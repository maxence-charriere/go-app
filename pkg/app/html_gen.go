package app

// Code generated by go generate; DO NOT EDIT.

import (
	"strings"
)

// The interface that represents a "a" HTML element.
type HTMLA interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLA

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLA

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLA

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLA

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLA

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLA

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLA

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLA

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLA

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLA

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLA

	// Hints the browser to download the linked resource, optionally providing a default filename.
	Download(format string, v ...any) HTMLA

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLA

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLA

	// Points to the URL of the destination when the link is clicked.
	Href(format string, v ...any) HTMLA

	// Declares the language of the linked document's content.
	HrefLang(format string, v ...any) HTMLA

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLA

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLA

	// Indicates the intended media or device for the linked document.
	Media(format string, v ...any) HTMLA

	// Lists URLs to be notified when the user activates the hyperlink.
	Ping(format string, v ...any) HTMLA

	// Describes the relationship between the current and linked documents.
	Rel(format string, v ...any) HTMLA

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLA

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLA

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLA

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLA

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLA

	// Indicates where to display the linked URL or where to submit the form. Can be called with various predefined values.
	Target(format string, v ...any) HTMLA

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLA

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLA

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLA

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLA

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLA

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLA

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLA

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLA

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLA

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLA

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLA

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLA

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLA

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLA

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLA

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLA

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLA

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLA

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLA

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLA

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLA

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLA

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLA

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLA

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLA

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLA

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLA

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLA

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLA

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLA

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLA
}

// Returns an HTML element that creates a hyperlink, allowing navigation to other web pages or resources.
func A() HTMLA {
	e := &htmlA{
		htmlElement: htmlElement{
			tag:           "a",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlA struct {
	htmlElement
}

func (e *htmlA) Body(v ...UI) HTMLA {
	return e.setBody(FilterUIElems(v...)).(*htmlA)
}

func (e *htmlA) Text(v any) HTMLA {
	return e.Body(Text(v))
}

func (e *htmlA) Textf(format string, v ...any) HTMLA {
	return e.Body(Textf(format, v...))
}

func (e *htmlA) AccessKey(format string, v ...any) HTMLA {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlA) Aria(k string, v any) HTMLA {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlA) Attr(n string, v any) HTMLA {
	e.setAttr(n, v)
	return e
}

func (e *htmlA) Class(v ...string) HTMLA {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlA) ContentEditable(v bool) HTMLA {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlA) DataSet(k string, v any) HTMLA {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlA) DataSets(ds map[string]any) HTMLA {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlA) Dir(format string, v ...any) HTMLA {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlA) Download(format string, v ...any) HTMLA {
	e.setAttr("download", FormatString(format, v...))
	return e
}

func (e *htmlA) Draggable(v bool) HTMLA {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlA) Hidden(v bool) HTMLA {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlA) Href(format string, v ...any) HTMLA {
	e.setAttr("href", FormatString(format, v...))
	return e
}

func (e *htmlA) HrefLang(format string, v ...any) HTMLA {
	e.setAttr("hreflang", FormatString(format, v...))
	return e
}

func (e *htmlA) ID(format string, v ...any) HTMLA {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlA) Lang(format string, v ...any) HTMLA {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlA) Media(format string, v ...any) HTMLA {
	e.setAttr("media", FormatString(format, v...))
	return e
}

func (e *htmlA) Ping(format string, v ...any) HTMLA {
	e.setAttr("ping", FormatString(format, v...))
	return e
}

func (e *htmlA) Rel(format string, v ...any) HTMLA {
	e.setAttr("rel", FormatString(format, v...))
	return e
}

func (e *htmlA) Role(format string, v ...any) HTMLA {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlA) Spellcheck(v bool) HTMLA {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlA) Style(k, format string, v ...any) HTMLA {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlA) Styles(s map[string]string) HTMLA {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlA) TabIndex(v int) HTMLA {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlA) Target(format string, v ...any) HTMLA {
	e.setAttr("target", FormatString(format, v...))
	return e
}

func (e *htmlA) Title(format string, v ...any) HTMLA {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlA) Type(format string, v ...any) HTMLA {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlA) On(event string, h EventHandler, options ...EventOption) HTMLA {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlA) OnBlur(h EventHandler, options ...EventOption) HTMLA {
	return e.On("blur", h, options...)
}

func (e *htmlA) OnChange(h EventHandler, options ...EventOption) HTMLA {
	return e.On("change", h, options...)
}

func (e *htmlA) OnClick(h EventHandler, options ...EventOption) HTMLA {
	return e.On("click", h, options...)
}

func (e *htmlA) OnContextMenu(h EventHandler, options ...EventOption) HTMLA {
	return e.On("contextmenu", h, options...)
}

func (e *htmlA) OnCopy(h EventHandler, options ...EventOption) HTMLA {
	return e.On("copy", h, options...)
}

func (e *htmlA) OnCut(h EventHandler, options ...EventOption) HTMLA {
	return e.On("cut", h, options...)
}

func (e *htmlA) OnDblClick(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dblclick", h, options...)
}

func (e *htmlA) OnDrag(h EventHandler, options ...EventOption) HTMLA {
	return e.On("drag", h, options...)
}

func (e *htmlA) OnDragEnd(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dragend", h, options...)
}

func (e *htmlA) OnDragEnter(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dragenter", h, options...)
}

func (e *htmlA) OnDragLeave(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dragleave", h, options...)
}

func (e *htmlA) OnDragOver(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dragover", h, options...)
}

func (e *htmlA) OnDragStart(h EventHandler, options ...EventOption) HTMLA {
	return e.On("dragstart", h, options...)
}

func (e *htmlA) OnDrop(h EventHandler, options ...EventOption) HTMLA {
	return e.On("drop", h, options...)
}

func (e *htmlA) OnFocus(h EventHandler, options ...EventOption) HTMLA {
	return e.On("focus", h, options...)
}

func (e *htmlA) OnInput(h EventHandler, options ...EventOption) HTMLA {
	return e.On("input", h, options...)
}

func (e *htmlA) OnInvalid(h EventHandler, options ...EventOption) HTMLA {
	return e.On("invalid", h, options...)
}

func (e *htmlA) OnKeyDown(h EventHandler, options ...EventOption) HTMLA {
	return e.On("keydown", h, options...)
}

func (e *htmlA) OnKeyPress(h EventHandler, options ...EventOption) HTMLA {
	return e.On("keypress", h, options...)
}

func (e *htmlA) OnKeyUp(h EventHandler, options ...EventOption) HTMLA {
	return e.On("keyup", h, options...)
}

func (e *htmlA) OnMouseDown(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mousedown", h, options...)
}

func (e *htmlA) OnMouseEnter(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mouseenter", h, options...)
}

func (e *htmlA) OnMouseLeave(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mouseleave", h, options...)
}

func (e *htmlA) OnMouseMove(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mousemove", h, options...)
}

func (e *htmlA) OnMouseOut(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mouseout", h, options...)
}

func (e *htmlA) OnMouseOver(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mouseover", h, options...)
}

func (e *htmlA) OnMouseUp(h EventHandler, options ...EventOption) HTMLA {
	return e.On("mouseup", h, options...)
}

func (e *htmlA) OnPaste(h EventHandler, options ...EventOption) HTMLA {
	return e.On("paste", h, options...)
}

func (e *htmlA) OnReset(h EventHandler, options ...EventOption) HTMLA {
	return e.On("reset", h, options...)
}

func (e *htmlA) OnScroll(h EventHandler, options ...EventOption) HTMLA {
	return e.On("scroll", h, options...)
}

func (e *htmlA) OnSearch(h EventHandler, options ...EventOption) HTMLA {
	return e.On("search", h, options...)
}

func (e *htmlA) OnSelect(h EventHandler, options ...EventOption) HTMLA {
	return e.On("select", h, options...)
}

func (e *htmlA) OnSubmit(h EventHandler, options ...EventOption) HTMLA {
	return e.On("submit", h, options...)
}

func (e *htmlA) OnWheel(h EventHandler, options ...EventOption) HTMLA {
	return e.On("wheel", h, options...)
}

func (e *htmlA) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlA) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlA) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlA) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlA) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlA) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "abbr" HTML element.
type HTMLAbbr interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLAbbr

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLAbbr

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLAbbr

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLAbbr

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLAbbr

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLAbbr

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLAbbr

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLAbbr

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLAbbr

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLAbbr

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLAbbr

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLAbbr

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLAbbr

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLAbbr

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLAbbr

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLAbbr

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLAbbr

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLAbbr

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLAbbr

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLAbbr

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLAbbr

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLAbbr

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLAbbr

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLAbbr

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLAbbr
}

// Returns an HTML element that represents an abbreviation or an acronym, providing a longer description or meaning of the content.
func Abbr() HTMLAbbr {
	e := &htmlAbbr{
		htmlElement: htmlElement{
			tag:           "abbr",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlAbbr struct {
	htmlElement
}

func (e *htmlAbbr) Body(v ...UI) HTMLAbbr {
	return e.setBody(FilterUIElems(v...)).(*htmlAbbr)
}

func (e *htmlAbbr) Text(v any) HTMLAbbr {
	return e.Body(Text(v))
}

func (e *htmlAbbr) Textf(format string, v ...any) HTMLAbbr {
	return e.Body(Textf(format, v...))
}

func (e *htmlAbbr) AccessKey(format string, v ...any) HTMLAbbr {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Aria(k string, v any) HTMLAbbr {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAbbr) Attr(n string, v any) HTMLAbbr {
	e.setAttr(n, v)
	return e
}

func (e *htmlAbbr) Class(v ...string) HTMLAbbr {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlAbbr) ContentEditable(v bool) HTMLAbbr {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlAbbr) DataSet(k string, v any) HTMLAbbr {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAbbr) DataSets(ds map[string]any) HTMLAbbr {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlAbbr) Dir(format string, v ...any) HTMLAbbr {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Draggable(v bool) HTMLAbbr {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlAbbr) Hidden(v bool) HTMLAbbr {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlAbbr) ID(format string, v ...any) HTMLAbbr {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Lang(format string, v ...any) HTMLAbbr {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Role(format string, v ...any) HTMLAbbr {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Spellcheck(v bool) HTMLAbbr {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlAbbr) Style(k, format string, v ...any) HTMLAbbr {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlAbbr) Styles(s map[string]string) HTMLAbbr {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlAbbr) TabIndex(v int) HTMLAbbr {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlAbbr) Title(format string, v ...any) HTMLAbbr {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlAbbr) On(event string, h EventHandler, options ...EventOption) HTMLAbbr {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlAbbr) OnBlur(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("blur", h, options...)
}

func (e *htmlAbbr) OnChange(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("change", h, options...)
}

func (e *htmlAbbr) OnClick(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("click", h, options...)
}

func (e *htmlAbbr) OnContextMenu(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("contextmenu", h, options...)
}

func (e *htmlAbbr) OnCopy(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("copy", h, options...)
}

func (e *htmlAbbr) OnCut(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("cut", h, options...)
}

func (e *htmlAbbr) OnDblClick(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dblclick", h, options...)
}

func (e *htmlAbbr) OnDrag(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("drag", h, options...)
}

func (e *htmlAbbr) OnDragEnd(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dragend", h, options...)
}

func (e *htmlAbbr) OnDragEnter(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dragenter", h, options...)
}

func (e *htmlAbbr) OnDragLeave(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dragleave", h, options...)
}

func (e *htmlAbbr) OnDragOver(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dragover", h, options...)
}

func (e *htmlAbbr) OnDragStart(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("dragstart", h, options...)
}

func (e *htmlAbbr) OnDrop(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("drop", h, options...)
}

func (e *htmlAbbr) OnFocus(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("focus", h, options...)
}

func (e *htmlAbbr) OnInput(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("input", h, options...)
}

func (e *htmlAbbr) OnInvalid(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("invalid", h, options...)
}

func (e *htmlAbbr) OnKeyDown(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("keydown", h, options...)
}

func (e *htmlAbbr) OnKeyPress(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("keypress", h, options...)
}

func (e *htmlAbbr) OnKeyUp(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("keyup", h, options...)
}

func (e *htmlAbbr) OnMouseDown(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mousedown", h, options...)
}

func (e *htmlAbbr) OnMouseEnter(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mouseenter", h, options...)
}

func (e *htmlAbbr) OnMouseLeave(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mouseleave", h, options...)
}

func (e *htmlAbbr) OnMouseMove(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mousemove", h, options...)
}

func (e *htmlAbbr) OnMouseOut(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mouseout", h, options...)
}

func (e *htmlAbbr) OnMouseOver(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mouseover", h, options...)
}

func (e *htmlAbbr) OnMouseUp(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("mouseup", h, options...)
}

func (e *htmlAbbr) OnPaste(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("paste", h, options...)
}

func (e *htmlAbbr) OnReset(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("reset", h, options...)
}

func (e *htmlAbbr) OnScroll(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("scroll", h, options...)
}

func (e *htmlAbbr) OnSearch(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("search", h, options...)
}

func (e *htmlAbbr) OnSelect(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("select", h, options...)
}

func (e *htmlAbbr) OnSubmit(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("submit", h, options...)
}

func (e *htmlAbbr) OnWheel(h EventHandler, options ...EventOption) HTMLAbbr {
	return e.On("wheel", h, options...)
}

func (e *htmlAbbr) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlAbbr) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlAbbr) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlAbbr) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlAbbr) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlAbbr) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "address" HTML element.
type HTMLAddress interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLAddress

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLAddress

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLAddress

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLAddress

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLAddress

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLAddress

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLAddress

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLAddress

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLAddress

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLAddress

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLAddress

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLAddress

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLAddress

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLAddress

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLAddress

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLAddress

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLAddress

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLAddress

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLAddress

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLAddress

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLAddress

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLAddress

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLAddress

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLAddress

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLAddress

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLAddress
}

// Returns an HTML element that designates contact information for the author or owner of a document or web page.
func Address() HTMLAddress {
	e := &htmlAddress{
		htmlElement: htmlElement{
			tag:           "address",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlAddress struct {
	htmlElement
}

func (e *htmlAddress) Body(v ...UI) HTMLAddress {
	return e.setBody(FilterUIElems(v...)).(*htmlAddress)
}

func (e *htmlAddress) Text(v any) HTMLAddress {
	return e.Body(Text(v))
}

func (e *htmlAddress) Textf(format string, v ...any) HTMLAddress {
	return e.Body(Textf(format, v...))
}

func (e *htmlAddress) AccessKey(format string, v ...any) HTMLAddress {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlAddress) Aria(k string, v any) HTMLAddress {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAddress) Attr(n string, v any) HTMLAddress {
	e.setAttr(n, v)
	return e
}

func (e *htmlAddress) Class(v ...string) HTMLAddress {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlAddress) ContentEditable(v bool) HTMLAddress {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlAddress) DataSet(k string, v any) HTMLAddress {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAddress) DataSets(ds map[string]any) HTMLAddress {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlAddress) Dir(format string, v ...any) HTMLAddress {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlAddress) Draggable(v bool) HTMLAddress {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlAddress) Hidden(v bool) HTMLAddress {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlAddress) ID(format string, v ...any) HTMLAddress {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlAddress) Lang(format string, v ...any) HTMLAddress {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlAddress) Role(format string, v ...any) HTMLAddress {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlAddress) Spellcheck(v bool) HTMLAddress {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlAddress) Style(k, format string, v ...any) HTMLAddress {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlAddress) Styles(s map[string]string) HTMLAddress {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlAddress) TabIndex(v int) HTMLAddress {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlAddress) Title(format string, v ...any) HTMLAddress {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlAddress) On(event string, h EventHandler, options ...EventOption) HTMLAddress {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlAddress) OnBlur(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("blur", h, options...)
}

func (e *htmlAddress) OnChange(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("change", h, options...)
}

func (e *htmlAddress) OnClick(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("click", h, options...)
}

func (e *htmlAddress) OnContextMenu(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("contextmenu", h, options...)
}

func (e *htmlAddress) OnCopy(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("copy", h, options...)
}

func (e *htmlAddress) OnCut(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("cut", h, options...)
}

func (e *htmlAddress) OnDblClick(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dblclick", h, options...)
}

func (e *htmlAddress) OnDrag(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("drag", h, options...)
}

func (e *htmlAddress) OnDragEnd(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dragend", h, options...)
}

func (e *htmlAddress) OnDragEnter(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dragenter", h, options...)
}

func (e *htmlAddress) OnDragLeave(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dragleave", h, options...)
}

func (e *htmlAddress) OnDragOver(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dragover", h, options...)
}

func (e *htmlAddress) OnDragStart(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("dragstart", h, options...)
}

func (e *htmlAddress) OnDrop(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("drop", h, options...)
}

func (e *htmlAddress) OnFocus(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("focus", h, options...)
}

func (e *htmlAddress) OnInput(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("input", h, options...)
}

func (e *htmlAddress) OnInvalid(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("invalid", h, options...)
}

func (e *htmlAddress) OnKeyDown(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("keydown", h, options...)
}

func (e *htmlAddress) OnKeyPress(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("keypress", h, options...)
}

func (e *htmlAddress) OnKeyUp(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("keyup", h, options...)
}

func (e *htmlAddress) OnMouseDown(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mousedown", h, options...)
}

func (e *htmlAddress) OnMouseEnter(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mouseenter", h, options...)
}

func (e *htmlAddress) OnMouseLeave(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mouseleave", h, options...)
}

func (e *htmlAddress) OnMouseMove(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mousemove", h, options...)
}

func (e *htmlAddress) OnMouseOut(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mouseout", h, options...)
}

func (e *htmlAddress) OnMouseOver(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mouseover", h, options...)
}

func (e *htmlAddress) OnMouseUp(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("mouseup", h, options...)
}

func (e *htmlAddress) OnPaste(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("paste", h, options...)
}

func (e *htmlAddress) OnReset(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("reset", h, options...)
}

func (e *htmlAddress) OnScroll(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("scroll", h, options...)
}

func (e *htmlAddress) OnSearch(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("search", h, options...)
}

func (e *htmlAddress) OnSelect(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("select", h, options...)
}

func (e *htmlAddress) OnSubmit(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("submit", h, options...)
}

func (e *htmlAddress) OnWheel(h EventHandler, options ...EventOption) HTMLAddress {
	return e.On("wheel", h, options...)
}

func (e *htmlAddress) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlAddress) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlAddress) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlAddress) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlAddress) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlAddress) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "area" HTML element.
type HTMLArea interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLArea

	// Provides a text alternative for elements (often images) ensuring content is accessible when visuals can't be rendered.
	Alt(format string, v ...any) HTMLArea

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLArea

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLArea

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLArea

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLArea

	// Defines the coordinates for elements in an image map, establishing active regions for hyperlinks.
	Coords(format string, v ...any) HTMLArea

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLArea

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLArea

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLArea

	// Hints the browser to download the linked resource, optionally providing a default filename.
	Download(format string, v ...any) HTMLArea

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLArea

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLArea

	// Points to the URL of the destination when the link is clicked.
	Href(format string, v ...any) HTMLArea

	// Declares the language of the linked document's content.
	HrefLang(format string, v ...any) HTMLArea

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLArea

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLArea

	// Indicates the intended media or device for the linked document.
	Media(format string, v ...any) HTMLArea

	// Describes the relationship between the current and linked documents.
	Rel(format string, v ...any) HTMLArea

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLArea

	// Describes the shape of a clickable area within an image map. Uses the given format and values.
	Shape(format string, v ...any) HTMLArea

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLArea

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLArea

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLArea

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLArea

	// Indicates where to display the linked URL or where to submit the form. Can be called with various predefined values.
	Target(format string, v ...any) HTMLArea

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLArea

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLArea

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLArea

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLArea

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLArea

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLArea

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLArea

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLArea

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLArea

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLArea

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLArea

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLArea

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLArea

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLArea

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLArea

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLArea

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLArea
}

// Returns an HTML element that defines a clickable region within an image map, usually linking to another resource.
func Area() HTMLArea {
	e := &htmlArea{
		htmlElement: htmlElement{
			tag:           "area",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlArea struct {
	htmlElement
}

func (e *htmlArea) AccessKey(format string, v ...any) HTMLArea {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlArea) Alt(format string, v ...any) HTMLArea {
	e.setAttr("alt", FormatString(format, v...))
	return e
}

func (e *htmlArea) Aria(k string, v any) HTMLArea {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlArea) Attr(n string, v any) HTMLArea {
	e.setAttr(n, v)
	return e
}

func (e *htmlArea) Class(v ...string) HTMLArea {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlArea) ContentEditable(v bool) HTMLArea {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlArea) Coords(format string, v ...any) HTMLArea {
	e.setAttr("coords", FormatString(format, v...))
	return e
}

func (e *htmlArea) DataSet(k string, v any) HTMLArea {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlArea) DataSets(ds map[string]any) HTMLArea {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlArea) Dir(format string, v ...any) HTMLArea {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlArea) Download(format string, v ...any) HTMLArea {
	e.setAttr("download", FormatString(format, v...))
	return e
}

func (e *htmlArea) Draggable(v bool) HTMLArea {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlArea) Hidden(v bool) HTMLArea {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlArea) Href(format string, v ...any) HTMLArea {
	e.setAttr("href", FormatString(format, v...))
	return e
}

func (e *htmlArea) HrefLang(format string, v ...any) HTMLArea {
	e.setAttr("hreflang", FormatString(format, v...))
	return e
}

func (e *htmlArea) ID(format string, v ...any) HTMLArea {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlArea) Lang(format string, v ...any) HTMLArea {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlArea) Media(format string, v ...any) HTMLArea {
	e.setAttr("media", FormatString(format, v...))
	return e
}

func (e *htmlArea) Rel(format string, v ...any) HTMLArea {
	e.setAttr("rel", FormatString(format, v...))
	return e
}

func (e *htmlArea) Role(format string, v ...any) HTMLArea {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlArea) Shape(format string, v ...any) HTMLArea {
	e.setAttr("shape", FormatString(format, v...))
	return e
}

func (e *htmlArea) Spellcheck(v bool) HTMLArea {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlArea) Style(k, format string, v ...any) HTMLArea {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlArea) Styles(s map[string]string) HTMLArea {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlArea) TabIndex(v int) HTMLArea {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlArea) Target(format string, v ...any) HTMLArea {
	e.setAttr("target", FormatString(format, v...))
	return e
}

func (e *htmlArea) Title(format string, v ...any) HTMLArea {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlArea) Type(format string, v ...any) HTMLArea {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlArea) On(event string, h EventHandler, options ...EventOption) HTMLArea {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlArea) OnBlur(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("blur", h, options...)
}

func (e *htmlArea) OnChange(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("change", h, options...)
}

func (e *htmlArea) OnClick(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("click", h, options...)
}

func (e *htmlArea) OnContextMenu(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("contextmenu", h, options...)
}

func (e *htmlArea) OnCopy(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("copy", h, options...)
}

func (e *htmlArea) OnCut(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("cut", h, options...)
}

func (e *htmlArea) OnDblClick(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dblclick", h, options...)
}

func (e *htmlArea) OnDrag(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("drag", h, options...)
}

func (e *htmlArea) OnDragEnd(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dragend", h, options...)
}

func (e *htmlArea) OnDragEnter(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dragenter", h, options...)
}

func (e *htmlArea) OnDragLeave(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dragleave", h, options...)
}

func (e *htmlArea) OnDragOver(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dragover", h, options...)
}

func (e *htmlArea) OnDragStart(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("dragstart", h, options...)
}

func (e *htmlArea) OnDrop(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("drop", h, options...)
}

func (e *htmlArea) OnFocus(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("focus", h, options...)
}

func (e *htmlArea) OnInput(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("input", h, options...)
}

func (e *htmlArea) OnInvalid(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("invalid", h, options...)
}

func (e *htmlArea) OnKeyDown(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("keydown", h, options...)
}

func (e *htmlArea) OnKeyPress(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("keypress", h, options...)
}

func (e *htmlArea) OnKeyUp(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("keyup", h, options...)
}

func (e *htmlArea) OnMouseDown(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mousedown", h, options...)
}

func (e *htmlArea) OnMouseEnter(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mouseenter", h, options...)
}

func (e *htmlArea) OnMouseLeave(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mouseleave", h, options...)
}

func (e *htmlArea) OnMouseMove(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mousemove", h, options...)
}

func (e *htmlArea) OnMouseOut(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mouseout", h, options...)
}

func (e *htmlArea) OnMouseOver(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mouseover", h, options...)
}

func (e *htmlArea) OnMouseUp(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("mouseup", h, options...)
}

func (e *htmlArea) OnPaste(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("paste", h, options...)
}

func (e *htmlArea) OnReset(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("reset", h, options...)
}

func (e *htmlArea) OnScroll(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("scroll", h, options...)
}

func (e *htmlArea) OnSearch(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("search", h, options...)
}

func (e *htmlArea) OnSelect(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("select", h, options...)
}

func (e *htmlArea) OnSubmit(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("submit", h, options...)
}

func (e *htmlArea) OnWheel(h EventHandler, options ...EventOption) HTMLArea {
	return e.On("wheel", h, options...)
}

func (e *htmlArea) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlArea) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlArea) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlArea) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlArea) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlArea) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "article" HTML element.
type HTMLArticle interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLArticle

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLArticle

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLArticle

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLArticle

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLArticle

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLArticle

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLArticle

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLArticle

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLArticle

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLArticle

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLArticle

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLArticle

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLArticle

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLArticle

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLArticle

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLArticle

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLArticle

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLArticle

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLArticle

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLArticle

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLArticle

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLArticle

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLArticle

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLArticle

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLArticle

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLArticle
}

// Returns an HTML element that marks a self-contained composition in a document, like a blog post or news story.
func Article() HTMLArticle {
	e := &htmlArticle{
		htmlElement: htmlElement{
			tag:           "article",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlArticle struct {
	htmlElement
}

func (e *htmlArticle) Body(v ...UI) HTMLArticle {
	return e.setBody(FilterUIElems(v...)).(*htmlArticle)
}

func (e *htmlArticle) Text(v any) HTMLArticle {
	return e.Body(Text(v))
}

func (e *htmlArticle) Textf(format string, v ...any) HTMLArticle {
	return e.Body(Textf(format, v...))
}

func (e *htmlArticle) AccessKey(format string, v ...any) HTMLArticle {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlArticle) Aria(k string, v any) HTMLArticle {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlArticle) Attr(n string, v any) HTMLArticle {
	e.setAttr(n, v)
	return e
}

func (e *htmlArticle) Class(v ...string) HTMLArticle {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlArticle) ContentEditable(v bool) HTMLArticle {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlArticle) DataSet(k string, v any) HTMLArticle {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlArticle) DataSets(ds map[string]any) HTMLArticle {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlArticle) Dir(format string, v ...any) HTMLArticle {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlArticle) Draggable(v bool) HTMLArticle {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlArticle) Hidden(v bool) HTMLArticle {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlArticle) ID(format string, v ...any) HTMLArticle {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlArticle) Lang(format string, v ...any) HTMLArticle {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlArticle) Role(format string, v ...any) HTMLArticle {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlArticle) Spellcheck(v bool) HTMLArticle {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlArticle) Style(k, format string, v ...any) HTMLArticle {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlArticle) Styles(s map[string]string) HTMLArticle {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlArticle) TabIndex(v int) HTMLArticle {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlArticle) Title(format string, v ...any) HTMLArticle {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlArticle) On(event string, h EventHandler, options ...EventOption) HTMLArticle {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlArticle) OnBlur(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("blur", h, options...)
}

func (e *htmlArticle) OnChange(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("change", h, options...)
}

func (e *htmlArticle) OnClick(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("click", h, options...)
}

func (e *htmlArticle) OnContextMenu(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("contextmenu", h, options...)
}

func (e *htmlArticle) OnCopy(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("copy", h, options...)
}

func (e *htmlArticle) OnCut(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("cut", h, options...)
}

func (e *htmlArticle) OnDblClick(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dblclick", h, options...)
}

func (e *htmlArticle) OnDrag(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("drag", h, options...)
}

func (e *htmlArticle) OnDragEnd(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dragend", h, options...)
}

func (e *htmlArticle) OnDragEnter(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dragenter", h, options...)
}

func (e *htmlArticle) OnDragLeave(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dragleave", h, options...)
}

func (e *htmlArticle) OnDragOver(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dragover", h, options...)
}

func (e *htmlArticle) OnDragStart(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("dragstart", h, options...)
}

func (e *htmlArticle) OnDrop(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("drop", h, options...)
}

func (e *htmlArticle) OnFocus(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("focus", h, options...)
}

func (e *htmlArticle) OnInput(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("input", h, options...)
}

func (e *htmlArticle) OnInvalid(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("invalid", h, options...)
}

func (e *htmlArticle) OnKeyDown(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("keydown", h, options...)
}

func (e *htmlArticle) OnKeyPress(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("keypress", h, options...)
}

func (e *htmlArticle) OnKeyUp(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("keyup", h, options...)
}

func (e *htmlArticle) OnMouseDown(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mousedown", h, options...)
}

func (e *htmlArticle) OnMouseEnter(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mouseenter", h, options...)
}

func (e *htmlArticle) OnMouseLeave(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mouseleave", h, options...)
}

func (e *htmlArticle) OnMouseMove(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mousemove", h, options...)
}

func (e *htmlArticle) OnMouseOut(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mouseout", h, options...)
}

func (e *htmlArticle) OnMouseOver(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mouseover", h, options...)
}

func (e *htmlArticle) OnMouseUp(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("mouseup", h, options...)
}

func (e *htmlArticle) OnPaste(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("paste", h, options...)
}

func (e *htmlArticle) OnReset(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("reset", h, options...)
}

func (e *htmlArticle) OnScroll(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("scroll", h, options...)
}

func (e *htmlArticle) OnSearch(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("search", h, options...)
}

func (e *htmlArticle) OnSelect(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("select", h, options...)
}

func (e *htmlArticle) OnSubmit(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("submit", h, options...)
}

func (e *htmlArticle) OnWheel(h EventHandler, options ...EventOption) HTMLArticle {
	return e.On("wheel", h, options...)
}

func (e *htmlArticle) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlArticle) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlArticle) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlArticle) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlArticle) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlArticle) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "aside" HTML element.
type HTMLAside interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLAside

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLAside

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLAside

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLAside

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLAside

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLAside

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLAside

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLAside

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLAside

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLAside

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLAside

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLAside

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLAside

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLAside

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLAside

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLAside

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLAside

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLAside

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLAside

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLAside

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLAside

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLAside

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLAside

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLAside

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLAside

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLAside

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLAside

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLAside

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLAside

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLAside

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLAside

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLAside

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLAside

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLAside

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLAside

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLAside
}

// Returns an HTML element that represents content tangentially related to the main content, and can be considered separate.
func Aside() HTMLAside {
	e := &htmlAside{
		htmlElement: htmlElement{
			tag:           "aside",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlAside struct {
	htmlElement
}

func (e *htmlAside) Body(v ...UI) HTMLAside {
	return e.setBody(FilterUIElems(v...)).(*htmlAside)
}

func (e *htmlAside) Text(v any) HTMLAside {
	return e.Body(Text(v))
}

func (e *htmlAside) Textf(format string, v ...any) HTMLAside {
	return e.Body(Textf(format, v...))
}

func (e *htmlAside) AccessKey(format string, v ...any) HTMLAside {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlAside) Aria(k string, v any) HTMLAside {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAside) Attr(n string, v any) HTMLAside {
	e.setAttr(n, v)
	return e
}

func (e *htmlAside) Class(v ...string) HTMLAside {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlAside) ContentEditable(v bool) HTMLAside {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlAside) DataSet(k string, v any) HTMLAside {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAside) DataSets(ds map[string]any) HTMLAside {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlAside) Dir(format string, v ...any) HTMLAside {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlAside) Draggable(v bool) HTMLAside {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlAside) Hidden(v bool) HTMLAside {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlAside) ID(format string, v ...any) HTMLAside {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlAside) Lang(format string, v ...any) HTMLAside {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlAside) Role(format string, v ...any) HTMLAside {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlAside) Spellcheck(v bool) HTMLAside {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlAside) Style(k, format string, v ...any) HTMLAside {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlAside) Styles(s map[string]string) HTMLAside {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlAside) TabIndex(v int) HTMLAside {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlAside) Title(format string, v ...any) HTMLAside {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlAside) On(event string, h EventHandler, options ...EventOption) HTMLAside {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlAside) OnBlur(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("blur", h, options...)
}

func (e *htmlAside) OnChange(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("change", h, options...)
}

func (e *htmlAside) OnClick(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("click", h, options...)
}

func (e *htmlAside) OnContextMenu(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("contextmenu", h, options...)
}

func (e *htmlAside) OnCopy(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("copy", h, options...)
}

func (e *htmlAside) OnCut(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("cut", h, options...)
}

func (e *htmlAside) OnDblClick(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dblclick", h, options...)
}

func (e *htmlAside) OnDrag(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("drag", h, options...)
}

func (e *htmlAside) OnDragEnd(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dragend", h, options...)
}

func (e *htmlAside) OnDragEnter(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dragenter", h, options...)
}

func (e *htmlAside) OnDragLeave(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dragleave", h, options...)
}

func (e *htmlAside) OnDragOver(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dragover", h, options...)
}

func (e *htmlAside) OnDragStart(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("dragstart", h, options...)
}

func (e *htmlAside) OnDrop(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("drop", h, options...)
}

func (e *htmlAside) OnFocus(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("focus", h, options...)
}

func (e *htmlAside) OnInput(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("input", h, options...)
}

func (e *htmlAside) OnInvalid(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("invalid", h, options...)
}

func (e *htmlAside) OnKeyDown(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("keydown", h, options...)
}

func (e *htmlAside) OnKeyPress(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("keypress", h, options...)
}

func (e *htmlAside) OnKeyUp(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("keyup", h, options...)
}

func (e *htmlAside) OnMouseDown(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mousedown", h, options...)
}

func (e *htmlAside) OnMouseEnter(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mouseenter", h, options...)
}

func (e *htmlAside) OnMouseLeave(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mouseleave", h, options...)
}

func (e *htmlAside) OnMouseMove(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mousemove", h, options...)
}

func (e *htmlAside) OnMouseOut(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mouseout", h, options...)
}

func (e *htmlAside) OnMouseOver(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mouseover", h, options...)
}

func (e *htmlAside) OnMouseUp(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("mouseup", h, options...)
}

func (e *htmlAside) OnPaste(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("paste", h, options...)
}

func (e *htmlAside) OnReset(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("reset", h, options...)
}

func (e *htmlAside) OnScroll(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("scroll", h, options...)
}

func (e *htmlAside) OnSearch(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("search", h, options...)
}

func (e *htmlAside) OnSelect(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("select", h, options...)
}

func (e *htmlAside) OnSubmit(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("submit", h, options...)
}

func (e *htmlAside) OnWheel(h EventHandler, options ...EventOption) HTMLAside {
	return e.On("wheel", h, options...)
}

func (e *htmlAside) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlAside) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlAside) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlAside) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlAside) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlAside) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "audio" HTML element.
type HTMLAudio interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLAudio

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLAudio

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLAudio

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLAudio

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLAudio

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLAudio

	// Automatically plays audio or video elements once they're ready, enhancing media responsiveness.
	AutoPlay(v bool) HTMLAudio

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLAudio

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLAudio

	// Indicates the presence of user interface controls for audio or video elements, such as play or pause buttons.
	Controls(v bool) HTMLAudio

	// Controls how cross-origin requests are managed for the element, supporting secure content integration from different origins.
	CrossOrigin(format string, v ...any) HTMLAudio

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLAudio

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLAudio

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLAudio

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLAudio

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLAudio

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLAudio

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLAudio

	// Indicates that the audio or video should replay from the beginning upon reaching its end.
	Loop(v bool) HTMLAudio

	// Ensures that the video's audio playback is muted.
	Muted(v bool) HTMLAudio

	// Indicates the preferred loading method for audio/video upon page load.
	Preload(format string, v ...any) HTMLAudio

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLAudio

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLAudio

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLAudio

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLAudio

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLAudio

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLAudio

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLAudio

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when media loading is aborted.
	OnAbort(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler when media has buffered sufficiently to begin playback.
	OnCanPlay(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when media can be played through without buffering interruptions.
	OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler upon cue changes within a track element.
	OnCueChange(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler when the media's duration changes.
	OnDurationChange(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when media unexpectedly becomes unavailable.
	OnEmptied(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when media playback reaches the end.
	OnEnded(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when media loading commences.
	OnLoadStart(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler as media data finishes loading.
	OnLoadedData(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when metadata (like duration and dimensions) are fully loaded.
	OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler when media playback is paused.
	OnPause(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when media starts its playback.
	OnPlay(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler once the media has initiated playback.
	OnPlaying(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler while the browser fetches media data.
	OnProgress(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when playback rate changes (e.g., slow motion or fast forward).
	OnRateChange(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler post seeking completion.
	OnSeeked(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler during the seeking process.
	OnSeeking(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler when media data fetching stalls.
	OnStalled(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when media data fetching is suspended.
	OnSuspend(h EventHandler, options ...EventOption) HTMLAudio

	// Executes the handler when the media's playback position changes.
	OnTimeUpdate(h EventHandler, options ...EventOption) HTMLAudio

	// Invokes the handler upon volume changes or muting.
	OnVolumeChange(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the handler when media pauses, awaiting further buffering.
	OnWaiting(h EventHandler, options ...EventOption) HTMLAudio

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLAudio
}

// Returns an HTML element that embeds an audio player for playing sound or music content.
func Audio() HTMLAudio {
	e := &htmlAudio{
		htmlElement: htmlElement{
			tag:           "audio",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlAudio struct {
	htmlElement
}

func (e *htmlAudio) Body(v ...UI) HTMLAudio {
	return e.setBody(FilterUIElems(v...)).(*htmlAudio)
}

func (e *htmlAudio) Text(v any) HTMLAudio {
	return e.Body(Text(v))
}

func (e *htmlAudio) Textf(format string, v ...any) HTMLAudio {
	return e.Body(Textf(format, v...))
}

func (e *htmlAudio) AccessKey(format string, v ...any) HTMLAudio {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Aria(k string, v any) HTMLAudio {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAudio) Attr(n string, v any) HTMLAudio {
	e.setAttr(n, v)
	return e
}

func (e *htmlAudio) AutoPlay(v bool) HTMLAudio {
	e.setAttr("autoplay", v)
	return e
}

func (e *htmlAudio) Class(v ...string) HTMLAudio {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlAudio) ContentEditable(v bool) HTMLAudio {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlAudio) Controls(v bool) HTMLAudio {
	e.setAttr("controls", v)
	return e
}

func (e *htmlAudio) CrossOrigin(format string, v ...any) HTMLAudio {
	e.setAttr("crossorigin", FormatString(format, v...))
	return e
}

func (e *htmlAudio) DataSet(k string, v any) HTMLAudio {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlAudio) DataSets(ds map[string]any) HTMLAudio {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlAudio) Dir(format string, v ...any) HTMLAudio {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Draggable(v bool) HTMLAudio {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlAudio) Hidden(v bool) HTMLAudio {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlAudio) ID(format string, v ...any) HTMLAudio {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Lang(format string, v ...any) HTMLAudio {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Loop(v bool) HTMLAudio {
	e.setAttr("loop", v)
	return e
}

func (e *htmlAudio) Muted(v bool) HTMLAudio {
	e.setAttr("muted", v)
	return e
}

func (e *htmlAudio) Preload(format string, v ...any) HTMLAudio {
	e.setAttr("preload", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Role(format string, v ...any) HTMLAudio {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Spellcheck(v bool) HTMLAudio {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlAudio) Src(format string, v ...any) HTMLAudio {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlAudio) Style(k, format string, v ...any) HTMLAudio {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlAudio) Styles(s map[string]string) HTMLAudio {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlAudio) TabIndex(v int) HTMLAudio {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlAudio) Title(format string, v ...any) HTMLAudio {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlAudio) On(event string, h EventHandler, options ...EventOption) HTMLAudio {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlAudio) OnAbort(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("abort", h, options...)
}

func (e *htmlAudio) OnBlur(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("blur", h, options...)
}

func (e *htmlAudio) OnCanPlay(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("canplay", h, options...)
}

func (e *htmlAudio) OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("canplaythrough", h, options...)
}

func (e *htmlAudio) OnChange(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("change", h, options...)
}

func (e *htmlAudio) OnClick(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("click", h, options...)
}

func (e *htmlAudio) OnContextMenu(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("contextmenu", h, options...)
}

func (e *htmlAudio) OnCopy(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("copy", h, options...)
}

func (e *htmlAudio) OnCueChange(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("cuechange", h, options...)
}

func (e *htmlAudio) OnCut(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("cut", h, options...)
}

func (e *htmlAudio) OnDblClick(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dblclick", h, options...)
}

func (e *htmlAudio) OnDrag(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("drag", h, options...)
}

func (e *htmlAudio) OnDragEnd(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dragend", h, options...)
}

func (e *htmlAudio) OnDragEnter(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dragenter", h, options...)
}

func (e *htmlAudio) OnDragLeave(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dragleave", h, options...)
}

func (e *htmlAudio) OnDragOver(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dragover", h, options...)
}

func (e *htmlAudio) OnDragStart(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("dragstart", h, options...)
}

func (e *htmlAudio) OnDrop(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("drop", h, options...)
}

func (e *htmlAudio) OnDurationChange(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("durationchange", h, options...)
}

func (e *htmlAudio) OnEmptied(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("emptied", h, options...)
}

func (e *htmlAudio) OnEnded(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("ended", h, options...)
}

func (e *htmlAudio) OnError(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("error", h, options...)
}

func (e *htmlAudio) OnFocus(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("focus", h, options...)
}

func (e *htmlAudio) OnInput(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("input", h, options...)
}

func (e *htmlAudio) OnInvalid(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("invalid", h, options...)
}

func (e *htmlAudio) OnKeyDown(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("keydown", h, options...)
}

func (e *htmlAudio) OnKeyPress(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("keypress", h, options...)
}

func (e *htmlAudio) OnKeyUp(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("keyup", h, options...)
}

func (e *htmlAudio) OnLoadStart(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("loadstart", h, options...)
}

func (e *htmlAudio) OnLoadedData(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("loadeddata", h, options...)
}

func (e *htmlAudio) OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("loadedmetadata", h, options...)
}

func (e *htmlAudio) OnMouseDown(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mousedown", h, options...)
}

func (e *htmlAudio) OnMouseEnter(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mouseenter", h, options...)
}

func (e *htmlAudio) OnMouseLeave(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mouseleave", h, options...)
}

func (e *htmlAudio) OnMouseMove(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mousemove", h, options...)
}

func (e *htmlAudio) OnMouseOut(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mouseout", h, options...)
}

func (e *htmlAudio) OnMouseOver(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mouseover", h, options...)
}

func (e *htmlAudio) OnMouseUp(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("mouseup", h, options...)
}

func (e *htmlAudio) OnPaste(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("paste", h, options...)
}

func (e *htmlAudio) OnPause(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("pause", h, options...)
}

func (e *htmlAudio) OnPlay(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("play", h, options...)
}

func (e *htmlAudio) OnPlaying(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("playing", h, options...)
}

func (e *htmlAudio) OnProgress(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("progress", h, options...)
}

func (e *htmlAudio) OnRateChange(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("ratechange", h, options...)
}

func (e *htmlAudio) OnReset(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("reset", h, options...)
}

func (e *htmlAudio) OnScroll(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("scroll", h, options...)
}

func (e *htmlAudio) OnSearch(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("search", h, options...)
}

func (e *htmlAudio) OnSeeked(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("seeked", h, options...)
}

func (e *htmlAudio) OnSeeking(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("seeking", h, options...)
}

func (e *htmlAudio) OnSelect(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("select", h, options...)
}

func (e *htmlAudio) OnStalled(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("stalled", h, options...)
}

func (e *htmlAudio) OnSubmit(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("submit", h, options...)
}

func (e *htmlAudio) OnSuspend(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("suspend", h, options...)
}

func (e *htmlAudio) OnTimeUpdate(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("timeupdate", h, options...)
}

func (e *htmlAudio) OnVolumeChange(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("volumechange", h, options...)
}

func (e *htmlAudio) OnWaiting(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("waiting", h, options...)
}

func (e *htmlAudio) OnWheel(h EventHandler, options ...EventOption) HTMLAudio {
	return e.On("wheel", h, options...)
}

func (e *htmlAudio) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlAudio) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlAudio) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlAudio) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlAudio) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlAudio) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "b" HTML element.
type HTMLB interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLB

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLB

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLB

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLB

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLB

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLB

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLB

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLB

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLB

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLB

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLB

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLB

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLB

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLB

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLB

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLB

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLB

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLB

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLB

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLB

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLB

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLB

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLB

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLB

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLB

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLB

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLB

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLB

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLB

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLB

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLB

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLB

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLB

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLB

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLB

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLB

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLB

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLB

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLB

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLB

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLB

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLB

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLB

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLB

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLB

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLB

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLB

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLB

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLB

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLB
}

// Returns an HTML element that applies bold styling to its content.
func B() HTMLB {
	e := &htmlB{
		htmlElement: htmlElement{
			tag:           "b",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlB struct {
	htmlElement
}

func (e *htmlB) Body(v ...UI) HTMLB {
	return e.setBody(FilterUIElems(v...)).(*htmlB)
}

func (e *htmlB) Text(v any) HTMLB {
	return e.Body(Text(v))
}

func (e *htmlB) Textf(format string, v ...any) HTMLB {
	return e.Body(Textf(format, v...))
}

func (e *htmlB) AccessKey(format string, v ...any) HTMLB {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlB) Aria(k string, v any) HTMLB {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlB) Attr(n string, v any) HTMLB {
	e.setAttr(n, v)
	return e
}

func (e *htmlB) Class(v ...string) HTMLB {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlB) ContentEditable(v bool) HTMLB {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlB) DataSet(k string, v any) HTMLB {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlB) DataSets(ds map[string]any) HTMLB {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlB) Dir(format string, v ...any) HTMLB {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlB) Draggable(v bool) HTMLB {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlB) Hidden(v bool) HTMLB {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlB) ID(format string, v ...any) HTMLB {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlB) Lang(format string, v ...any) HTMLB {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlB) Role(format string, v ...any) HTMLB {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlB) Spellcheck(v bool) HTMLB {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlB) Style(k, format string, v ...any) HTMLB {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlB) Styles(s map[string]string) HTMLB {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlB) TabIndex(v int) HTMLB {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlB) Title(format string, v ...any) HTMLB {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlB) On(event string, h EventHandler, options ...EventOption) HTMLB {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlB) OnBlur(h EventHandler, options ...EventOption) HTMLB {
	return e.On("blur", h, options...)
}

func (e *htmlB) OnChange(h EventHandler, options ...EventOption) HTMLB {
	return e.On("change", h, options...)
}

func (e *htmlB) OnClick(h EventHandler, options ...EventOption) HTMLB {
	return e.On("click", h, options...)
}

func (e *htmlB) OnContextMenu(h EventHandler, options ...EventOption) HTMLB {
	return e.On("contextmenu", h, options...)
}

func (e *htmlB) OnCopy(h EventHandler, options ...EventOption) HTMLB {
	return e.On("copy", h, options...)
}

func (e *htmlB) OnCut(h EventHandler, options ...EventOption) HTMLB {
	return e.On("cut", h, options...)
}

func (e *htmlB) OnDblClick(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dblclick", h, options...)
}

func (e *htmlB) OnDrag(h EventHandler, options ...EventOption) HTMLB {
	return e.On("drag", h, options...)
}

func (e *htmlB) OnDragEnd(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dragend", h, options...)
}

func (e *htmlB) OnDragEnter(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dragenter", h, options...)
}

func (e *htmlB) OnDragLeave(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dragleave", h, options...)
}

func (e *htmlB) OnDragOver(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dragover", h, options...)
}

func (e *htmlB) OnDragStart(h EventHandler, options ...EventOption) HTMLB {
	return e.On("dragstart", h, options...)
}

func (e *htmlB) OnDrop(h EventHandler, options ...EventOption) HTMLB {
	return e.On("drop", h, options...)
}

func (e *htmlB) OnFocus(h EventHandler, options ...EventOption) HTMLB {
	return e.On("focus", h, options...)
}

func (e *htmlB) OnInput(h EventHandler, options ...EventOption) HTMLB {
	return e.On("input", h, options...)
}

func (e *htmlB) OnInvalid(h EventHandler, options ...EventOption) HTMLB {
	return e.On("invalid", h, options...)
}

func (e *htmlB) OnKeyDown(h EventHandler, options ...EventOption) HTMLB {
	return e.On("keydown", h, options...)
}

func (e *htmlB) OnKeyPress(h EventHandler, options ...EventOption) HTMLB {
	return e.On("keypress", h, options...)
}

func (e *htmlB) OnKeyUp(h EventHandler, options ...EventOption) HTMLB {
	return e.On("keyup", h, options...)
}

func (e *htmlB) OnMouseDown(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mousedown", h, options...)
}

func (e *htmlB) OnMouseEnter(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mouseenter", h, options...)
}

func (e *htmlB) OnMouseLeave(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mouseleave", h, options...)
}

func (e *htmlB) OnMouseMove(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mousemove", h, options...)
}

func (e *htmlB) OnMouseOut(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mouseout", h, options...)
}

func (e *htmlB) OnMouseOver(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mouseover", h, options...)
}

func (e *htmlB) OnMouseUp(h EventHandler, options ...EventOption) HTMLB {
	return e.On("mouseup", h, options...)
}

func (e *htmlB) OnPaste(h EventHandler, options ...EventOption) HTMLB {
	return e.On("paste", h, options...)
}

func (e *htmlB) OnReset(h EventHandler, options ...EventOption) HTMLB {
	return e.On("reset", h, options...)
}

func (e *htmlB) OnScroll(h EventHandler, options ...EventOption) HTMLB {
	return e.On("scroll", h, options...)
}

func (e *htmlB) OnSearch(h EventHandler, options ...EventOption) HTMLB {
	return e.On("search", h, options...)
}

func (e *htmlB) OnSelect(h EventHandler, options ...EventOption) HTMLB {
	return e.On("select", h, options...)
}

func (e *htmlB) OnSubmit(h EventHandler, options ...EventOption) HTMLB {
	return e.On("submit", h, options...)
}

func (e *htmlB) OnWheel(h EventHandler, options ...EventOption) HTMLB {
	return e.On("wheel", h, options...)
}

func (e *htmlB) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlB) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlB) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlB) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlB) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlB) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "base" HTML element.
type HTMLBase interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBase

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBase

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBase

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBase

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBase

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBase

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBase

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBase

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBase

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBase

	// Points to the URL of the destination when the link is clicked.
	Href(format string, v ...any) HTMLBase

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBase

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBase

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBase

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBase

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBase

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBase

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBase

	// Indicates where to display the linked URL or where to submit the form. Can be called with various predefined values.
	Target(format string, v ...any) HTMLBase

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBase

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBase

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBase

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBase

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBase

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBase

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBase

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBase

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBase

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBase

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBase

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBase

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBase

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBase

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBase

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBase
}

// Returns an HTML element that specifies the base URL and target for all relative URLs in the document.
func Base() HTMLBase {
	e := &htmlBase{
		htmlElement: htmlElement{
			tag:           "base",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlBase struct {
	htmlElement
}

func (e *htmlBase) AccessKey(format string, v ...any) HTMLBase {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBase) Aria(k string, v any) HTMLBase {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBase) Attr(n string, v any) HTMLBase {
	e.setAttr(n, v)
	return e
}

func (e *htmlBase) Class(v ...string) HTMLBase {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBase) ContentEditable(v bool) HTMLBase {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBase) DataSet(k string, v any) HTMLBase {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBase) DataSets(ds map[string]any) HTMLBase {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBase) Dir(format string, v ...any) HTMLBase {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBase) Draggable(v bool) HTMLBase {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBase) Hidden(v bool) HTMLBase {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBase) Href(format string, v ...any) HTMLBase {
	e.setAttr("href", FormatString(format, v...))
	return e
}

func (e *htmlBase) ID(format string, v ...any) HTMLBase {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBase) Lang(format string, v ...any) HTMLBase {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBase) Role(format string, v ...any) HTMLBase {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBase) Spellcheck(v bool) HTMLBase {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBase) Style(k, format string, v ...any) HTMLBase {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBase) Styles(s map[string]string) HTMLBase {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBase) TabIndex(v int) HTMLBase {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBase) Target(format string, v ...any) HTMLBase {
	e.setAttr("target", FormatString(format, v...))
	return e
}

func (e *htmlBase) Title(format string, v ...any) HTMLBase {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBase) On(event string, h EventHandler, options ...EventOption) HTMLBase {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBase) OnBlur(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("blur", h, options...)
}

func (e *htmlBase) OnChange(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("change", h, options...)
}

func (e *htmlBase) OnClick(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("click", h, options...)
}

func (e *htmlBase) OnContextMenu(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBase) OnCopy(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("copy", h, options...)
}

func (e *htmlBase) OnCut(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("cut", h, options...)
}

func (e *htmlBase) OnDblClick(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dblclick", h, options...)
}

func (e *htmlBase) OnDrag(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("drag", h, options...)
}

func (e *htmlBase) OnDragEnd(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dragend", h, options...)
}

func (e *htmlBase) OnDragEnter(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dragenter", h, options...)
}

func (e *htmlBase) OnDragLeave(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dragleave", h, options...)
}

func (e *htmlBase) OnDragOver(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dragover", h, options...)
}

func (e *htmlBase) OnDragStart(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("dragstart", h, options...)
}

func (e *htmlBase) OnDrop(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("drop", h, options...)
}

func (e *htmlBase) OnFocus(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("focus", h, options...)
}

func (e *htmlBase) OnInput(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("input", h, options...)
}

func (e *htmlBase) OnInvalid(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("invalid", h, options...)
}

func (e *htmlBase) OnKeyDown(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("keydown", h, options...)
}

func (e *htmlBase) OnKeyPress(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("keypress", h, options...)
}

func (e *htmlBase) OnKeyUp(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("keyup", h, options...)
}

func (e *htmlBase) OnMouseDown(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mousedown", h, options...)
}

func (e *htmlBase) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBase) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBase) OnMouseMove(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mousemove", h, options...)
}

func (e *htmlBase) OnMouseOut(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mouseout", h, options...)
}

func (e *htmlBase) OnMouseOver(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mouseover", h, options...)
}

func (e *htmlBase) OnMouseUp(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("mouseup", h, options...)
}

func (e *htmlBase) OnPaste(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("paste", h, options...)
}

func (e *htmlBase) OnReset(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("reset", h, options...)
}

func (e *htmlBase) OnScroll(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("scroll", h, options...)
}

func (e *htmlBase) OnSearch(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("search", h, options...)
}

func (e *htmlBase) OnSelect(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("select", h, options...)
}

func (e *htmlBase) OnSubmit(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("submit", h, options...)
}

func (e *htmlBase) OnWheel(h EventHandler, options ...EventOption) HTMLBase {
	return e.On("wheel", h, options...)
}

func (e *htmlBase) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBase) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBase) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBase) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBase) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBase) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "bdi" HTML element.
type HTMLBdi interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLBdi

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLBdi

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLBdi

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBdi

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBdi

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBdi

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBdi

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBdi

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBdi

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBdi

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBdi

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBdi

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBdi

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBdi

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBdi

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBdi

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBdi

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBdi

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBdi

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBdi

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBdi

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBdi

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBdi

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBdi

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBdi

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBdi
}

// Returns an HTML element that isolates a section of text, allowing it to be formatted in a different direction than the surrounding content.
func Bdi() HTMLBdi {
	e := &htmlBdi{
		htmlElement: htmlElement{
			tag:           "bdi",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlBdi struct {
	htmlElement
}

func (e *htmlBdi) Body(v ...UI) HTMLBdi {
	return e.setBody(FilterUIElems(v...)).(*htmlBdi)
}

func (e *htmlBdi) Text(v any) HTMLBdi {
	return e.Body(Text(v))
}

func (e *htmlBdi) Textf(format string, v ...any) HTMLBdi {
	return e.Body(Textf(format, v...))
}

func (e *htmlBdi) AccessKey(format string, v ...any) HTMLBdi {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBdi) Aria(k string, v any) HTMLBdi {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBdi) Attr(n string, v any) HTMLBdi {
	e.setAttr(n, v)
	return e
}

func (e *htmlBdi) Class(v ...string) HTMLBdi {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBdi) ContentEditable(v bool) HTMLBdi {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBdi) DataSet(k string, v any) HTMLBdi {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBdi) DataSets(ds map[string]any) HTMLBdi {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBdi) Dir(format string, v ...any) HTMLBdi {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBdi) Draggable(v bool) HTMLBdi {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBdi) Hidden(v bool) HTMLBdi {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBdi) ID(format string, v ...any) HTMLBdi {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBdi) Lang(format string, v ...any) HTMLBdi {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBdi) Role(format string, v ...any) HTMLBdi {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBdi) Spellcheck(v bool) HTMLBdi {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBdi) Style(k, format string, v ...any) HTMLBdi {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBdi) Styles(s map[string]string) HTMLBdi {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBdi) TabIndex(v int) HTMLBdi {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBdi) Title(format string, v ...any) HTMLBdi {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBdi) On(event string, h EventHandler, options ...EventOption) HTMLBdi {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBdi) OnBlur(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("blur", h, options...)
}

func (e *htmlBdi) OnChange(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("change", h, options...)
}

func (e *htmlBdi) OnClick(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("click", h, options...)
}

func (e *htmlBdi) OnContextMenu(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBdi) OnCopy(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("copy", h, options...)
}

func (e *htmlBdi) OnCut(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("cut", h, options...)
}

func (e *htmlBdi) OnDblClick(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dblclick", h, options...)
}

func (e *htmlBdi) OnDrag(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("drag", h, options...)
}

func (e *htmlBdi) OnDragEnd(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dragend", h, options...)
}

func (e *htmlBdi) OnDragEnter(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dragenter", h, options...)
}

func (e *htmlBdi) OnDragLeave(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dragleave", h, options...)
}

func (e *htmlBdi) OnDragOver(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dragover", h, options...)
}

func (e *htmlBdi) OnDragStart(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("dragstart", h, options...)
}

func (e *htmlBdi) OnDrop(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("drop", h, options...)
}

func (e *htmlBdi) OnFocus(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("focus", h, options...)
}

func (e *htmlBdi) OnInput(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("input", h, options...)
}

func (e *htmlBdi) OnInvalid(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("invalid", h, options...)
}

func (e *htmlBdi) OnKeyDown(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("keydown", h, options...)
}

func (e *htmlBdi) OnKeyPress(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("keypress", h, options...)
}

func (e *htmlBdi) OnKeyUp(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("keyup", h, options...)
}

func (e *htmlBdi) OnMouseDown(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mousedown", h, options...)
}

func (e *htmlBdi) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBdi) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBdi) OnMouseMove(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mousemove", h, options...)
}

func (e *htmlBdi) OnMouseOut(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mouseout", h, options...)
}

func (e *htmlBdi) OnMouseOver(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mouseover", h, options...)
}

func (e *htmlBdi) OnMouseUp(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("mouseup", h, options...)
}

func (e *htmlBdi) OnPaste(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("paste", h, options...)
}

func (e *htmlBdi) OnReset(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("reset", h, options...)
}

func (e *htmlBdi) OnScroll(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("scroll", h, options...)
}

func (e *htmlBdi) OnSearch(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("search", h, options...)
}

func (e *htmlBdi) OnSelect(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("select", h, options...)
}

func (e *htmlBdi) OnSubmit(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("submit", h, options...)
}

func (e *htmlBdi) OnWheel(h EventHandler, options ...EventOption) HTMLBdi {
	return e.On("wheel", h, options...)
}

func (e *htmlBdi) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBdi) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBdi) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBdi) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBdi) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBdi) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "bdo" HTML element.
type HTMLBdo interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLBdo

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLBdo

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLBdo

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBdo

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBdo

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBdo

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBdo

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBdo

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBdo

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBdo

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBdo

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBdo

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBdo

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBdo

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBdo

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBdo

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBdo

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBdo

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBdo

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBdo

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBdo

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBdo

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBdo

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBdo

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBdo

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBdo
}

// Returns an HTML element that controls the text direction of its content, overriding other directional settings.
func Bdo() HTMLBdo {
	e := &htmlBdo{
		htmlElement: htmlElement{
			tag:           "bdo",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlBdo struct {
	htmlElement
}

func (e *htmlBdo) Body(v ...UI) HTMLBdo {
	return e.setBody(FilterUIElems(v...)).(*htmlBdo)
}

func (e *htmlBdo) Text(v any) HTMLBdo {
	return e.Body(Text(v))
}

func (e *htmlBdo) Textf(format string, v ...any) HTMLBdo {
	return e.Body(Textf(format, v...))
}

func (e *htmlBdo) AccessKey(format string, v ...any) HTMLBdo {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBdo) Aria(k string, v any) HTMLBdo {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBdo) Attr(n string, v any) HTMLBdo {
	e.setAttr(n, v)
	return e
}

func (e *htmlBdo) Class(v ...string) HTMLBdo {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBdo) ContentEditable(v bool) HTMLBdo {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBdo) DataSet(k string, v any) HTMLBdo {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBdo) DataSets(ds map[string]any) HTMLBdo {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBdo) Dir(format string, v ...any) HTMLBdo {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBdo) Draggable(v bool) HTMLBdo {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBdo) Hidden(v bool) HTMLBdo {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBdo) ID(format string, v ...any) HTMLBdo {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBdo) Lang(format string, v ...any) HTMLBdo {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBdo) Role(format string, v ...any) HTMLBdo {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBdo) Spellcheck(v bool) HTMLBdo {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBdo) Style(k, format string, v ...any) HTMLBdo {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBdo) Styles(s map[string]string) HTMLBdo {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBdo) TabIndex(v int) HTMLBdo {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBdo) Title(format string, v ...any) HTMLBdo {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBdo) On(event string, h EventHandler, options ...EventOption) HTMLBdo {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBdo) OnBlur(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("blur", h, options...)
}

func (e *htmlBdo) OnChange(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("change", h, options...)
}

func (e *htmlBdo) OnClick(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("click", h, options...)
}

func (e *htmlBdo) OnContextMenu(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBdo) OnCopy(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("copy", h, options...)
}

func (e *htmlBdo) OnCut(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("cut", h, options...)
}

func (e *htmlBdo) OnDblClick(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dblclick", h, options...)
}

func (e *htmlBdo) OnDrag(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("drag", h, options...)
}

func (e *htmlBdo) OnDragEnd(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dragend", h, options...)
}

func (e *htmlBdo) OnDragEnter(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dragenter", h, options...)
}

func (e *htmlBdo) OnDragLeave(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dragleave", h, options...)
}

func (e *htmlBdo) OnDragOver(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dragover", h, options...)
}

func (e *htmlBdo) OnDragStart(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("dragstart", h, options...)
}

func (e *htmlBdo) OnDrop(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("drop", h, options...)
}

func (e *htmlBdo) OnFocus(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("focus", h, options...)
}

func (e *htmlBdo) OnInput(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("input", h, options...)
}

func (e *htmlBdo) OnInvalid(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("invalid", h, options...)
}

func (e *htmlBdo) OnKeyDown(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("keydown", h, options...)
}

func (e *htmlBdo) OnKeyPress(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("keypress", h, options...)
}

func (e *htmlBdo) OnKeyUp(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("keyup", h, options...)
}

func (e *htmlBdo) OnMouseDown(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mousedown", h, options...)
}

func (e *htmlBdo) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBdo) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBdo) OnMouseMove(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mousemove", h, options...)
}

func (e *htmlBdo) OnMouseOut(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mouseout", h, options...)
}

func (e *htmlBdo) OnMouseOver(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mouseover", h, options...)
}

func (e *htmlBdo) OnMouseUp(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("mouseup", h, options...)
}

func (e *htmlBdo) OnPaste(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("paste", h, options...)
}

func (e *htmlBdo) OnReset(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("reset", h, options...)
}

func (e *htmlBdo) OnScroll(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("scroll", h, options...)
}

func (e *htmlBdo) OnSearch(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("search", h, options...)
}

func (e *htmlBdo) OnSelect(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("select", h, options...)
}

func (e *htmlBdo) OnSubmit(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("submit", h, options...)
}

func (e *htmlBdo) OnWheel(h EventHandler, options ...EventOption) HTMLBdo {
	return e.On("wheel", h, options...)
}

func (e *htmlBdo) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBdo) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBdo) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBdo) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBdo) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBdo) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "blockquote" HTML element.
type HTMLBlockquote interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLBlockquote

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLBlockquote

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLBlockquote

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBlockquote

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBlockquote

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBlockquote

	// Provides a reference or link to a source explaining quoted or modified content in the element.
	Cite(format string, v ...any) HTMLBlockquote

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBlockquote

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBlockquote

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBlockquote

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBlockquote

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBlockquote

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBlockquote

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBlockquote

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBlockquote

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBlockquote

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBlockquote

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBlockquote

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBlockquote

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBlockquote

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBlockquote

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBlockquote

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBlockquote

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBlockquote

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBlockquote

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBlockquote
}

// Returns an HTML element that represents a section of text quoted from another source.
func Blockquote() HTMLBlockquote {
	e := &htmlBlockquote{
		htmlElement: htmlElement{
			tag:           "blockquote",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlBlockquote struct {
	htmlElement
}

func (e *htmlBlockquote) Body(v ...UI) HTMLBlockquote {
	return e.setBody(FilterUIElems(v...)).(*htmlBlockquote)
}

func (e *htmlBlockquote) Text(v any) HTMLBlockquote {
	return e.Body(Text(v))
}

func (e *htmlBlockquote) Textf(format string, v ...any) HTMLBlockquote {
	return e.Body(Textf(format, v...))
}

func (e *htmlBlockquote) AccessKey(format string, v ...any) HTMLBlockquote {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Aria(k string, v any) HTMLBlockquote {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBlockquote) Attr(n string, v any) HTMLBlockquote {
	e.setAttr(n, v)
	return e
}

func (e *htmlBlockquote) Cite(format string, v ...any) HTMLBlockquote {
	e.setAttr("cite", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Class(v ...string) HTMLBlockquote {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBlockquote) ContentEditable(v bool) HTMLBlockquote {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBlockquote) DataSet(k string, v any) HTMLBlockquote {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBlockquote) DataSets(ds map[string]any) HTMLBlockquote {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBlockquote) Dir(format string, v ...any) HTMLBlockquote {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Draggable(v bool) HTMLBlockquote {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBlockquote) Hidden(v bool) HTMLBlockquote {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBlockquote) ID(format string, v ...any) HTMLBlockquote {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Lang(format string, v ...any) HTMLBlockquote {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Role(format string, v ...any) HTMLBlockquote {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Spellcheck(v bool) HTMLBlockquote {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBlockquote) Style(k, format string, v ...any) HTMLBlockquote {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) Styles(s map[string]string) HTMLBlockquote {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBlockquote) TabIndex(v int) HTMLBlockquote {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBlockquote) Title(format string, v ...any) HTMLBlockquote {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBlockquote) On(event string, h EventHandler, options ...EventOption) HTMLBlockquote {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBlockquote) OnBlur(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("blur", h, options...)
}

func (e *htmlBlockquote) OnChange(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("change", h, options...)
}

func (e *htmlBlockquote) OnClick(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("click", h, options...)
}

func (e *htmlBlockquote) OnContextMenu(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBlockquote) OnCopy(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("copy", h, options...)
}

func (e *htmlBlockquote) OnCut(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("cut", h, options...)
}

func (e *htmlBlockquote) OnDblClick(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dblclick", h, options...)
}

func (e *htmlBlockquote) OnDrag(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("drag", h, options...)
}

func (e *htmlBlockquote) OnDragEnd(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dragend", h, options...)
}

func (e *htmlBlockquote) OnDragEnter(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dragenter", h, options...)
}

func (e *htmlBlockquote) OnDragLeave(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dragleave", h, options...)
}

func (e *htmlBlockquote) OnDragOver(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dragover", h, options...)
}

func (e *htmlBlockquote) OnDragStart(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("dragstart", h, options...)
}

func (e *htmlBlockquote) OnDrop(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("drop", h, options...)
}

func (e *htmlBlockquote) OnFocus(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("focus", h, options...)
}

func (e *htmlBlockquote) OnInput(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("input", h, options...)
}

func (e *htmlBlockquote) OnInvalid(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("invalid", h, options...)
}

func (e *htmlBlockquote) OnKeyDown(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("keydown", h, options...)
}

func (e *htmlBlockquote) OnKeyPress(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("keypress", h, options...)
}

func (e *htmlBlockquote) OnKeyUp(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("keyup", h, options...)
}

func (e *htmlBlockquote) OnMouseDown(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mousedown", h, options...)
}

func (e *htmlBlockquote) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBlockquote) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBlockquote) OnMouseMove(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mousemove", h, options...)
}

func (e *htmlBlockquote) OnMouseOut(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mouseout", h, options...)
}

func (e *htmlBlockquote) OnMouseOver(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mouseover", h, options...)
}

func (e *htmlBlockquote) OnMouseUp(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("mouseup", h, options...)
}

func (e *htmlBlockquote) OnPaste(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("paste", h, options...)
}

func (e *htmlBlockquote) OnReset(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("reset", h, options...)
}

func (e *htmlBlockquote) OnScroll(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("scroll", h, options...)
}

func (e *htmlBlockquote) OnSearch(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("search", h, options...)
}

func (e *htmlBlockquote) OnSelect(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("select", h, options...)
}

func (e *htmlBlockquote) OnSubmit(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("submit", h, options...)
}

func (e *htmlBlockquote) OnWheel(h EventHandler, options ...EventOption) HTMLBlockquote {
	return e.On("wheel", h, options...)
}

func (e *htmlBlockquote) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBlockquote) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBlockquote) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBlockquote) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBlockquote) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBlockquote) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "body" HTML element.
type HTMLBody interface {
	HTML

	privateBody(elems ...UI) HTMLBody

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBody

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBody

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBody

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBody

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBody

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBody

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBody

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBody

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBody

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBody

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBody

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBody

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBody

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBody

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBody

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBody

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBody

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBody

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBody

	// Executes the given handler after the document has been printed.
	OnAfterPrint(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the specified handler before the document gets printed.
	OnBeforePrint(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when the document is about to be unloaded.
	OnBeforeUnload(h EventHandler, options ...EventOption) HTMLBody

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBody

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBody

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBody

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBody

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLBody

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when changes occur to the anchor part of the URL.
	OnHashChange(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBody

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBody

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the provided handler when a message event occurs.
	OnMessage(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBody

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBody

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the given handler when the browser transitions to offline mode.
	OnOffline(h EventHandler, options ...EventOption) HTMLBody

	// Executes the specified handler when the browser transitions to online mode.
	OnOnline(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the given handler when a user navigates away from the current page.
	OnPageHide(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the specified handler when a user navigates to the page.
	OnPageShow(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBody

	// Executes the provided handler when changes are made to the window's history.
	OnPopState(h EventHandler, options ...EventOption) HTMLBody

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the given handler upon resizing the browser window.
	OnResize(h EventHandler, options ...EventOption) HTMLBody

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBody

	// Invokes the specified handler when a Web Storage area undergoes updates.
	OnStorage(h EventHandler, options ...EventOption) HTMLBody

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBody

	// Executes the provided handler once the page has been unloaded or the browser window closes.
	OnUnload(h EventHandler, options ...EventOption) HTMLBody

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBody
}

// Returns an HTML element that encloses the main content of the HTML document.
func Body() HTMLBody {
	e := &htmlBody{
		htmlElement: htmlElement{
			tag:           "body",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlBody struct {
	htmlElement
}

func (e *htmlBody) privateBody(v ...UI) HTMLBody {
	return e.setBody(FilterUIElems(v...)).(*htmlBody)
}

func (e *htmlBody) AccessKey(format string, v ...any) HTMLBody {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBody) Aria(k string, v any) HTMLBody {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBody) Attr(n string, v any) HTMLBody {
	e.setAttr(n, v)
	return e
}

func (e *htmlBody) Class(v ...string) HTMLBody {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBody) ContentEditable(v bool) HTMLBody {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBody) DataSet(k string, v any) HTMLBody {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBody) DataSets(ds map[string]any) HTMLBody {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBody) Dir(format string, v ...any) HTMLBody {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBody) Draggable(v bool) HTMLBody {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBody) Hidden(v bool) HTMLBody {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBody) ID(format string, v ...any) HTMLBody {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBody) Lang(format string, v ...any) HTMLBody {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBody) Role(format string, v ...any) HTMLBody {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBody) Spellcheck(v bool) HTMLBody {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBody) Style(k, format string, v ...any) HTMLBody {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBody) Styles(s map[string]string) HTMLBody {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBody) TabIndex(v int) HTMLBody {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBody) Title(format string, v ...any) HTMLBody {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBody) On(event string, h EventHandler, options ...EventOption) HTMLBody {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBody) OnAfterPrint(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("afterprint", h, options...)
}

func (e *htmlBody) OnBeforePrint(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("beforeprint", h, options...)
}

func (e *htmlBody) OnBeforeUnload(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("beforeunload", h, options...)
}

func (e *htmlBody) OnBlur(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("blur", h, options...)
}

func (e *htmlBody) OnChange(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("change", h, options...)
}

func (e *htmlBody) OnClick(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("click", h, options...)
}

func (e *htmlBody) OnContextMenu(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBody) OnCopy(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("copy", h, options...)
}

func (e *htmlBody) OnCut(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("cut", h, options...)
}

func (e *htmlBody) OnDblClick(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dblclick", h, options...)
}

func (e *htmlBody) OnDrag(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("drag", h, options...)
}

func (e *htmlBody) OnDragEnd(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dragend", h, options...)
}

func (e *htmlBody) OnDragEnter(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dragenter", h, options...)
}

func (e *htmlBody) OnDragLeave(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dragleave", h, options...)
}

func (e *htmlBody) OnDragOver(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dragover", h, options...)
}

func (e *htmlBody) OnDragStart(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("dragstart", h, options...)
}

func (e *htmlBody) OnDrop(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("drop", h, options...)
}

func (e *htmlBody) OnError(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("error", h, options...)
}

func (e *htmlBody) OnFocus(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("focus", h, options...)
}

func (e *htmlBody) OnHashChange(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("hashchange", h, options...)
}

func (e *htmlBody) OnInput(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("input", h, options...)
}

func (e *htmlBody) OnInvalid(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("invalid", h, options...)
}

func (e *htmlBody) OnKeyDown(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("keydown", h, options...)
}

func (e *htmlBody) OnKeyPress(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("keypress", h, options...)
}

func (e *htmlBody) OnKeyUp(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("keyup", h, options...)
}

func (e *htmlBody) OnLoad(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("load", h, options...)
}

func (e *htmlBody) OnMessage(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("message", h, options...)
}

func (e *htmlBody) OnMouseDown(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mousedown", h, options...)
}

func (e *htmlBody) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBody) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBody) OnMouseMove(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mousemove", h, options...)
}

func (e *htmlBody) OnMouseOut(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mouseout", h, options...)
}

func (e *htmlBody) OnMouseOver(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mouseover", h, options...)
}

func (e *htmlBody) OnMouseUp(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("mouseup", h, options...)
}

func (e *htmlBody) OnOffline(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("offline", h, options...)
}

func (e *htmlBody) OnOnline(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("online", h, options...)
}

func (e *htmlBody) OnPageHide(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("pagehide", h, options...)
}

func (e *htmlBody) OnPageShow(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("pageshow", h, options...)
}

func (e *htmlBody) OnPaste(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("paste", h, options...)
}

func (e *htmlBody) OnPopState(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("popstate", h, options...)
}

func (e *htmlBody) OnReset(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("reset", h, options...)
}

func (e *htmlBody) OnResize(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("resize", h, options...)
}

func (e *htmlBody) OnScroll(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("scroll", h, options...)
}

func (e *htmlBody) OnSearch(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("search", h, options...)
}

func (e *htmlBody) OnSelect(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("select", h, options...)
}

func (e *htmlBody) OnStorage(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("storage", h, options...)
}

func (e *htmlBody) OnSubmit(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("submit", h, options...)
}

func (e *htmlBody) OnUnload(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("unload", h, options...)
}

func (e *htmlBody) OnWheel(h EventHandler, options ...EventOption) HTMLBody {
	return e.On("wheel", h, options...)
}

func (e *htmlBody) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBody) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBody) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBody) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBody) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBody) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "br" HTML element.
type HTMLBr interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLBr

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLBr

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLBr

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLBr

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLBr

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLBr

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLBr

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLBr

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLBr

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLBr

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLBr

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLBr

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLBr

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLBr

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLBr

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLBr

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLBr

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLBr

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLBr

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLBr

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLBr

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLBr

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLBr

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLBr

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLBr

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLBr

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLBr

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLBr

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLBr

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLBr

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLBr

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLBr

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLBr
}

// Returns an HTML element that inserts a line break within inline content.
func Br() HTMLBr {
	e := &htmlBr{
		htmlElement: htmlElement{
			tag:           "br",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlBr struct {
	htmlElement
}

func (e *htmlBr) AccessKey(format string, v ...any) HTMLBr {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlBr) Aria(k string, v any) HTMLBr {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBr) Attr(n string, v any) HTMLBr {
	e.setAttr(n, v)
	return e
}

func (e *htmlBr) Class(v ...string) HTMLBr {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlBr) ContentEditable(v bool) HTMLBr {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlBr) DataSet(k string, v any) HTMLBr {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlBr) DataSets(ds map[string]any) HTMLBr {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlBr) Dir(format string, v ...any) HTMLBr {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlBr) Draggable(v bool) HTMLBr {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlBr) Hidden(v bool) HTMLBr {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlBr) ID(format string, v ...any) HTMLBr {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlBr) Lang(format string, v ...any) HTMLBr {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlBr) Role(format string, v ...any) HTMLBr {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlBr) Spellcheck(v bool) HTMLBr {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlBr) Style(k, format string, v ...any) HTMLBr {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlBr) Styles(s map[string]string) HTMLBr {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlBr) TabIndex(v int) HTMLBr {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlBr) Title(format string, v ...any) HTMLBr {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlBr) On(event string, h EventHandler, options ...EventOption) HTMLBr {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlBr) OnBlur(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("blur", h, options...)
}

func (e *htmlBr) OnChange(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("change", h, options...)
}

func (e *htmlBr) OnClick(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("click", h, options...)
}

func (e *htmlBr) OnContextMenu(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("contextmenu", h, options...)
}

func (e *htmlBr) OnCopy(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("copy", h, options...)
}

func (e *htmlBr) OnCut(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("cut", h, options...)
}

func (e *htmlBr) OnDblClick(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dblclick", h, options...)
}

func (e *htmlBr) OnDrag(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("drag", h, options...)
}

func (e *htmlBr) OnDragEnd(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dragend", h, options...)
}

func (e *htmlBr) OnDragEnter(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dragenter", h, options...)
}

func (e *htmlBr) OnDragLeave(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dragleave", h, options...)
}

func (e *htmlBr) OnDragOver(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dragover", h, options...)
}

func (e *htmlBr) OnDragStart(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("dragstart", h, options...)
}

func (e *htmlBr) OnDrop(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("drop", h, options...)
}

func (e *htmlBr) OnFocus(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("focus", h, options...)
}

func (e *htmlBr) OnInput(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("input", h, options...)
}

func (e *htmlBr) OnInvalid(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("invalid", h, options...)
}

func (e *htmlBr) OnKeyDown(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("keydown", h, options...)
}

func (e *htmlBr) OnKeyPress(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("keypress", h, options...)
}

func (e *htmlBr) OnKeyUp(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("keyup", h, options...)
}

func (e *htmlBr) OnMouseDown(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mousedown", h, options...)
}

func (e *htmlBr) OnMouseEnter(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mouseenter", h, options...)
}

func (e *htmlBr) OnMouseLeave(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mouseleave", h, options...)
}

func (e *htmlBr) OnMouseMove(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mousemove", h, options...)
}

func (e *htmlBr) OnMouseOut(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mouseout", h, options...)
}

func (e *htmlBr) OnMouseOver(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mouseover", h, options...)
}

func (e *htmlBr) OnMouseUp(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("mouseup", h, options...)
}

func (e *htmlBr) OnPaste(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("paste", h, options...)
}

func (e *htmlBr) OnReset(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("reset", h, options...)
}

func (e *htmlBr) OnScroll(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("scroll", h, options...)
}

func (e *htmlBr) OnSearch(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("search", h, options...)
}

func (e *htmlBr) OnSelect(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("select", h, options...)
}

func (e *htmlBr) OnSubmit(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("submit", h, options...)
}

func (e *htmlBr) OnWheel(h EventHandler, options ...EventOption) HTMLBr {
	return e.On("wheel", h, options...)
}

func (e *htmlBr) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlBr) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlBr) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlBr) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlBr) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlBr) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "button" HTML element.
type HTMLButton interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLButton

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLButton

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLButton

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLButton

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLButton

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLButton

	// Instructs the browser to focus this element automatically when the page loads.
	AutoFocus(v bool) HTMLButton

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLButton

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLButton

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLButton

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLButton

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLButton

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLButton

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLButton

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLButton

	// Defines the URL to which form data should be sent upon submission. Applicable only to 'submit' type inputs.
	FormAction(format string, v ...any) HTMLButton

	// Dictates the encoding method for form data prior to its submission to a server. Applicable only to 'submit' type inputs.
	FormEncType(format string, v ...any) HTMLButton

	// Determines the HTTP method for sending form data. Applicable only to 'submit' type inputs.
	FormMethod(format string, v ...any) HTMLButton

	// Indicates that the form data should bypass validation upon submission. Applicable only to 'submit' type inputs.
	FormNoValidate(v bool) HTMLButton

	// Specifies where the server's response will be displayed after form submission. Applicable only to 'submit' type inputs.
	FormTarget(format string, v ...any) HTMLButton

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLButton

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLButton

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLButton

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLButton

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLButton

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLButton

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLButton

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLButton

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLButton

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLButton

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLButton

	// Assigns a value to the element.
	Value(v any) HTMLButton

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLButton

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLButton

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLButton

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLButton

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLButton

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLButton

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLButton

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLButton

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLButton

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLButton

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLButton

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLButton

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLButton

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLButton

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLButton
}

// Returns an HTML element that creates a clickable button, typically used for form submission or triggering interactions.
func Button() HTMLButton {
	e := &htmlButton{
		htmlElement: htmlElement{
			tag:           "button",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlButton struct {
	htmlElement
}

func (e *htmlButton) Body(v ...UI) HTMLButton {
	return e.setBody(FilterUIElems(v...)).(*htmlButton)
}

func (e *htmlButton) Text(v any) HTMLButton {
	return e.Body(Text(v))
}

func (e *htmlButton) Textf(format string, v ...any) HTMLButton {
	return e.Body(Textf(format, v...))
}

func (e *htmlButton) AccessKey(format string, v ...any) HTMLButton {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlButton) Aria(k string, v any) HTMLButton {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlButton) Attr(n string, v any) HTMLButton {
	e.setAttr(n, v)
	return e
}

func (e *htmlButton) AutoFocus(v bool) HTMLButton {
	e.setAttr("autofocus", v)
	return e
}

func (e *htmlButton) Class(v ...string) HTMLButton {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlButton) ContentEditable(v bool) HTMLButton {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlButton) DataSet(k string, v any) HTMLButton {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlButton) DataSets(ds map[string]any) HTMLButton {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlButton) Dir(format string, v ...any) HTMLButton {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlButton) Disabled(v bool) HTMLButton {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlButton) Draggable(v bool) HTMLButton {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlButton) Form(format string, v ...any) HTMLButton {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlButton) FormAction(format string, v ...any) HTMLButton {
	e.setAttr("formaction", FormatString(format, v...))
	return e
}

func (e *htmlButton) FormEncType(format string, v ...any) HTMLButton {
	e.setAttr("formenctype", FormatString(format, v...))
	return e
}

func (e *htmlButton) FormMethod(format string, v ...any) HTMLButton {
	e.setAttr("formmethod", FormatString(format, v...))
	return e
}

func (e *htmlButton) FormNoValidate(v bool) HTMLButton {
	e.setAttr("formnovalidate", v)
	return e
}

func (e *htmlButton) FormTarget(format string, v ...any) HTMLButton {
	e.setAttr("formtarget", FormatString(format, v...))
	return e
}

func (e *htmlButton) Hidden(v bool) HTMLButton {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlButton) ID(format string, v ...any) HTMLButton {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlButton) Lang(format string, v ...any) HTMLButton {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlButton) Name(format string, v ...any) HTMLButton {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlButton) Role(format string, v ...any) HTMLButton {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlButton) Spellcheck(v bool) HTMLButton {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlButton) Style(k, format string, v ...any) HTMLButton {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlButton) Styles(s map[string]string) HTMLButton {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlButton) TabIndex(v int) HTMLButton {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlButton) Title(format string, v ...any) HTMLButton {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlButton) Type(format string, v ...any) HTMLButton {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlButton) Value(v any) HTMLButton {
	e.setAttr("value", v)
	return e
}

func (e *htmlButton) On(event string, h EventHandler, options ...EventOption) HTMLButton {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlButton) OnBlur(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("blur", h, options...)
}

func (e *htmlButton) OnChange(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("change", h, options...)
}

func (e *htmlButton) OnClick(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("click", h, options...)
}

func (e *htmlButton) OnContextMenu(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("contextmenu", h, options...)
}

func (e *htmlButton) OnCopy(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("copy", h, options...)
}

func (e *htmlButton) OnCut(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("cut", h, options...)
}

func (e *htmlButton) OnDblClick(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dblclick", h, options...)
}

func (e *htmlButton) OnDrag(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("drag", h, options...)
}

func (e *htmlButton) OnDragEnd(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dragend", h, options...)
}

func (e *htmlButton) OnDragEnter(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dragenter", h, options...)
}

func (e *htmlButton) OnDragLeave(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dragleave", h, options...)
}

func (e *htmlButton) OnDragOver(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dragover", h, options...)
}

func (e *htmlButton) OnDragStart(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("dragstart", h, options...)
}

func (e *htmlButton) OnDrop(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("drop", h, options...)
}

func (e *htmlButton) OnFocus(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("focus", h, options...)
}

func (e *htmlButton) OnInput(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("input", h, options...)
}

func (e *htmlButton) OnInvalid(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("invalid", h, options...)
}

func (e *htmlButton) OnKeyDown(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("keydown", h, options...)
}

func (e *htmlButton) OnKeyPress(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("keypress", h, options...)
}

func (e *htmlButton) OnKeyUp(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("keyup", h, options...)
}

func (e *htmlButton) OnMouseDown(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mousedown", h, options...)
}

func (e *htmlButton) OnMouseEnter(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mouseenter", h, options...)
}

func (e *htmlButton) OnMouseLeave(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mouseleave", h, options...)
}

func (e *htmlButton) OnMouseMove(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mousemove", h, options...)
}

func (e *htmlButton) OnMouseOut(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mouseout", h, options...)
}

func (e *htmlButton) OnMouseOver(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mouseover", h, options...)
}

func (e *htmlButton) OnMouseUp(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("mouseup", h, options...)
}

func (e *htmlButton) OnPaste(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("paste", h, options...)
}

func (e *htmlButton) OnReset(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("reset", h, options...)
}

func (e *htmlButton) OnScroll(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("scroll", h, options...)
}

func (e *htmlButton) OnSearch(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("search", h, options...)
}

func (e *htmlButton) OnSelect(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("select", h, options...)
}

func (e *htmlButton) OnSubmit(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("submit", h, options...)
}

func (e *htmlButton) OnWheel(h EventHandler, options ...EventOption) HTMLButton {
	return e.On("wheel", h, options...)
}

func (e *htmlButton) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlButton) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlButton) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlButton) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlButton) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlButton) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "canvas" HTML element.
type HTMLCanvas interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLCanvas

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLCanvas

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLCanvas

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLCanvas

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLCanvas

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLCanvas

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLCanvas

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLCanvas

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLCanvas

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLCanvas

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLCanvas

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLCanvas

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLCanvas

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLCanvas

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLCanvas

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLCanvas

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLCanvas

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLCanvas

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLCanvas

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLCanvas

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLCanvas

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLCanvas

	// Sets the width of the element.
	Width(v int) HTMLCanvas

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLCanvas

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLCanvas

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLCanvas

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLCanvas
}

// Returns an HTML element that provides a space where graphics can be rendered dynamically, such as 2D drawings or 3D visualizations.
func Canvas() HTMLCanvas {
	e := &htmlCanvas{
		htmlElement: htmlElement{
			tag:           "canvas",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlCanvas struct {
	htmlElement
}

func (e *htmlCanvas) Body(v ...UI) HTMLCanvas {
	return e.setBody(FilterUIElems(v...)).(*htmlCanvas)
}

func (e *htmlCanvas) Text(v any) HTMLCanvas {
	return e.Body(Text(v))
}

func (e *htmlCanvas) Textf(format string, v ...any) HTMLCanvas {
	return e.Body(Textf(format, v...))
}

func (e *htmlCanvas) AccessKey(format string, v ...any) HTMLCanvas {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Aria(k string, v any) HTMLCanvas {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCanvas) Attr(n string, v any) HTMLCanvas {
	e.setAttr(n, v)
	return e
}

func (e *htmlCanvas) Class(v ...string) HTMLCanvas {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlCanvas) ContentEditable(v bool) HTMLCanvas {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlCanvas) DataSet(k string, v any) HTMLCanvas {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCanvas) DataSets(ds map[string]any) HTMLCanvas {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlCanvas) Dir(format string, v ...any) HTMLCanvas {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Draggable(v bool) HTMLCanvas {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlCanvas) Height(v int) HTMLCanvas {
	e.setAttr("height", v)
	return e
}

func (e *htmlCanvas) Hidden(v bool) HTMLCanvas {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlCanvas) ID(format string, v ...any) HTMLCanvas {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Lang(format string, v ...any) HTMLCanvas {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Role(format string, v ...any) HTMLCanvas {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Spellcheck(v bool) HTMLCanvas {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlCanvas) Style(k, format string, v ...any) HTMLCanvas {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Styles(s map[string]string) HTMLCanvas {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlCanvas) TabIndex(v int) HTMLCanvas {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlCanvas) Title(format string, v ...any) HTMLCanvas {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlCanvas) Width(v int) HTMLCanvas {
	e.setAttr("width", v)
	return e
}

func (e *htmlCanvas) On(event string, h EventHandler, options ...EventOption) HTMLCanvas {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlCanvas) OnBlur(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("blur", h, options...)
}

func (e *htmlCanvas) OnChange(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("change", h, options...)
}

func (e *htmlCanvas) OnClick(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("click", h, options...)
}

func (e *htmlCanvas) OnContextMenu(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("contextmenu", h, options...)
}

func (e *htmlCanvas) OnCopy(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("copy", h, options...)
}

func (e *htmlCanvas) OnCut(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("cut", h, options...)
}

func (e *htmlCanvas) OnDblClick(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dblclick", h, options...)
}

func (e *htmlCanvas) OnDrag(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("drag", h, options...)
}

func (e *htmlCanvas) OnDragEnd(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dragend", h, options...)
}

func (e *htmlCanvas) OnDragEnter(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dragenter", h, options...)
}

func (e *htmlCanvas) OnDragLeave(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dragleave", h, options...)
}

func (e *htmlCanvas) OnDragOver(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dragover", h, options...)
}

func (e *htmlCanvas) OnDragStart(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("dragstart", h, options...)
}

func (e *htmlCanvas) OnDrop(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("drop", h, options...)
}

func (e *htmlCanvas) OnFocus(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("focus", h, options...)
}

func (e *htmlCanvas) OnInput(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("input", h, options...)
}

func (e *htmlCanvas) OnInvalid(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("invalid", h, options...)
}

func (e *htmlCanvas) OnKeyDown(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("keydown", h, options...)
}

func (e *htmlCanvas) OnKeyPress(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("keypress", h, options...)
}

func (e *htmlCanvas) OnKeyUp(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("keyup", h, options...)
}

func (e *htmlCanvas) OnMouseDown(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mousedown", h, options...)
}

func (e *htmlCanvas) OnMouseEnter(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mouseenter", h, options...)
}

func (e *htmlCanvas) OnMouseLeave(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mouseleave", h, options...)
}

func (e *htmlCanvas) OnMouseMove(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mousemove", h, options...)
}

func (e *htmlCanvas) OnMouseOut(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mouseout", h, options...)
}

func (e *htmlCanvas) OnMouseOver(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mouseover", h, options...)
}

func (e *htmlCanvas) OnMouseUp(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("mouseup", h, options...)
}

func (e *htmlCanvas) OnPaste(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("paste", h, options...)
}

func (e *htmlCanvas) OnReset(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("reset", h, options...)
}

func (e *htmlCanvas) OnScroll(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("scroll", h, options...)
}

func (e *htmlCanvas) OnSearch(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("search", h, options...)
}

func (e *htmlCanvas) OnSelect(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("select", h, options...)
}

func (e *htmlCanvas) OnSubmit(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("submit", h, options...)
}

func (e *htmlCanvas) OnWheel(h EventHandler, options ...EventOption) HTMLCanvas {
	return e.On("wheel", h, options...)
}

func (e *htmlCanvas) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlCanvas) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlCanvas) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlCanvas) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlCanvas) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlCanvas) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "caption" HTML element.
type HTMLCaption interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLCaption

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLCaption

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLCaption

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLCaption

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLCaption

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLCaption

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLCaption

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLCaption

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLCaption

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLCaption

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLCaption

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLCaption

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLCaption

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLCaption

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLCaption

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLCaption

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLCaption

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLCaption

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLCaption

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLCaption

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLCaption

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLCaption

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLCaption

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLCaption

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLCaption

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLCaption
}

// Returns an HTML element that represents the title or description of a table, usually appearing above or below the table.
func Caption() HTMLCaption {
	e := &htmlCaption{
		htmlElement: htmlElement{
			tag:           "caption",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlCaption struct {
	htmlElement
}

func (e *htmlCaption) Body(v ...UI) HTMLCaption {
	return e.setBody(FilterUIElems(v...)).(*htmlCaption)
}

func (e *htmlCaption) Text(v any) HTMLCaption {
	return e.Body(Text(v))
}

func (e *htmlCaption) Textf(format string, v ...any) HTMLCaption {
	return e.Body(Textf(format, v...))
}

func (e *htmlCaption) AccessKey(format string, v ...any) HTMLCaption {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlCaption) Aria(k string, v any) HTMLCaption {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCaption) Attr(n string, v any) HTMLCaption {
	e.setAttr(n, v)
	return e
}

func (e *htmlCaption) Class(v ...string) HTMLCaption {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlCaption) ContentEditable(v bool) HTMLCaption {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlCaption) DataSet(k string, v any) HTMLCaption {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCaption) DataSets(ds map[string]any) HTMLCaption {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlCaption) Dir(format string, v ...any) HTMLCaption {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlCaption) Draggable(v bool) HTMLCaption {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlCaption) Hidden(v bool) HTMLCaption {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlCaption) ID(format string, v ...any) HTMLCaption {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlCaption) Lang(format string, v ...any) HTMLCaption {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlCaption) Role(format string, v ...any) HTMLCaption {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlCaption) Spellcheck(v bool) HTMLCaption {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlCaption) Style(k, format string, v ...any) HTMLCaption {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlCaption) Styles(s map[string]string) HTMLCaption {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlCaption) TabIndex(v int) HTMLCaption {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlCaption) Title(format string, v ...any) HTMLCaption {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlCaption) On(event string, h EventHandler, options ...EventOption) HTMLCaption {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlCaption) OnBlur(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("blur", h, options...)
}

func (e *htmlCaption) OnChange(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("change", h, options...)
}

func (e *htmlCaption) OnClick(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("click", h, options...)
}

func (e *htmlCaption) OnContextMenu(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("contextmenu", h, options...)
}

func (e *htmlCaption) OnCopy(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("copy", h, options...)
}

func (e *htmlCaption) OnCut(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("cut", h, options...)
}

func (e *htmlCaption) OnDblClick(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dblclick", h, options...)
}

func (e *htmlCaption) OnDrag(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("drag", h, options...)
}

func (e *htmlCaption) OnDragEnd(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dragend", h, options...)
}

func (e *htmlCaption) OnDragEnter(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dragenter", h, options...)
}

func (e *htmlCaption) OnDragLeave(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dragleave", h, options...)
}

func (e *htmlCaption) OnDragOver(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dragover", h, options...)
}

func (e *htmlCaption) OnDragStart(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("dragstart", h, options...)
}

func (e *htmlCaption) OnDrop(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("drop", h, options...)
}

func (e *htmlCaption) OnFocus(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("focus", h, options...)
}

func (e *htmlCaption) OnInput(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("input", h, options...)
}

func (e *htmlCaption) OnInvalid(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("invalid", h, options...)
}

func (e *htmlCaption) OnKeyDown(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("keydown", h, options...)
}

func (e *htmlCaption) OnKeyPress(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("keypress", h, options...)
}

func (e *htmlCaption) OnKeyUp(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("keyup", h, options...)
}

func (e *htmlCaption) OnMouseDown(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mousedown", h, options...)
}

func (e *htmlCaption) OnMouseEnter(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mouseenter", h, options...)
}

func (e *htmlCaption) OnMouseLeave(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mouseleave", h, options...)
}

func (e *htmlCaption) OnMouseMove(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mousemove", h, options...)
}

func (e *htmlCaption) OnMouseOut(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mouseout", h, options...)
}

func (e *htmlCaption) OnMouseOver(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mouseover", h, options...)
}

func (e *htmlCaption) OnMouseUp(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("mouseup", h, options...)
}

func (e *htmlCaption) OnPaste(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("paste", h, options...)
}

func (e *htmlCaption) OnReset(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("reset", h, options...)
}

func (e *htmlCaption) OnScroll(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("scroll", h, options...)
}

func (e *htmlCaption) OnSearch(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("search", h, options...)
}

func (e *htmlCaption) OnSelect(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("select", h, options...)
}

func (e *htmlCaption) OnSubmit(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("submit", h, options...)
}

func (e *htmlCaption) OnWheel(h EventHandler, options ...EventOption) HTMLCaption {
	return e.On("wheel", h, options...)
}

func (e *htmlCaption) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlCaption) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlCaption) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlCaption) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlCaption) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlCaption) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "cite" HTML element.
type HTMLCite interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLCite

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLCite

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLCite

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLCite

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLCite

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLCite

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLCite

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLCite

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLCite

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLCite

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLCite

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLCite

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLCite

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLCite

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLCite

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLCite

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLCite

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLCite

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLCite

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLCite

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLCite

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLCite

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLCite

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLCite

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLCite

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLCite

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLCite

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLCite

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLCite

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLCite

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLCite

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLCite

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLCite

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLCite

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLCite

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLCite
}

// Returns an HTML element that indicates the title or reference of a creative work, such as a book, film, or research paper.
func Cite() HTMLCite {
	e := &htmlCite{
		htmlElement: htmlElement{
			tag:           "cite",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlCite struct {
	htmlElement
}

func (e *htmlCite) Body(v ...UI) HTMLCite {
	return e.setBody(FilterUIElems(v...)).(*htmlCite)
}

func (e *htmlCite) Text(v any) HTMLCite {
	return e.Body(Text(v))
}

func (e *htmlCite) Textf(format string, v ...any) HTMLCite {
	return e.Body(Textf(format, v...))
}

func (e *htmlCite) AccessKey(format string, v ...any) HTMLCite {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlCite) Aria(k string, v any) HTMLCite {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCite) Attr(n string, v any) HTMLCite {
	e.setAttr(n, v)
	return e
}

func (e *htmlCite) Class(v ...string) HTMLCite {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlCite) ContentEditable(v bool) HTMLCite {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlCite) DataSet(k string, v any) HTMLCite {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCite) DataSets(ds map[string]any) HTMLCite {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlCite) Dir(format string, v ...any) HTMLCite {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlCite) Draggable(v bool) HTMLCite {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlCite) Hidden(v bool) HTMLCite {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlCite) ID(format string, v ...any) HTMLCite {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlCite) Lang(format string, v ...any) HTMLCite {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlCite) Role(format string, v ...any) HTMLCite {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlCite) Spellcheck(v bool) HTMLCite {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlCite) Style(k, format string, v ...any) HTMLCite {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlCite) Styles(s map[string]string) HTMLCite {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlCite) TabIndex(v int) HTMLCite {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlCite) Title(format string, v ...any) HTMLCite {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlCite) On(event string, h EventHandler, options ...EventOption) HTMLCite {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlCite) OnBlur(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("blur", h, options...)
}

func (e *htmlCite) OnChange(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("change", h, options...)
}

func (e *htmlCite) OnClick(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("click", h, options...)
}

func (e *htmlCite) OnContextMenu(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("contextmenu", h, options...)
}

func (e *htmlCite) OnCopy(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("copy", h, options...)
}

func (e *htmlCite) OnCut(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("cut", h, options...)
}

func (e *htmlCite) OnDblClick(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dblclick", h, options...)
}

func (e *htmlCite) OnDrag(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("drag", h, options...)
}

func (e *htmlCite) OnDragEnd(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dragend", h, options...)
}

func (e *htmlCite) OnDragEnter(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dragenter", h, options...)
}

func (e *htmlCite) OnDragLeave(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dragleave", h, options...)
}

func (e *htmlCite) OnDragOver(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dragover", h, options...)
}

func (e *htmlCite) OnDragStart(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("dragstart", h, options...)
}

func (e *htmlCite) OnDrop(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("drop", h, options...)
}

func (e *htmlCite) OnFocus(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("focus", h, options...)
}

func (e *htmlCite) OnInput(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("input", h, options...)
}

func (e *htmlCite) OnInvalid(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("invalid", h, options...)
}

func (e *htmlCite) OnKeyDown(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("keydown", h, options...)
}

func (e *htmlCite) OnKeyPress(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("keypress", h, options...)
}

func (e *htmlCite) OnKeyUp(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("keyup", h, options...)
}

func (e *htmlCite) OnMouseDown(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mousedown", h, options...)
}

func (e *htmlCite) OnMouseEnter(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mouseenter", h, options...)
}

func (e *htmlCite) OnMouseLeave(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mouseleave", h, options...)
}

func (e *htmlCite) OnMouseMove(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mousemove", h, options...)
}

func (e *htmlCite) OnMouseOut(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mouseout", h, options...)
}

func (e *htmlCite) OnMouseOver(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mouseover", h, options...)
}

func (e *htmlCite) OnMouseUp(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("mouseup", h, options...)
}

func (e *htmlCite) OnPaste(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("paste", h, options...)
}

func (e *htmlCite) OnReset(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("reset", h, options...)
}

func (e *htmlCite) OnScroll(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("scroll", h, options...)
}

func (e *htmlCite) OnSearch(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("search", h, options...)
}

func (e *htmlCite) OnSelect(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("select", h, options...)
}

func (e *htmlCite) OnSubmit(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("submit", h, options...)
}

func (e *htmlCite) OnWheel(h EventHandler, options ...EventOption) HTMLCite {
	return e.On("wheel", h, options...)
}

func (e *htmlCite) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlCite) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlCite) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlCite) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlCite) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlCite) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "code" HTML element.
type HTMLCode interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLCode

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLCode

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLCode

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLCode

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLCode

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLCode

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLCode

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLCode

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLCode

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLCode

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLCode

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLCode

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLCode

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLCode

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLCode

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLCode

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLCode

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLCode

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLCode

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLCode

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLCode

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLCode

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLCode

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLCode

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLCode

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLCode

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLCode

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLCode

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLCode

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLCode

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLCode

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLCode

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLCode

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLCode

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLCode

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLCode
}

// Returns an HTML element that displays a single line of code or a code snippet, preserving its formatting.
func Code() HTMLCode {
	e := &htmlCode{
		htmlElement: htmlElement{
			tag:           "code",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlCode struct {
	htmlElement
}

func (e *htmlCode) Body(v ...UI) HTMLCode {
	return e.setBody(FilterUIElems(v...)).(*htmlCode)
}

func (e *htmlCode) Text(v any) HTMLCode {
	return e.Body(Text(v))
}

func (e *htmlCode) Textf(format string, v ...any) HTMLCode {
	return e.Body(Textf(format, v...))
}

func (e *htmlCode) AccessKey(format string, v ...any) HTMLCode {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlCode) Aria(k string, v any) HTMLCode {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCode) Attr(n string, v any) HTMLCode {
	e.setAttr(n, v)
	return e
}

func (e *htmlCode) Class(v ...string) HTMLCode {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlCode) ContentEditable(v bool) HTMLCode {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlCode) DataSet(k string, v any) HTMLCode {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCode) DataSets(ds map[string]any) HTMLCode {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlCode) Dir(format string, v ...any) HTMLCode {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlCode) Draggable(v bool) HTMLCode {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlCode) Hidden(v bool) HTMLCode {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlCode) ID(format string, v ...any) HTMLCode {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlCode) Lang(format string, v ...any) HTMLCode {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlCode) Role(format string, v ...any) HTMLCode {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlCode) Spellcheck(v bool) HTMLCode {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlCode) Style(k, format string, v ...any) HTMLCode {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlCode) Styles(s map[string]string) HTMLCode {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlCode) TabIndex(v int) HTMLCode {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlCode) Title(format string, v ...any) HTMLCode {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlCode) On(event string, h EventHandler, options ...EventOption) HTMLCode {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlCode) OnBlur(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("blur", h, options...)
}

func (e *htmlCode) OnChange(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("change", h, options...)
}

func (e *htmlCode) OnClick(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("click", h, options...)
}

func (e *htmlCode) OnContextMenu(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("contextmenu", h, options...)
}

func (e *htmlCode) OnCopy(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("copy", h, options...)
}

func (e *htmlCode) OnCut(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("cut", h, options...)
}

func (e *htmlCode) OnDblClick(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dblclick", h, options...)
}

func (e *htmlCode) OnDrag(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("drag", h, options...)
}

func (e *htmlCode) OnDragEnd(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dragend", h, options...)
}

func (e *htmlCode) OnDragEnter(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dragenter", h, options...)
}

func (e *htmlCode) OnDragLeave(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dragleave", h, options...)
}

func (e *htmlCode) OnDragOver(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dragover", h, options...)
}

func (e *htmlCode) OnDragStart(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("dragstart", h, options...)
}

func (e *htmlCode) OnDrop(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("drop", h, options...)
}

func (e *htmlCode) OnFocus(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("focus", h, options...)
}

func (e *htmlCode) OnInput(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("input", h, options...)
}

func (e *htmlCode) OnInvalid(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("invalid", h, options...)
}

func (e *htmlCode) OnKeyDown(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("keydown", h, options...)
}

func (e *htmlCode) OnKeyPress(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("keypress", h, options...)
}

func (e *htmlCode) OnKeyUp(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("keyup", h, options...)
}

func (e *htmlCode) OnMouseDown(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mousedown", h, options...)
}

func (e *htmlCode) OnMouseEnter(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mouseenter", h, options...)
}

func (e *htmlCode) OnMouseLeave(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mouseleave", h, options...)
}

func (e *htmlCode) OnMouseMove(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mousemove", h, options...)
}

func (e *htmlCode) OnMouseOut(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mouseout", h, options...)
}

func (e *htmlCode) OnMouseOver(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mouseover", h, options...)
}

func (e *htmlCode) OnMouseUp(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("mouseup", h, options...)
}

func (e *htmlCode) OnPaste(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("paste", h, options...)
}

func (e *htmlCode) OnReset(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("reset", h, options...)
}

func (e *htmlCode) OnScroll(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("scroll", h, options...)
}

func (e *htmlCode) OnSearch(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("search", h, options...)
}

func (e *htmlCode) OnSelect(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("select", h, options...)
}

func (e *htmlCode) OnSubmit(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("submit", h, options...)
}

func (e *htmlCode) OnWheel(h EventHandler, options ...EventOption) HTMLCode {
	return e.On("wheel", h, options...)
}

func (e *htmlCode) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlCode) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlCode) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlCode) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlCode) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlCode) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "col" HTML element.
type HTMLCol interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLCol

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLCol

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLCol

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLCol

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLCol

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLCol

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLCol

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLCol

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLCol

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLCol

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLCol

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLCol

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLCol

	// Defines how many columns or rows a cell should span.
	Span(v int) HTMLCol

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLCol

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLCol

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLCol

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLCol

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLCol

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLCol

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLCol

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLCol

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLCol

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLCol

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLCol

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLCol

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLCol

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLCol

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLCol

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLCol

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLCol

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLCol

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLCol

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLCol
}

// Returns an HTML element that defines the properties for a single column or a group of columns within a table, when nested within a `<colgroup>` element.
func Col() HTMLCol {
	e := &htmlCol{
		htmlElement: htmlElement{
			tag:           "col",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlCol struct {
	htmlElement
}

func (e *htmlCol) AccessKey(format string, v ...any) HTMLCol {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlCol) Aria(k string, v any) HTMLCol {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCol) Attr(n string, v any) HTMLCol {
	e.setAttr(n, v)
	return e
}

func (e *htmlCol) Class(v ...string) HTMLCol {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlCol) ContentEditable(v bool) HTMLCol {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlCol) DataSet(k string, v any) HTMLCol {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlCol) DataSets(ds map[string]any) HTMLCol {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlCol) Dir(format string, v ...any) HTMLCol {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlCol) Draggable(v bool) HTMLCol {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlCol) Hidden(v bool) HTMLCol {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlCol) ID(format string, v ...any) HTMLCol {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlCol) Lang(format string, v ...any) HTMLCol {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlCol) Role(format string, v ...any) HTMLCol {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlCol) Span(v int) HTMLCol {
	e.setAttr("span", v)
	return e
}

func (e *htmlCol) Spellcheck(v bool) HTMLCol {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlCol) Style(k, format string, v ...any) HTMLCol {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlCol) Styles(s map[string]string) HTMLCol {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlCol) TabIndex(v int) HTMLCol {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlCol) Title(format string, v ...any) HTMLCol {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlCol) On(event string, h EventHandler, options ...EventOption) HTMLCol {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlCol) OnBlur(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("blur", h, options...)
}

func (e *htmlCol) OnChange(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("change", h, options...)
}

func (e *htmlCol) OnClick(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("click", h, options...)
}

func (e *htmlCol) OnContextMenu(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("contextmenu", h, options...)
}

func (e *htmlCol) OnCopy(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("copy", h, options...)
}

func (e *htmlCol) OnCut(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("cut", h, options...)
}

func (e *htmlCol) OnDblClick(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dblclick", h, options...)
}

func (e *htmlCol) OnDrag(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("drag", h, options...)
}

func (e *htmlCol) OnDragEnd(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dragend", h, options...)
}

func (e *htmlCol) OnDragEnter(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dragenter", h, options...)
}

func (e *htmlCol) OnDragLeave(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dragleave", h, options...)
}

func (e *htmlCol) OnDragOver(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dragover", h, options...)
}

func (e *htmlCol) OnDragStart(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("dragstart", h, options...)
}

func (e *htmlCol) OnDrop(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("drop", h, options...)
}

func (e *htmlCol) OnFocus(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("focus", h, options...)
}

func (e *htmlCol) OnInput(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("input", h, options...)
}

func (e *htmlCol) OnInvalid(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("invalid", h, options...)
}

func (e *htmlCol) OnKeyDown(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("keydown", h, options...)
}

func (e *htmlCol) OnKeyPress(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("keypress", h, options...)
}

func (e *htmlCol) OnKeyUp(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("keyup", h, options...)
}

func (e *htmlCol) OnMouseDown(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mousedown", h, options...)
}

func (e *htmlCol) OnMouseEnter(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mouseenter", h, options...)
}

func (e *htmlCol) OnMouseLeave(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mouseleave", h, options...)
}

func (e *htmlCol) OnMouseMove(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mousemove", h, options...)
}

func (e *htmlCol) OnMouseOut(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mouseout", h, options...)
}

func (e *htmlCol) OnMouseOver(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mouseover", h, options...)
}

func (e *htmlCol) OnMouseUp(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("mouseup", h, options...)
}

func (e *htmlCol) OnPaste(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("paste", h, options...)
}

func (e *htmlCol) OnReset(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("reset", h, options...)
}

func (e *htmlCol) OnScroll(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("scroll", h, options...)
}

func (e *htmlCol) OnSearch(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("search", h, options...)
}

func (e *htmlCol) OnSelect(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("select", h, options...)
}

func (e *htmlCol) OnSubmit(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("submit", h, options...)
}

func (e *htmlCol) OnWheel(h EventHandler, options ...EventOption) HTMLCol {
	return e.On("wheel", h, options...)
}

func (e *htmlCol) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlCol) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlCol) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlCol) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlCol) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlCol) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "colgroup" HTML element.
type HTMLColGroup interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLColGroup

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLColGroup

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLColGroup

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLColGroup

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLColGroup

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLColGroup

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLColGroup

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLColGroup

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLColGroup

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLColGroup

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLColGroup

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLColGroup

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLColGroup

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLColGroup

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLColGroup

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLColGroup

	// Defines how many columns or rows a cell should span.
	Span(v int) HTMLColGroup

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLColGroup

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLColGroup

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLColGroup

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLColGroup

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLColGroup

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLColGroup

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLColGroup

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLColGroup

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLColGroup
}

// Returns an HTML element that groups one or more `<col>` elements, providing a way to apply styles and attributes to multiple columns simultaneously.
func ColGroup() HTMLColGroup {
	e := &htmlColGroup{
		htmlElement: htmlElement{
			tag:           "colgroup",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlColGroup struct {
	htmlElement
}

func (e *htmlColGroup) Body(v ...UI) HTMLColGroup {
	return e.setBody(FilterUIElems(v...)).(*htmlColGroup)
}

func (e *htmlColGroup) Text(v any) HTMLColGroup {
	return e.Body(Text(v))
}

func (e *htmlColGroup) Textf(format string, v ...any) HTMLColGroup {
	return e.Body(Textf(format, v...))
}

func (e *htmlColGroup) AccessKey(format string, v ...any) HTMLColGroup {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Aria(k string, v any) HTMLColGroup {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlColGroup) Attr(n string, v any) HTMLColGroup {
	e.setAttr(n, v)
	return e
}

func (e *htmlColGroup) Class(v ...string) HTMLColGroup {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlColGroup) ContentEditable(v bool) HTMLColGroup {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlColGroup) DataSet(k string, v any) HTMLColGroup {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlColGroup) DataSets(ds map[string]any) HTMLColGroup {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlColGroup) Dir(format string, v ...any) HTMLColGroup {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Draggable(v bool) HTMLColGroup {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlColGroup) Hidden(v bool) HTMLColGroup {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlColGroup) ID(format string, v ...any) HTMLColGroup {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Lang(format string, v ...any) HTMLColGroup {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Role(format string, v ...any) HTMLColGroup {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Span(v int) HTMLColGroup {
	e.setAttr("span", v)
	return e
}

func (e *htmlColGroup) Spellcheck(v bool) HTMLColGroup {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlColGroup) Style(k, format string, v ...any) HTMLColGroup {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlColGroup) Styles(s map[string]string) HTMLColGroup {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlColGroup) TabIndex(v int) HTMLColGroup {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlColGroup) Title(format string, v ...any) HTMLColGroup {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlColGroup) On(event string, h EventHandler, options ...EventOption) HTMLColGroup {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlColGroup) OnBlur(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("blur", h, options...)
}

func (e *htmlColGroup) OnChange(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("change", h, options...)
}

func (e *htmlColGroup) OnClick(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("click", h, options...)
}

func (e *htmlColGroup) OnContextMenu(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("contextmenu", h, options...)
}

func (e *htmlColGroup) OnCopy(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("copy", h, options...)
}

func (e *htmlColGroup) OnCut(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("cut", h, options...)
}

func (e *htmlColGroup) OnDblClick(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dblclick", h, options...)
}

func (e *htmlColGroup) OnDrag(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("drag", h, options...)
}

func (e *htmlColGroup) OnDragEnd(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dragend", h, options...)
}

func (e *htmlColGroup) OnDragEnter(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dragenter", h, options...)
}

func (e *htmlColGroup) OnDragLeave(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dragleave", h, options...)
}

func (e *htmlColGroup) OnDragOver(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dragover", h, options...)
}

func (e *htmlColGroup) OnDragStart(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("dragstart", h, options...)
}

func (e *htmlColGroup) OnDrop(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("drop", h, options...)
}

func (e *htmlColGroup) OnFocus(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("focus", h, options...)
}

func (e *htmlColGroup) OnInput(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("input", h, options...)
}

func (e *htmlColGroup) OnInvalid(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("invalid", h, options...)
}

func (e *htmlColGroup) OnKeyDown(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("keydown", h, options...)
}

func (e *htmlColGroup) OnKeyPress(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("keypress", h, options...)
}

func (e *htmlColGroup) OnKeyUp(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("keyup", h, options...)
}

func (e *htmlColGroup) OnMouseDown(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mousedown", h, options...)
}

func (e *htmlColGroup) OnMouseEnter(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mouseenter", h, options...)
}

func (e *htmlColGroup) OnMouseLeave(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mouseleave", h, options...)
}

func (e *htmlColGroup) OnMouseMove(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mousemove", h, options...)
}

func (e *htmlColGroup) OnMouseOut(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mouseout", h, options...)
}

func (e *htmlColGroup) OnMouseOver(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mouseover", h, options...)
}

func (e *htmlColGroup) OnMouseUp(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("mouseup", h, options...)
}

func (e *htmlColGroup) OnPaste(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("paste", h, options...)
}

func (e *htmlColGroup) OnReset(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("reset", h, options...)
}

func (e *htmlColGroup) OnScroll(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("scroll", h, options...)
}

func (e *htmlColGroup) OnSearch(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("search", h, options...)
}

func (e *htmlColGroup) OnSelect(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("select", h, options...)
}

func (e *htmlColGroup) OnSubmit(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("submit", h, options...)
}

func (e *htmlColGroup) OnWheel(h EventHandler, options ...EventOption) HTMLColGroup {
	return e.On("wheel", h, options...)
}

func (e *htmlColGroup) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlColGroup) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlColGroup) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlColGroup) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlColGroup) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlColGroup) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "data" HTML element.
type HTMLData interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLData

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLData

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLData

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLData

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLData

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLData

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLData

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLData

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLData

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLData

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLData

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLData

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLData

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLData

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLData

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLData

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLData

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLData

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLData

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLData

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLData

	// Assigns a value to the element.
	Value(v any) HTMLData

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLData
}

// Returns an HTML element that pairs content with its machine-readable translation or value.
func Data() HTMLData {
	e := &htmlData{
		htmlElement: htmlElement{
			tag:           "data",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlData struct {
	htmlElement
}

func (e *htmlData) Body(v ...UI) HTMLData {
	return e.setBody(FilterUIElems(v...)).(*htmlData)
}

func (e *htmlData) Text(v any) HTMLData {
	return e.Body(Text(v))
}

func (e *htmlData) Textf(format string, v ...any) HTMLData {
	return e.Body(Textf(format, v...))
}

func (e *htmlData) AccessKey(format string, v ...any) HTMLData {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlData) Aria(k string, v any) HTMLData {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlData) Attr(n string, v any) HTMLData {
	e.setAttr(n, v)
	return e
}

func (e *htmlData) Class(v ...string) HTMLData {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlData) ContentEditable(v bool) HTMLData {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlData) DataSet(k string, v any) HTMLData {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlData) DataSets(ds map[string]any) HTMLData {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlData) Dir(format string, v ...any) HTMLData {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlData) Draggable(v bool) HTMLData {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlData) Hidden(v bool) HTMLData {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlData) ID(format string, v ...any) HTMLData {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlData) Lang(format string, v ...any) HTMLData {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlData) Role(format string, v ...any) HTMLData {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlData) Spellcheck(v bool) HTMLData {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlData) Style(k, format string, v ...any) HTMLData {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlData) Styles(s map[string]string) HTMLData {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlData) TabIndex(v int) HTMLData {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlData) Title(format string, v ...any) HTMLData {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlData) Value(v any) HTMLData {
	e.setAttr("value", v)
	return e
}

func (e *htmlData) On(event string, h EventHandler, options ...EventOption) HTMLData {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlData) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlData) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlData) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlData) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlData) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlData) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "datalist" HTML element.
type HTMLDataList interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDataList

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDataList

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDataList

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDataList

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDataList

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDataList

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDataList

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDataList

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDataList

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDataList

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDataList

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDataList

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDataList

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDataList

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDataList

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDataList

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDataList

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDataList

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDataList

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDataList

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDataList

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDataList

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDataList

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDataList

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDataList

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDataList
}

// Returns an HTML element that offers a predefined set of options for input controls.
func DataList() HTMLDataList {
	e := &htmlDataList{
		htmlElement: htmlElement{
			tag:           "datalist",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDataList struct {
	htmlElement
}

func (e *htmlDataList) Body(v ...UI) HTMLDataList {
	return e.setBody(FilterUIElems(v...)).(*htmlDataList)
}

func (e *htmlDataList) Text(v any) HTMLDataList {
	return e.Body(Text(v))
}

func (e *htmlDataList) Textf(format string, v ...any) HTMLDataList {
	return e.Body(Textf(format, v...))
}

func (e *htmlDataList) AccessKey(format string, v ...any) HTMLDataList {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDataList) Aria(k string, v any) HTMLDataList {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDataList) Attr(n string, v any) HTMLDataList {
	e.setAttr(n, v)
	return e
}

func (e *htmlDataList) Class(v ...string) HTMLDataList {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDataList) ContentEditable(v bool) HTMLDataList {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDataList) DataSet(k string, v any) HTMLDataList {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDataList) DataSets(ds map[string]any) HTMLDataList {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDataList) Dir(format string, v ...any) HTMLDataList {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDataList) Draggable(v bool) HTMLDataList {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDataList) Hidden(v bool) HTMLDataList {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDataList) ID(format string, v ...any) HTMLDataList {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDataList) Lang(format string, v ...any) HTMLDataList {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDataList) Role(format string, v ...any) HTMLDataList {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDataList) Spellcheck(v bool) HTMLDataList {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDataList) Style(k, format string, v ...any) HTMLDataList {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDataList) Styles(s map[string]string) HTMLDataList {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDataList) TabIndex(v int) HTMLDataList {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDataList) Title(format string, v ...any) HTMLDataList {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDataList) On(event string, h EventHandler, options ...EventOption) HTMLDataList {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDataList) OnBlur(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("blur", h, options...)
}

func (e *htmlDataList) OnChange(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("change", h, options...)
}

func (e *htmlDataList) OnClick(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("click", h, options...)
}

func (e *htmlDataList) OnContextMenu(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDataList) OnCopy(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("copy", h, options...)
}

func (e *htmlDataList) OnCut(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("cut", h, options...)
}

func (e *htmlDataList) OnDblClick(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dblclick", h, options...)
}

func (e *htmlDataList) OnDrag(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("drag", h, options...)
}

func (e *htmlDataList) OnDragEnd(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dragend", h, options...)
}

func (e *htmlDataList) OnDragEnter(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dragenter", h, options...)
}

func (e *htmlDataList) OnDragLeave(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dragleave", h, options...)
}

func (e *htmlDataList) OnDragOver(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dragover", h, options...)
}

func (e *htmlDataList) OnDragStart(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("dragstart", h, options...)
}

func (e *htmlDataList) OnDrop(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("drop", h, options...)
}

func (e *htmlDataList) OnFocus(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("focus", h, options...)
}

func (e *htmlDataList) OnInput(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("input", h, options...)
}

func (e *htmlDataList) OnInvalid(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("invalid", h, options...)
}

func (e *htmlDataList) OnKeyDown(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("keydown", h, options...)
}

func (e *htmlDataList) OnKeyPress(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("keypress", h, options...)
}

func (e *htmlDataList) OnKeyUp(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("keyup", h, options...)
}

func (e *htmlDataList) OnMouseDown(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mousedown", h, options...)
}

func (e *htmlDataList) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDataList) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDataList) OnMouseMove(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mousemove", h, options...)
}

func (e *htmlDataList) OnMouseOut(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mouseout", h, options...)
}

func (e *htmlDataList) OnMouseOver(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mouseover", h, options...)
}

func (e *htmlDataList) OnMouseUp(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("mouseup", h, options...)
}

func (e *htmlDataList) OnPaste(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("paste", h, options...)
}

func (e *htmlDataList) OnReset(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("reset", h, options...)
}

func (e *htmlDataList) OnScroll(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("scroll", h, options...)
}

func (e *htmlDataList) OnSearch(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("search", h, options...)
}

func (e *htmlDataList) OnSelect(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("select", h, options...)
}

func (e *htmlDataList) OnSubmit(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("submit", h, options...)
}

func (e *htmlDataList) OnWheel(h EventHandler, options ...EventOption) HTMLDataList {
	return e.On("wheel", h, options...)
}

func (e *htmlDataList) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDataList) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDataList) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDataList) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDataList) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDataList) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "dd" HTML element.
type HTMLDd interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDd

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDd

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDd

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDd

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDd

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDd

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDd

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDd

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDd

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDd

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDd

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDd

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDd

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDd

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDd

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDd

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDd

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDd

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDd

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDd

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDd

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDd

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDd

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDd

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDd

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDd

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDd

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDd

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDd

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDd

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDd

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDd

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDd

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDd

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDd

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDd
}

// Returns an HTML element that provides the description or value for a term in a description list.
func Dd() HTMLDd {
	e := &htmlDd{
		htmlElement: htmlElement{
			tag:           "dd",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDd struct {
	htmlElement
}

func (e *htmlDd) Body(v ...UI) HTMLDd {
	return e.setBody(FilterUIElems(v...)).(*htmlDd)
}

func (e *htmlDd) Text(v any) HTMLDd {
	return e.Body(Text(v))
}

func (e *htmlDd) Textf(format string, v ...any) HTMLDd {
	return e.Body(Textf(format, v...))
}

func (e *htmlDd) AccessKey(format string, v ...any) HTMLDd {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDd) Aria(k string, v any) HTMLDd {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDd) Attr(n string, v any) HTMLDd {
	e.setAttr(n, v)
	return e
}

func (e *htmlDd) Class(v ...string) HTMLDd {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDd) ContentEditable(v bool) HTMLDd {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDd) DataSet(k string, v any) HTMLDd {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDd) DataSets(ds map[string]any) HTMLDd {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDd) Dir(format string, v ...any) HTMLDd {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDd) Draggable(v bool) HTMLDd {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDd) Hidden(v bool) HTMLDd {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDd) ID(format string, v ...any) HTMLDd {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDd) Lang(format string, v ...any) HTMLDd {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDd) Role(format string, v ...any) HTMLDd {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDd) Spellcheck(v bool) HTMLDd {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDd) Style(k, format string, v ...any) HTMLDd {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDd) Styles(s map[string]string) HTMLDd {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDd) TabIndex(v int) HTMLDd {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDd) Title(format string, v ...any) HTMLDd {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDd) On(event string, h EventHandler, options ...EventOption) HTMLDd {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDd) OnBlur(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("blur", h, options...)
}

func (e *htmlDd) OnChange(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("change", h, options...)
}

func (e *htmlDd) OnClick(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("click", h, options...)
}

func (e *htmlDd) OnContextMenu(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDd) OnCopy(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("copy", h, options...)
}

func (e *htmlDd) OnCut(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("cut", h, options...)
}

func (e *htmlDd) OnDblClick(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dblclick", h, options...)
}

func (e *htmlDd) OnDrag(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("drag", h, options...)
}

func (e *htmlDd) OnDragEnd(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dragend", h, options...)
}

func (e *htmlDd) OnDragEnter(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dragenter", h, options...)
}

func (e *htmlDd) OnDragLeave(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dragleave", h, options...)
}

func (e *htmlDd) OnDragOver(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dragover", h, options...)
}

func (e *htmlDd) OnDragStart(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("dragstart", h, options...)
}

func (e *htmlDd) OnDrop(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("drop", h, options...)
}

func (e *htmlDd) OnFocus(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("focus", h, options...)
}

func (e *htmlDd) OnInput(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("input", h, options...)
}

func (e *htmlDd) OnInvalid(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("invalid", h, options...)
}

func (e *htmlDd) OnKeyDown(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("keydown", h, options...)
}

func (e *htmlDd) OnKeyPress(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("keypress", h, options...)
}

func (e *htmlDd) OnKeyUp(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("keyup", h, options...)
}

func (e *htmlDd) OnMouseDown(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mousedown", h, options...)
}

func (e *htmlDd) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDd) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDd) OnMouseMove(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mousemove", h, options...)
}

func (e *htmlDd) OnMouseOut(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mouseout", h, options...)
}

func (e *htmlDd) OnMouseOver(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mouseover", h, options...)
}

func (e *htmlDd) OnMouseUp(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("mouseup", h, options...)
}

func (e *htmlDd) OnPaste(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("paste", h, options...)
}

func (e *htmlDd) OnReset(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("reset", h, options...)
}

func (e *htmlDd) OnScroll(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("scroll", h, options...)
}

func (e *htmlDd) OnSearch(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("search", h, options...)
}

func (e *htmlDd) OnSelect(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("select", h, options...)
}

func (e *htmlDd) OnSubmit(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("submit", h, options...)
}

func (e *htmlDd) OnWheel(h EventHandler, options ...EventOption) HTMLDd {
	return e.On("wheel", h, options...)
}

func (e *htmlDd) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDd) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDd) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDd) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDd) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDd) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "del" HTML element.
type HTMLDel interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDel

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDel

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDel

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDel

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDel

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDel

	// Provides a reference or link to a source explaining quoted or modified content in the element.
	Cite(format string, v ...any) HTMLDel

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDel

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDel

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDel

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDel

	// Represents the date and time, often used in context with machine-readable equivalents of time-related content.
	DateTime(format string, v ...any) HTMLDel

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDel

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDel

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDel

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDel

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDel

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDel

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDel

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDel

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDel

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDel

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDel

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDel

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDel

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDel

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDel

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDel

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDel

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDel

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDel

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDel

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDel

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDel

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDel

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDel

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDel

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDel
}

// Returns an HTML element that denotes text segments that have been deleted or modified in the content.
func Del() HTMLDel {
	e := &htmlDel{
		htmlElement: htmlElement{
			tag:           "del",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDel struct {
	htmlElement
}

func (e *htmlDel) Body(v ...UI) HTMLDel {
	return e.setBody(FilterUIElems(v...)).(*htmlDel)
}

func (e *htmlDel) Text(v any) HTMLDel {
	return e.Body(Text(v))
}

func (e *htmlDel) Textf(format string, v ...any) HTMLDel {
	return e.Body(Textf(format, v...))
}

func (e *htmlDel) AccessKey(format string, v ...any) HTMLDel {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDel) Aria(k string, v any) HTMLDel {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDel) Attr(n string, v any) HTMLDel {
	e.setAttr(n, v)
	return e
}

func (e *htmlDel) Cite(format string, v ...any) HTMLDel {
	e.setAttr("cite", FormatString(format, v...))
	return e
}

func (e *htmlDel) Class(v ...string) HTMLDel {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDel) ContentEditable(v bool) HTMLDel {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDel) DataSet(k string, v any) HTMLDel {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDel) DataSets(ds map[string]any) HTMLDel {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDel) DateTime(format string, v ...any) HTMLDel {
	e.setAttr("datetime", FormatString(format, v...))
	return e
}

func (e *htmlDel) Dir(format string, v ...any) HTMLDel {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDel) Draggable(v bool) HTMLDel {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDel) Hidden(v bool) HTMLDel {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDel) ID(format string, v ...any) HTMLDel {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDel) Lang(format string, v ...any) HTMLDel {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDel) Role(format string, v ...any) HTMLDel {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDel) Spellcheck(v bool) HTMLDel {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDel) Style(k, format string, v ...any) HTMLDel {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDel) Styles(s map[string]string) HTMLDel {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDel) TabIndex(v int) HTMLDel {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDel) Title(format string, v ...any) HTMLDel {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDel) On(event string, h EventHandler, options ...EventOption) HTMLDel {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDel) OnBlur(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("blur", h, options...)
}

func (e *htmlDel) OnChange(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("change", h, options...)
}

func (e *htmlDel) OnClick(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("click", h, options...)
}

func (e *htmlDel) OnContextMenu(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDel) OnCopy(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("copy", h, options...)
}

func (e *htmlDel) OnCut(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("cut", h, options...)
}

func (e *htmlDel) OnDblClick(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dblclick", h, options...)
}

func (e *htmlDel) OnDrag(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("drag", h, options...)
}

func (e *htmlDel) OnDragEnd(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dragend", h, options...)
}

func (e *htmlDel) OnDragEnter(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dragenter", h, options...)
}

func (e *htmlDel) OnDragLeave(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dragleave", h, options...)
}

func (e *htmlDel) OnDragOver(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dragover", h, options...)
}

func (e *htmlDel) OnDragStart(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("dragstart", h, options...)
}

func (e *htmlDel) OnDrop(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("drop", h, options...)
}

func (e *htmlDel) OnFocus(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("focus", h, options...)
}

func (e *htmlDel) OnInput(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("input", h, options...)
}

func (e *htmlDel) OnInvalid(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("invalid", h, options...)
}

func (e *htmlDel) OnKeyDown(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("keydown", h, options...)
}

func (e *htmlDel) OnKeyPress(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("keypress", h, options...)
}

func (e *htmlDel) OnKeyUp(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("keyup", h, options...)
}

func (e *htmlDel) OnMouseDown(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mousedown", h, options...)
}

func (e *htmlDel) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDel) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDel) OnMouseMove(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mousemove", h, options...)
}

func (e *htmlDel) OnMouseOut(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mouseout", h, options...)
}

func (e *htmlDel) OnMouseOver(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mouseover", h, options...)
}

func (e *htmlDel) OnMouseUp(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("mouseup", h, options...)
}

func (e *htmlDel) OnPaste(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("paste", h, options...)
}

func (e *htmlDel) OnReset(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("reset", h, options...)
}

func (e *htmlDel) OnScroll(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("scroll", h, options...)
}

func (e *htmlDel) OnSearch(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("search", h, options...)
}

func (e *htmlDel) OnSelect(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("select", h, options...)
}

func (e *htmlDel) OnSubmit(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("submit", h, options...)
}

func (e *htmlDel) OnWheel(h EventHandler, options ...EventOption) HTMLDel {
	return e.On("wheel", h, options...)
}

func (e *htmlDel) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDel) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDel) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDel) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDel) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDel) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "details" HTML element.
type HTMLDetails interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDetails

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDetails

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDetails

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDetails

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDetails

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDetails

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDetails

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDetails

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDetails

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDetails

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDetails

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDetails

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDetails

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDetails

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDetails

	// Indicates that the details element is expanded and visible to the user.
	Open(v bool) HTMLDetails

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDetails

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDetails

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDetails

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDetails

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDetails

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDetails

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDetails

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDetails

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDetails

	// Executes the handler when the details element is toggled by the user.
	OnToggle(h EventHandler, options ...EventOption) HTMLDetails

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDetails
}

// Returns an HTML element that encapsulates content users can toggle visibility for, such as additional information or context.
func Details() HTMLDetails {
	e := &htmlDetails{
		htmlElement: htmlElement{
			tag:           "details",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDetails struct {
	htmlElement
}

func (e *htmlDetails) Body(v ...UI) HTMLDetails {
	return e.setBody(FilterUIElems(v...)).(*htmlDetails)
}

func (e *htmlDetails) Text(v any) HTMLDetails {
	return e.Body(Text(v))
}

func (e *htmlDetails) Textf(format string, v ...any) HTMLDetails {
	return e.Body(Textf(format, v...))
}

func (e *htmlDetails) AccessKey(format string, v ...any) HTMLDetails {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDetails) Aria(k string, v any) HTMLDetails {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDetails) Attr(n string, v any) HTMLDetails {
	e.setAttr(n, v)
	return e
}

func (e *htmlDetails) Class(v ...string) HTMLDetails {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDetails) ContentEditable(v bool) HTMLDetails {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDetails) DataSet(k string, v any) HTMLDetails {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDetails) DataSets(ds map[string]any) HTMLDetails {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDetails) Dir(format string, v ...any) HTMLDetails {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDetails) Draggable(v bool) HTMLDetails {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDetails) Hidden(v bool) HTMLDetails {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDetails) ID(format string, v ...any) HTMLDetails {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDetails) Lang(format string, v ...any) HTMLDetails {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDetails) Open(v bool) HTMLDetails {
	e.setAttr("open", v)
	return e
}

func (e *htmlDetails) Role(format string, v ...any) HTMLDetails {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDetails) Spellcheck(v bool) HTMLDetails {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDetails) Style(k, format string, v ...any) HTMLDetails {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDetails) Styles(s map[string]string) HTMLDetails {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDetails) TabIndex(v int) HTMLDetails {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDetails) Title(format string, v ...any) HTMLDetails {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDetails) On(event string, h EventHandler, options ...EventOption) HTMLDetails {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDetails) OnBlur(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("blur", h, options...)
}

func (e *htmlDetails) OnChange(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("change", h, options...)
}

func (e *htmlDetails) OnClick(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("click", h, options...)
}

func (e *htmlDetails) OnContextMenu(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDetails) OnCopy(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("copy", h, options...)
}

func (e *htmlDetails) OnCut(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("cut", h, options...)
}

func (e *htmlDetails) OnDblClick(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dblclick", h, options...)
}

func (e *htmlDetails) OnDrag(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("drag", h, options...)
}

func (e *htmlDetails) OnDragEnd(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dragend", h, options...)
}

func (e *htmlDetails) OnDragEnter(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dragenter", h, options...)
}

func (e *htmlDetails) OnDragLeave(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dragleave", h, options...)
}

func (e *htmlDetails) OnDragOver(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dragover", h, options...)
}

func (e *htmlDetails) OnDragStart(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("dragstart", h, options...)
}

func (e *htmlDetails) OnDrop(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("drop", h, options...)
}

func (e *htmlDetails) OnFocus(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("focus", h, options...)
}

func (e *htmlDetails) OnInput(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("input", h, options...)
}

func (e *htmlDetails) OnInvalid(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("invalid", h, options...)
}

func (e *htmlDetails) OnKeyDown(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("keydown", h, options...)
}

func (e *htmlDetails) OnKeyPress(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("keypress", h, options...)
}

func (e *htmlDetails) OnKeyUp(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("keyup", h, options...)
}

func (e *htmlDetails) OnMouseDown(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mousedown", h, options...)
}

func (e *htmlDetails) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDetails) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDetails) OnMouseMove(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mousemove", h, options...)
}

func (e *htmlDetails) OnMouseOut(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mouseout", h, options...)
}

func (e *htmlDetails) OnMouseOver(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mouseover", h, options...)
}

func (e *htmlDetails) OnMouseUp(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("mouseup", h, options...)
}

func (e *htmlDetails) OnPaste(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("paste", h, options...)
}

func (e *htmlDetails) OnReset(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("reset", h, options...)
}

func (e *htmlDetails) OnScroll(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("scroll", h, options...)
}

func (e *htmlDetails) OnSearch(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("search", h, options...)
}

func (e *htmlDetails) OnSelect(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("select", h, options...)
}

func (e *htmlDetails) OnSubmit(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("submit", h, options...)
}

func (e *htmlDetails) OnToggle(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("toggle", h, options...)
}

func (e *htmlDetails) OnWheel(h EventHandler, options ...EventOption) HTMLDetails {
	return e.On("wheel", h, options...)
}

func (e *htmlDetails) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDetails) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDetails) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDetails) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDetails) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDetails) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "dfn" HTML element.
type HTMLDfn interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDfn

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDfn

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDfn

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDfn

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDfn

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDfn

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDfn

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDfn

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDfn

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDfn

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDfn

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDfn

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDfn

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDfn

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDfn

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDfn

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDfn

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDfn

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDfn

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDfn

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDfn

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDfn

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDfn

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDfn

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDfn

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDfn
}

// Returns an HTML element that marks the defining occurrence or clarification of a term or phrase.
func Dfn() HTMLDfn {
	e := &htmlDfn{
		htmlElement: htmlElement{
			tag:           "dfn",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDfn struct {
	htmlElement
}

func (e *htmlDfn) Body(v ...UI) HTMLDfn {
	return e.setBody(FilterUIElems(v...)).(*htmlDfn)
}

func (e *htmlDfn) Text(v any) HTMLDfn {
	return e.Body(Text(v))
}

func (e *htmlDfn) Textf(format string, v ...any) HTMLDfn {
	return e.Body(Textf(format, v...))
}

func (e *htmlDfn) AccessKey(format string, v ...any) HTMLDfn {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDfn) Aria(k string, v any) HTMLDfn {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDfn) Attr(n string, v any) HTMLDfn {
	e.setAttr(n, v)
	return e
}

func (e *htmlDfn) Class(v ...string) HTMLDfn {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDfn) ContentEditable(v bool) HTMLDfn {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDfn) DataSet(k string, v any) HTMLDfn {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDfn) DataSets(ds map[string]any) HTMLDfn {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDfn) Dir(format string, v ...any) HTMLDfn {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDfn) Draggable(v bool) HTMLDfn {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDfn) Hidden(v bool) HTMLDfn {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDfn) ID(format string, v ...any) HTMLDfn {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDfn) Lang(format string, v ...any) HTMLDfn {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDfn) Role(format string, v ...any) HTMLDfn {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDfn) Spellcheck(v bool) HTMLDfn {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDfn) Style(k, format string, v ...any) HTMLDfn {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDfn) Styles(s map[string]string) HTMLDfn {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDfn) TabIndex(v int) HTMLDfn {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDfn) Title(format string, v ...any) HTMLDfn {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDfn) On(event string, h EventHandler, options ...EventOption) HTMLDfn {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDfn) OnBlur(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("blur", h, options...)
}

func (e *htmlDfn) OnChange(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("change", h, options...)
}

func (e *htmlDfn) OnClick(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("click", h, options...)
}

func (e *htmlDfn) OnContextMenu(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDfn) OnCopy(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("copy", h, options...)
}

func (e *htmlDfn) OnCut(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("cut", h, options...)
}

func (e *htmlDfn) OnDblClick(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dblclick", h, options...)
}

func (e *htmlDfn) OnDrag(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("drag", h, options...)
}

func (e *htmlDfn) OnDragEnd(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dragend", h, options...)
}

func (e *htmlDfn) OnDragEnter(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dragenter", h, options...)
}

func (e *htmlDfn) OnDragLeave(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dragleave", h, options...)
}

func (e *htmlDfn) OnDragOver(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dragover", h, options...)
}

func (e *htmlDfn) OnDragStart(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("dragstart", h, options...)
}

func (e *htmlDfn) OnDrop(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("drop", h, options...)
}

func (e *htmlDfn) OnFocus(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("focus", h, options...)
}

func (e *htmlDfn) OnInput(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("input", h, options...)
}

func (e *htmlDfn) OnInvalid(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("invalid", h, options...)
}

func (e *htmlDfn) OnKeyDown(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("keydown", h, options...)
}

func (e *htmlDfn) OnKeyPress(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("keypress", h, options...)
}

func (e *htmlDfn) OnKeyUp(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("keyup", h, options...)
}

func (e *htmlDfn) OnMouseDown(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mousedown", h, options...)
}

func (e *htmlDfn) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDfn) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDfn) OnMouseMove(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mousemove", h, options...)
}

func (e *htmlDfn) OnMouseOut(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mouseout", h, options...)
}

func (e *htmlDfn) OnMouseOver(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mouseover", h, options...)
}

func (e *htmlDfn) OnMouseUp(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("mouseup", h, options...)
}

func (e *htmlDfn) OnPaste(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("paste", h, options...)
}

func (e *htmlDfn) OnReset(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("reset", h, options...)
}

func (e *htmlDfn) OnScroll(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("scroll", h, options...)
}

func (e *htmlDfn) OnSearch(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("search", h, options...)
}

func (e *htmlDfn) OnSelect(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("select", h, options...)
}

func (e *htmlDfn) OnSubmit(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("submit", h, options...)
}

func (e *htmlDfn) OnWheel(h EventHandler, options ...EventOption) HTMLDfn {
	return e.On("wheel", h, options...)
}

func (e *htmlDfn) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDfn) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDfn) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDfn) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDfn) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDfn) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "dialog" HTML element.
type HTMLDialog interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDialog

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDialog

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDialog

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDialog

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDialog

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDialog

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDialog

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDialog

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDialog

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDialog

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDialog

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDialog

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDialog

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDialog

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDialog

	// Indicates that the details element is expanded and visible to the user.
	Open(v bool) HTMLDialog

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDialog

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDialog

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDialog

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDialog

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDialog

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDialog

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDialog

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDialog

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDialog

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDialog

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDialog
}

// Returns an HTML element that represents a popup dialog box or an interactive window overlay.
func Dialog() HTMLDialog {
	e := &htmlDialog{
		htmlElement: htmlElement{
			tag:           "dialog",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDialog struct {
	htmlElement
}

func (e *htmlDialog) Body(v ...UI) HTMLDialog {
	return e.setBody(FilterUIElems(v...)).(*htmlDialog)
}

func (e *htmlDialog) Text(v any) HTMLDialog {
	return e.Body(Text(v))
}

func (e *htmlDialog) Textf(format string, v ...any) HTMLDialog {
	return e.Body(Textf(format, v...))
}

func (e *htmlDialog) AccessKey(format string, v ...any) HTMLDialog {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDialog) Aria(k string, v any) HTMLDialog {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDialog) Attr(n string, v any) HTMLDialog {
	e.setAttr(n, v)
	return e
}

func (e *htmlDialog) Class(v ...string) HTMLDialog {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDialog) ContentEditable(v bool) HTMLDialog {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDialog) DataSet(k string, v any) HTMLDialog {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDialog) DataSets(ds map[string]any) HTMLDialog {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDialog) Dir(format string, v ...any) HTMLDialog {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDialog) Draggable(v bool) HTMLDialog {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDialog) Hidden(v bool) HTMLDialog {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDialog) ID(format string, v ...any) HTMLDialog {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDialog) Lang(format string, v ...any) HTMLDialog {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDialog) Open(v bool) HTMLDialog {
	e.setAttr("open", v)
	return e
}

func (e *htmlDialog) Role(format string, v ...any) HTMLDialog {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDialog) Spellcheck(v bool) HTMLDialog {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDialog) Style(k, format string, v ...any) HTMLDialog {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDialog) Styles(s map[string]string) HTMLDialog {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDialog) TabIndex(v int) HTMLDialog {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDialog) Title(format string, v ...any) HTMLDialog {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDialog) On(event string, h EventHandler, options ...EventOption) HTMLDialog {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDialog) OnBlur(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("blur", h, options...)
}

func (e *htmlDialog) OnChange(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("change", h, options...)
}

func (e *htmlDialog) OnClick(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("click", h, options...)
}

func (e *htmlDialog) OnContextMenu(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDialog) OnCopy(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("copy", h, options...)
}

func (e *htmlDialog) OnCut(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("cut", h, options...)
}

func (e *htmlDialog) OnDblClick(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dblclick", h, options...)
}

func (e *htmlDialog) OnDrag(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("drag", h, options...)
}

func (e *htmlDialog) OnDragEnd(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dragend", h, options...)
}

func (e *htmlDialog) OnDragEnter(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dragenter", h, options...)
}

func (e *htmlDialog) OnDragLeave(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dragleave", h, options...)
}

func (e *htmlDialog) OnDragOver(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dragover", h, options...)
}

func (e *htmlDialog) OnDragStart(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("dragstart", h, options...)
}

func (e *htmlDialog) OnDrop(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("drop", h, options...)
}

func (e *htmlDialog) OnFocus(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("focus", h, options...)
}

func (e *htmlDialog) OnInput(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("input", h, options...)
}

func (e *htmlDialog) OnInvalid(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("invalid", h, options...)
}

func (e *htmlDialog) OnKeyDown(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("keydown", h, options...)
}

func (e *htmlDialog) OnKeyPress(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("keypress", h, options...)
}

func (e *htmlDialog) OnKeyUp(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("keyup", h, options...)
}

func (e *htmlDialog) OnMouseDown(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mousedown", h, options...)
}

func (e *htmlDialog) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDialog) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDialog) OnMouseMove(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mousemove", h, options...)
}

func (e *htmlDialog) OnMouseOut(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mouseout", h, options...)
}

func (e *htmlDialog) OnMouseOver(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mouseover", h, options...)
}

func (e *htmlDialog) OnMouseUp(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("mouseup", h, options...)
}

func (e *htmlDialog) OnPaste(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("paste", h, options...)
}

func (e *htmlDialog) OnReset(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("reset", h, options...)
}

func (e *htmlDialog) OnScroll(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("scroll", h, options...)
}

func (e *htmlDialog) OnSearch(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("search", h, options...)
}

func (e *htmlDialog) OnSelect(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("select", h, options...)
}

func (e *htmlDialog) OnSubmit(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("submit", h, options...)
}

func (e *htmlDialog) OnWheel(h EventHandler, options ...EventOption) HTMLDialog {
	return e.On("wheel", h, options...)
}

func (e *htmlDialog) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDialog) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDialog) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDialog) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDialog) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDialog) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "div" HTML element.
type HTMLDiv interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDiv

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDiv

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDiv

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDiv

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDiv

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDiv

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDiv

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDiv

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDiv

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDiv

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDiv

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDiv

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDiv

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDiv

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDiv

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDiv

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDiv

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDiv

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDiv

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDiv

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDiv

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDiv

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDiv

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDiv

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDiv

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDiv
}

// Returns an HTML element that creates a generic container for flow content, usually combined with styles or scripts.
func Div() HTMLDiv {
	e := &htmlDiv{
		htmlElement: htmlElement{
			tag:           "div",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDiv struct {
	htmlElement
}

func (e *htmlDiv) Body(v ...UI) HTMLDiv {
	return e.setBody(FilterUIElems(v...)).(*htmlDiv)
}

func (e *htmlDiv) Text(v any) HTMLDiv {
	return e.Body(Text(v))
}

func (e *htmlDiv) Textf(format string, v ...any) HTMLDiv {
	return e.Body(Textf(format, v...))
}

func (e *htmlDiv) AccessKey(format string, v ...any) HTMLDiv {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDiv) Aria(k string, v any) HTMLDiv {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDiv) Attr(n string, v any) HTMLDiv {
	e.setAttr(n, v)
	return e
}

func (e *htmlDiv) Class(v ...string) HTMLDiv {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDiv) ContentEditable(v bool) HTMLDiv {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDiv) DataSet(k string, v any) HTMLDiv {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDiv) DataSets(ds map[string]any) HTMLDiv {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDiv) Dir(format string, v ...any) HTMLDiv {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDiv) Draggable(v bool) HTMLDiv {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDiv) Hidden(v bool) HTMLDiv {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDiv) ID(format string, v ...any) HTMLDiv {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDiv) Lang(format string, v ...any) HTMLDiv {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDiv) Role(format string, v ...any) HTMLDiv {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDiv) Spellcheck(v bool) HTMLDiv {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDiv) Style(k, format string, v ...any) HTMLDiv {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDiv) Styles(s map[string]string) HTMLDiv {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDiv) TabIndex(v int) HTMLDiv {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDiv) Title(format string, v ...any) HTMLDiv {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDiv) On(event string, h EventHandler, options ...EventOption) HTMLDiv {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDiv) OnBlur(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("blur", h, options...)
}

func (e *htmlDiv) OnChange(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("change", h, options...)
}

func (e *htmlDiv) OnClick(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("click", h, options...)
}

func (e *htmlDiv) OnContextMenu(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDiv) OnCopy(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("copy", h, options...)
}

func (e *htmlDiv) OnCut(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("cut", h, options...)
}

func (e *htmlDiv) OnDblClick(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dblclick", h, options...)
}

func (e *htmlDiv) OnDrag(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("drag", h, options...)
}

func (e *htmlDiv) OnDragEnd(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dragend", h, options...)
}

func (e *htmlDiv) OnDragEnter(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dragenter", h, options...)
}

func (e *htmlDiv) OnDragLeave(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dragleave", h, options...)
}

func (e *htmlDiv) OnDragOver(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dragover", h, options...)
}

func (e *htmlDiv) OnDragStart(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("dragstart", h, options...)
}

func (e *htmlDiv) OnDrop(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("drop", h, options...)
}

func (e *htmlDiv) OnFocus(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("focus", h, options...)
}

func (e *htmlDiv) OnInput(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("input", h, options...)
}

func (e *htmlDiv) OnInvalid(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("invalid", h, options...)
}

func (e *htmlDiv) OnKeyDown(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("keydown", h, options...)
}

func (e *htmlDiv) OnKeyPress(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("keypress", h, options...)
}

func (e *htmlDiv) OnKeyUp(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("keyup", h, options...)
}

func (e *htmlDiv) OnMouseDown(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mousedown", h, options...)
}

func (e *htmlDiv) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDiv) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDiv) OnMouseMove(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mousemove", h, options...)
}

func (e *htmlDiv) OnMouseOut(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mouseout", h, options...)
}

func (e *htmlDiv) OnMouseOver(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mouseover", h, options...)
}

func (e *htmlDiv) OnMouseUp(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("mouseup", h, options...)
}

func (e *htmlDiv) OnPaste(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("paste", h, options...)
}

func (e *htmlDiv) OnReset(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("reset", h, options...)
}

func (e *htmlDiv) OnScroll(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("scroll", h, options...)
}

func (e *htmlDiv) OnSearch(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("search", h, options...)
}

func (e *htmlDiv) OnSelect(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("select", h, options...)
}

func (e *htmlDiv) OnSubmit(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("submit", h, options...)
}

func (e *htmlDiv) OnWheel(h EventHandler, options ...EventOption) HTMLDiv {
	return e.On("wheel", h, options...)
}

func (e *htmlDiv) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDiv) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDiv) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDiv) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDiv) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDiv) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "dl" HTML element.
type HTMLDl interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDl

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDl

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDl

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDl

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDl

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDl

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDl

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDl

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDl

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDl

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDl

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDl

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDl

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDl

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDl

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDl

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDl

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDl

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDl

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDl

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDl

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDl

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDl

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDl

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDl

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDl

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDl

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDl

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDl

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDl

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDl

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDl

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDl

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDl

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDl

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDl
}

// Returns an HTML element that structures a list of terms alongside their associated descriptions.
func Dl() HTMLDl {
	e := &htmlDl{
		htmlElement: htmlElement{
			tag:           "dl",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDl struct {
	htmlElement
}

func (e *htmlDl) Body(v ...UI) HTMLDl {
	return e.setBody(FilterUIElems(v...)).(*htmlDl)
}

func (e *htmlDl) Text(v any) HTMLDl {
	return e.Body(Text(v))
}

func (e *htmlDl) Textf(format string, v ...any) HTMLDl {
	return e.Body(Textf(format, v...))
}

func (e *htmlDl) AccessKey(format string, v ...any) HTMLDl {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDl) Aria(k string, v any) HTMLDl {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDl) Attr(n string, v any) HTMLDl {
	e.setAttr(n, v)
	return e
}

func (e *htmlDl) Class(v ...string) HTMLDl {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDl) ContentEditable(v bool) HTMLDl {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDl) DataSet(k string, v any) HTMLDl {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDl) DataSets(ds map[string]any) HTMLDl {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDl) Dir(format string, v ...any) HTMLDl {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDl) Draggable(v bool) HTMLDl {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDl) Hidden(v bool) HTMLDl {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDl) ID(format string, v ...any) HTMLDl {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDl) Lang(format string, v ...any) HTMLDl {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDl) Role(format string, v ...any) HTMLDl {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDl) Spellcheck(v bool) HTMLDl {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDl) Style(k, format string, v ...any) HTMLDl {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDl) Styles(s map[string]string) HTMLDl {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDl) TabIndex(v int) HTMLDl {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDl) Title(format string, v ...any) HTMLDl {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDl) On(event string, h EventHandler, options ...EventOption) HTMLDl {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDl) OnBlur(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("blur", h, options...)
}

func (e *htmlDl) OnChange(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("change", h, options...)
}

func (e *htmlDl) OnClick(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("click", h, options...)
}

func (e *htmlDl) OnContextMenu(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDl) OnCopy(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("copy", h, options...)
}

func (e *htmlDl) OnCut(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("cut", h, options...)
}

func (e *htmlDl) OnDblClick(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dblclick", h, options...)
}

func (e *htmlDl) OnDrag(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("drag", h, options...)
}

func (e *htmlDl) OnDragEnd(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dragend", h, options...)
}

func (e *htmlDl) OnDragEnter(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dragenter", h, options...)
}

func (e *htmlDl) OnDragLeave(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dragleave", h, options...)
}

func (e *htmlDl) OnDragOver(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dragover", h, options...)
}

func (e *htmlDl) OnDragStart(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("dragstart", h, options...)
}

func (e *htmlDl) OnDrop(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("drop", h, options...)
}

func (e *htmlDl) OnFocus(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("focus", h, options...)
}

func (e *htmlDl) OnInput(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("input", h, options...)
}

func (e *htmlDl) OnInvalid(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("invalid", h, options...)
}

func (e *htmlDl) OnKeyDown(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("keydown", h, options...)
}

func (e *htmlDl) OnKeyPress(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("keypress", h, options...)
}

func (e *htmlDl) OnKeyUp(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("keyup", h, options...)
}

func (e *htmlDl) OnMouseDown(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mousedown", h, options...)
}

func (e *htmlDl) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDl) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDl) OnMouseMove(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mousemove", h, options...)
}

func (e *htmlDl) OnMouseOut(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mouseout", h, options...)
}

func (e *htmlDl) OnMouseOver(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mouseover", h, options...)
}

func (e *htmlDl) OnMouseUp(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("mouseup", h, options...)
}

func (e *htmlDl) OnPaste(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("paste", h, options...)
}

func (e *htmlDl) OnReset(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("reset", h, options...)
}

func (e *htmlDl) OnScroll(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("scroll", h, options...)
}

func (e *htmlDl) OnSearch(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("search", h, options...)
}

func (e *htmlDl) OnSelect(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("select", h, options...)
}

func (e *htmlDl) OnSubmit(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("submit", h, options...)
}

func (e *htmlDl) OnWheel(h EventHandler, options ...EventOption) HTMLDl {
	return e.On("wheel", h, options...)
}

func (e *htmlDl) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDl) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDl) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDl) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDl) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDl) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "dt" HTML element.
type HTMLDt interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLDt

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLDt

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLDt

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLDt

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLDt

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLDt

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLDt

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLDt

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLDt

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLDt

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLDt

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLDt

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLDt

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLDt

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLDt

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLDt

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLDt

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLDt

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLDt

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLDt

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLDt

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLDt

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLDt

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLDt

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLDt

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLDt

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLDt

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLDt

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLDt

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLDt

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLDt

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLDt

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLDt

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLDt

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLDt

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLDt
}

// Returns an HTML element that specifies a term or name within a description list.
func Dt() HTMLDt {
	e := &htmlDt{
		htmlElement: htmlElement{
			tag:           "dt",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlDt struct {
	htmlElement
}

func (e *htmlDt) Body(v ...UI) HTMLDt {
	return e.setBody(FilterUIElems(v...)).(*htmlDt)
}

func (e *htmlDt) Text(v any) HTMLDt {
	return e.Body(Text(v))
}

func (e *htmlDt) Textf(format string, v ...any) HTMLDt {
	return e.Body(Textf(format, v...))
}

func (e *htmlDt) AccessKey(format string, v ...any) HTMLDt {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlDt) Aria(k string, v any) HTMLDt {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDt) Attr(n string, v any) HTMLDt {
	e.setAttr(n, v)
	return e
}

func (e *htmlDt) Class(v ...string) HTMLDt {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlDt) ContentEditable(v bool) HTMLDt {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlDt) DataSet(k string, v any) HTMLDt {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlDt) DataSets(ds map[string]any) HTMLDt {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlDt) Dir(format string, v ...any) HTMLDt {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlDt) Draggable(v bool) HTMLDt {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlDt) Hidden(v bool) HTMLDt {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlDt) ID(format string, v ...any) HTMLDt {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlDt) Lang(format string, v ...any) HTMLDt {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlDt) Role(format string, v ...any) HTMLDt {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlDt) Spellcheck(v bool) HTMLDt {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlDt) Style(k, format string, v ...any) HTMLDt {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlDt) Styles(s map[string]string) HTMLDt {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlDt) TabIndex(v int) HTMLDt {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlDt) Title(format string, v ...any) HTMLDt {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlDt) On(event string, h EventHandler, options ...EventOption) HTMLDt {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlDt) OnBlur(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("blur", h, options...)
}

func (e *htmlDt) OnChange(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("change", h, options...)
}

func (e *htmlDt) OnClick(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("click", h, options...)
}

func (e *htmlDt) OnContextMenu(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("contextmenu", h, options...)
}

func (e *htmlDt) OnCopy(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("copy", h, options...)
}

func (e *htmlDt) OnCut(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("cut", h, options...)
}

func (e *htmlDt) OnDblClick(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dblclick", h, options...)
}

func (e *htmlDt) OnDrag(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("drag", h, options...)
}

func (e *htmlDt) OnDragEnd(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dragend", h, options...)
}

func (e *htmlDt) OnDragEnter(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dragenter", h, options...)
}

func (e *htmlDt) OnDragLeave(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dragleave", h, options...)
}

func (e *htmlDt) OnDragOver(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dragover", h, options...)
}

func (e *htmlDt) OnDragStart(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("dragstart", h, options...)
}

func (e *htmlDt) OnDrop(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("drop", h, options...)
}

func (e *htmlDt) OnFocus(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("focus", h, options...)
}

func (e *htmlDt) OnInput(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("input", h, options...)
}

func (e *htmlDt) OnInvalid(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("invalid", h, options...)
}

func (e *htmlDt) OnKeyDown(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("keydown", h, options...)
}

func (e *htmlDt) OnKeyPress(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("keypress", h, options...)
}

func (e *htmlDt) OnKeyUp(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("keyup", h, options...)
}

func (e *htmlDt) OnMouseDown(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mousedown", h, options...)
}

func (e *htmlDt) OnMouseEnter(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mouseenter", h, options...)
}

func (e *htmlDt) OnMouseLeave(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mouseleave", h, options...)
}

func (e *htmlDt) OnMouseMove(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mousemove", h, options...)
}

func (e *htmlDt) OnMouseOut(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mouseout", h, options...)
}

func (e *htmlDt) OnMouseOver(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mouseover", h, options...)
}

func (e *htmlDt) OnMouseUp(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("mouseup", h, options...)
}

func (e *htmlDt) OnPaste(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("paste", h, options...)
}

func (e *htmlDt) OnReset(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("reset", h, options...)
}

func (e *htmlDt) OnScroll(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("scroll", h, options...)
}

func (e *htmlDt) OnSearch(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("search", h, options...)
}

func (e *htmlDt) OnSelect(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("select", h, options...)
}

func (e *htmlDt) OnSubmit(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("submit", h, options...)
}

func (e *htmlDt) OnWheel(h EventHandler, options ...EventOption) HTMLDt {
	return e.On("wheel", h, options...)
}

func (e *htmlDt) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlDt) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlDt) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlDt) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlDt) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlDt) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "elem" HTML element.
type HTMLElem interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLElem

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLElem

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLElem

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLElem

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLElem

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLElem

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLElem

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLElem

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLElem

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLElem

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLElem

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLElem

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLElem

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLElem

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLElem

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLElem

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLElem

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLElem

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLElem

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLElem

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLElem

	// Defines the XML namespace for the element.
	XMLNS(v string) HTMLElem

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLElem

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLElem

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLElem

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLElem

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLElem

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLElem

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLElem

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLElem

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLElem

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLElem

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLElem

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLElem

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLElem

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLElem

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLElem
}

// Returns an HTML element that is customizable.
func Elem(tag string) HTMLElem {
	e := &htmlElem{
		htmlElement: htmlElement{
			tag:           tag,
			isSelfClosing: false,
		},
	}

	return e
}

type htmlElem struct {
	htmlElement
}

func (e *htmlElem) Body(v ...UI) HTMLElem {
	return e.setBody(FilterUIElems(v...)).(*htmlElem)
}

func (e *htmlElem) Text(v any) HTMLElem {
	return e.Body(Text(v))
}

func (e *htmlElem) Textf(format string, v ...any) HTMLElem {
	return e.Body(Textf(format, v...))
}

func (e *htmlElem) AccessKey(format string, v ...any) HTMLElem {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlElem) Aria(k string, v any) HTMLElem {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlElem) Attr(n string, v any) HTMLElem {
	e.setAttr(n, v)
	return e
}

func (e *htmlElem) Class(v ...string) HTMLElem {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlElem) ContentEditable(v bool) HTMLElem {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlElem) DataSet(k string, v any) HTMLElem {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlElem) DataSets(ds map[string]any) HTMLElem {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlElem) Dir(format string, v ...any) HTMLElem {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlElem) Draggable(v bool) HTMLElem {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlElem) Hidden(v bool) HTMLElem {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlElem) ID(format string, v ...any) HTMLElem {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlElem) Lang(format string, v ...any) HTMLElem {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlElem) Role(format string, v ...any) HTMLElem {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlElem) Spellcheck(v bool) HTMLElem {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlElem) Style(k, format string, v ...any) HTMLElem {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlElem) Styles(s map[string]string) HTMLElem {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlElem) TabIndex(v int) HTMLElem {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlElem) Title(format string, v ...any) HTMLElem {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlElem) XMLNS(v string) HTMLElem {
	e.xmlns = v
	return e
}

func (e *htmlElem) On(event string, h EventHandler, options ...EventOption) HTMLElem {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlElem) OnBlur(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("blur", h, options...)
}

func (e *htmlElem) OnChange(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("change", h, options...)
}

func (e *htmlElem) OnClick(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("click", h, options...)
}

func (e *htmlElem) OnContextMenu(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("contextmenu", h, options...)
}

func (e *htmlElem) OnCopy(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("copy", h, options...)
}

func (e *htmlElem) OnCut(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("cut", h, options...)
}

func (e *htmlElem) OnDblClick(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dblclick", h, options...)
}

func (e *htmlElem) OnDrag(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("drag", h, options...)
}

func (e *htmlElem) OnDragEnd(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dragend", h, options...)
}

func (e *htmlElem) OnDragEnter(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dragenter", h, options...)
}

func (e *htmlElem) OnDragLeave(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dragleave", h, options...)
}

func (e *htmlElem) OnDragOver(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dragover", h, options...)
}

func (e *htmlElem) OnDragStart(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("dragstart", h, options...)
}

func (e *htmlElem) OnDrop(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("drop", h, options...)
}

func (e *htmlElem) OnFocus(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("focus", h, options...)
}

func (e *htmlElem) OnInput(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("input", h, options...)
}

func (e *htmlElem) OnInvalid(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("invalid", h, options...)
}

func (e *htmlElem) OnKeyDown(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("keydown", h, options...)
}

func (e *htmlElem) OnKeyPress(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("keypress", h, options...)
}

func (e *htmlElem) OnKeyUp(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("keyup", h, options...)
}

func (e *htmlElem) OnMouseDown(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mousedown", h, options...)
}

func (e *htmlElem) OnMouseEnter(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mouseenter", h, options...)
}

func (e *htmlElem) OnMouseLeave(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mouseleave", h, options...)
}

func (e *htmlElem) OnMouseMove(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mousemove", h, options...)
}

func (e *htmlElem) OnMouseOut(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mouseout", h, options...)
}

func (e *htmlElem) OnMouseOver(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mouseover", h, options...)
}

func (e *htmlElem) OnMouseUp(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("mouseup", h, options...)
}

func (e *htmlElem) OnPaste(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("paste", h, options...)
}

func (e *htmlElem) OnReset(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("reset", h, options...)
}

func (e *htmlElem) OnScroll(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("scroll", h, options...)
}

func (e *htmlElem) OnSearch(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("search", h, options...)
}

func (e *htmlElem) OnSelect(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("select", h, options...)
}

func (e *htmlElem) OnSubmit(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("submit", h, options...)
}

func (e *htmlElem) OnWheel(h EventHandler, options ...EventOption) HTMLElem {
	return e.On("wheel", h, options...)
}

func (e *htmlElem) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlElem) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlElem) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlElem) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlElem) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlElem) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "elemselfclosing" HTML element.
type HTMLElemSelfClosing interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLElemSelfClosing

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLElemSelfClosing

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLElemSelfClosing

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLElemSelfClosing

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLElemSelfClosing

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLElemSelfClosing

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLElemSelfClosing

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLElemSelfClosing

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLElemSelfClosing

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLElemSelfClosing

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLElemSelfClosing

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLElemSelfClosing

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLElemSelfClosing

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLElemSelfClosing

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLElemSelfClosing

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLElemSelfClosing

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLElemSelfClosing

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLElemSelfClosing

	// Defines the XML namespace for the element.
	XMLNS(v string) HTMLElemSelfClosing

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLElemSelfClosing

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLElemSelfClosing
}

// Returns an HTML element that is self-closing and customizable.
func ElemSelfClosing(tag string) HTMLElemSelfClosing {
	e := &htmlElemSelfClosing{
		htmlElement: htmlElement{
			tag:           tag,
			isSelfClosing: true,
		},
	}

	return e
}

type htmlElemSelfClosing struct {
	htmlElement
}

func (e *htmlElemSelfClosing) AccessKey(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Aria(k string, v any) HTMLElemSelfClosing {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlElemSelfClosing) Attr(n string, v any) HTMLElemSelfClosing {
	e.setAttr(n, v)
	return e
}

func (e *htmlElemSelfClosing) Class(v ...string) HTMLElemSelfClosing {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlElemSelfClosing) ContentEditable(v bool) HTMLElemSelfClosing {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlElemSelfClosing) DataSet(k string, v any) HTMLElemSelfClosing {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlElemSelfClosing) DataSets(ds map[string]any) HTMLElemSelfClosing {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlElemSelfClosing) Dir(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Draggable(v bool) HTMLElemSelfClosing {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlElemSelfClosing) Hidden(v bool) HTMLElemSelfClosing {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlElemSelfClosing) ID(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Lang(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Role(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Spellcheck(v bool) HTMLElemSelfClosing {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlElemSelfClosing) Style(k, format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) Styles(s map[string]string) HTMLElemSelfClosing {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlElemSelfClosing) TabIndex(v int) HTMLElemSelfClosing {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlElemSelfClosing) Title(format string, v ...any) HTMLElemSelfClosing {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlElemSelfClosing) XMLNS(v string) HTMLElemSelfClosing {
	e.xmlns = v
	return e
}

func (e *htmlElemSelfClosing) On(event string, h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlElemSelfClosing) OnBlur(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("blur", h, options...)
}

func (e *htmlElemSelfClosing) OnChange(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("change", h, options...)
}

func (e *htmlElemSelfClosing) OnClick(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("click", h, options...)
}

func (e *htmlElemSelfClosing) OnContextMenu(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("contextmenu", h, options...)
}

func (e *htmlElemSelfClosing) OnCopy(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("copy", h, options...)
}

func (e *htmlElemSelfClosing) OnCut(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("cut", h, options...)
}

func (e *htmlElemSelfClosing) OnDblClick(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dblclick", h, options...)
}

func (e *htmlElemSelfClosing) OnDrag(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("drag", h, options...)
}

func (e *htmlElemSelfClosing) OnDragEnd(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dragend", h, options...)
}

func (e *htmlElemSelfClosing) OnDragEnter(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dragenter", h, options...)
}

func (e *htmlElemSelfClosing) OnDragLeave(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dragleave", h, options...)
}

func (e *htmlElemSelfClosing) OnDragOver(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dragover", h, options...)
}

func (e *htmlElemSelfClosing) OnDragStart(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("dragstart", h, options...)
}

func (e *htmlElemSelfClosing) OnDrop(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("drop", h, options...)
}

func (e *htmlElemSelfClosing) OnFocus(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("focus", h, options...)
}

func (e *htmlElemSelfClosing) OnInput(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("input", h, options...)
}

func (e *htmlElemSelfClosing) OnInvalid(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("invalid", h, options...)
}

func (e *htmlElemSelfClosing) OnKeyDown(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("keydown", h, options...)
}

func (e *htmlElemSelfClosing) OnKeyPress(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("keypress", h, options...)
}

func (e *htmlElemSelfClosing) OnKeyUp(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("keyup", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseDown(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mousedown", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseEnter(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mouseenter", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseLeave(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mouseleave", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseMove(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mousemove", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseOut(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mouseout", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseOver(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mouseover", h, options...)
}

func (e *htmlElemSelfClosing) OnMouseUp(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("mouseup", h, options...)
}

func (e *htmlElemSelfClosing) OnPaste(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("paste", h, options...)
}

func (e *htmlElemSelfClosing) OnReset(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("reset", h, options...)
}

func (e *htmlElemSelfClosing) OnScroll(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("scroll", h, options...)
}

func (e *htmlElemSelfClosing) OnSearch(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("search", h, options...)
}

func (e *htmlElemSelfClosing) OnSelect(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("select", h, options...)
}

func (e *htmlElemSelfClosing) OnSubmit(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("submit", h, options...)
}

func (e *htmlElemSelfClosing) OnWheel(h EventHandler, options ...EventOption) HTMLElemSelfClosing {
	return e.On("wheel", h, options...)
}

func (e *htmlElemSelfClosing) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlElemSelfClosing) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlElemSelfClosing) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlElemSelfClosing) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlElemSelfClosing) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlElemSelfClosing) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "em" HTML element.
type HTMLEm interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLEm

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLEm

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLEm

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLEm

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLEm

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLEm

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLEm

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLEm

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLEm

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLEm

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLEm

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLEm

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLEm

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLEm

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLEm

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLEm

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLEm

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLEm

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLEm

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLEm

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLEm

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLEm

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLEm

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLEm

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLEm

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLEm

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLEm

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLEm

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLEm

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLEm

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLEm

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLEm

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLEm

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLEm

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLEm

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLEm
}

// Returns an HTML element that marks text for emphasis, typically rendered as italicized text.
func Em() HTMLEm {
	e := &htmlEm{
		htmlElement: htmlElement{
			tag:           "em",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlEm struct {
	htmlElement
}

func (e *htmlEm) Body(v ...UI) HTMLEm {
	return e.setBody(FilterUIElems(v...)).(*htmlEm)
}

func (e *htmlEm) Text(v any) HTMLEm {
	return e.Body(Text(v))
}

func (e *htmlEm) Textf(format string, v ...any) HTMLEm {
	return e.Body(Textf(format, v...))
}

func (e *htmlEm) AccessKey(format string, v ...any) HTMLEm {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlEm) Aria(k string, v any) HTMLEm {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlEm) Attr(n string, v any) HTMLEm {
	e.setAttr(n, v)
	return e
}

func (e *htmlEm) Class(v ...string) HTMLEm {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlEm) ContentEditable(v bool) HTMLEm {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlEm) DataSet(k string, v any) HTMLEm {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlEm) DataSets(ds map[string]any) HTMLEm {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlEm) Dir(format string, v ...any) HTMLEm {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlEm) Draggable(v bool) HTMLEm {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlEm) Hidden(v bool) HTMLEm {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlEm) ID(format string, v ...any) HTMLEm {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlEm) Lang(format string, v ...any) HTMLEm {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlEm) Role(format string, v ...any) HTMLEm {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlEm) Spellcheck(v bool) HTMLEm {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlEm) Style(k, format string, v ...any) HTMLEm {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlEm) Styles(s map[string]string) HTMLEm {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlEm) TabIndex(v int) HTMLEm {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlEm) Title(format string, v ...any) HTMLEm {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlEm) On(event string, h EventHandler, options ...EventOption) HTMLEm {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlEm) OnBlur(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("blur", h, options...)
}

func (e *htmlEm) OnChange(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("change", h, options...)
}

func (e *htmlEm) OnClick(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("click", h, options...)
}

func (e *htmlEm) OnContextMenu(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("contextmenu", h, options...)
}

func (e *htmlEm) OnCopy(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("copy", h, options...)
}

func (e *htmlEm) OnCut(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("cut", h, options...)
}

func (e *htmlEm) OnDblClick(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dblclick", h, options...)
}

func (e *htmlEm) OnDrag(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("drag", h, options...)
}

func (e *htmlEm) OnDragEnd(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dragend", h, options...)
}

func (e *htmlEm) OnDragEnter(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dragenter", h, options...)
}

func (e *htmlEm) OnDragLeave(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dragleave", h, options...)
}

func (e *htmlEm) OnDragOver(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dragover", h, options...)
}

func (e *htmlEm) OnDragStart(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("dragstart", h, options...)
}

func (e *htmlEm) OnDrop(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("drop", h, options...)
}

func (e *htmlEm) OnFocus(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("focus", h, options...)
}

func (e *htmlEm) OnInput(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("input", h, options...)
}

func (e *htmlEm) OnInvalid(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("invalid", h, options...)
}

func (e *htmlEm) OnKeyDown(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("keydown", h, options...)
}

func (e *htmlEm) OnKeyPress(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("keypress", h, options...)
}

func (e *htmlEm) OnKeyUp(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("keyup", h, options...)
}

func (e *htmlEm) OnMouseDown(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mousedown", h, options...)
}

func (e *htmlEm) OnMouseEnter(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mouseenter", h, options...)
}

func (e *htmlEm) OnMouseLeave(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mouseleave", h, options...)
}

func (e *htmlEm) OnMouseMove(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mousemove", h, options...)
}

func (e *htmlEm) OnMouseOut(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mouseout", h, options...)
}

func (e *htmlEm) OnMouseOver(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mouseover", h, options...)
}

func (e *htmlEm) OnMouseUp(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("mouseup", h, options...)
}

func (e *htmlEm) OnPaste(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("paste", h, options...)
}

func (e *htmlEm) OnReset(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("reset", h, options...)
}

func (e *htmlEm) OnScroll(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("scroll", h, options...)
}

func (e *htmlEm) OnSearch(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("search", h, options...)
}

func (e *htmlEm) OnSelect(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("select", h, options...)
}

func (e *htmlEm) OnSubmit(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("submit", h, options...)
}

func (e *htmlEm) OnWheel(h EventHandler, options ...EventOption) HTMLEm {
	return e.On("wheel", h, options...)
}

func (e *htmlEm) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlEm) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlEm) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlEm) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlEm) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlEm) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "embed" HTML element.
type HTMLEmbed interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLEmbed

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLEmbed

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLEmbed

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLEmbed

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLEmbed

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLEmbed

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLEmbed

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLEmbed

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLEmbed

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLEmbed

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLEmbed

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLEmbed

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLEmbed

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLEmbed

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLEmbed

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLEmbed

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLEmbed

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLEmbed

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLEmbed

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLEmbed

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLEmbed

	// Sets the width of the element.
	Width(v int) HTMLEmbed

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when media loading is aborted.
	OnAbort(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler when media has buffered sufficiently to begin playback.
	OnCanPlay(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when media can be played through without buffering interruptions.
	OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler upon cue changes within a track element.
	OnCueChange(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler when the media's duration changes.
	OnDurationChange(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when media unexpectedly becomes unavailable.
	OnEmptied(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when media playback reaches the end.
	OnEnded(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when media loading commences.
	OnLoadStart(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler as media data finishes loading.
	OnLoadedData(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when metadata (like duration and dimensions) are fully loaded.
	OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler when media playback is paused.
	OnPause(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when media starts its playback.
	OnPlay(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler once the media has initiated playback.
	OnPlaying(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler while the browser fetches media data.
	OnProgress(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when playback rate changes (e.g., slow motion or fast forward).
	OnRateChange(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler post seeking completion.
	OnSeeked(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler during the seeking process.
	OnSeeking(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler when media data fetching stalls.
	OnStalled(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when media data fetching is suspended.
	OnSuspend(h EventHandler, options ...EventOption) HTMLEmbed

	// Executes the handler when the media's playback position changes.
	OnTimeUpdate(h EventHandler, options ...EventOption) HTMLEmbed

	// Invokes the handler upon volume changes or muting.
	OnVolumeChange(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the handler when media pauses, awaiting further buffering.
	OnWaiting(h EventHandler, options ...EventOption) HTMLEmbed

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLEmbed
}

// Returns an HTML element that offers a container for integrating non-HTML content or applications.
func Embed() HTMLEmbed {
	e := &htmlEmbed{
		htmlElement: htmlElement{
			tag:           "embed",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlEmbed struct {
	htmlElement
}

func (e *htmlEmbed) AccessKey(format string, v ...any) HTMLEmbed {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Aria(k string, v any) HTMLEmbed {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlEmbed) Attr(n string, v any) HTMLEmbed {
	e.setAttr(n, v)
	return e
}

func (e *htmlEmbed) Class(v ...string) HTMLEmbed {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlEmbed) ContentEditable(v bool) HTMLEmbed {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlEmbed) DataSet(k string, v any) HTMLEmbed {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlEmbed) DataSets(ds map[string]any) HTMLEmbed {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlEmbed) Dir(format string, v ...any) HTMLEmbed {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Draggable(v bool) HTMLEmbed {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlEmbed) Height(v int) HTMLEmbed {
	e.setAttr("height", v)
	return e
}

func (e *htmlEmbed) Hidden(v bool) HTMLEmbed {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlEmbed) ID(format string, v ...any) HTMLEmbed {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Lang(format string, v ...any) HTMLEmbed {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Role(format string, v ...any) HTMLEmbed {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Spellcheck(v bool) HTMLEmbed {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlEmbed) Src(format string, v ...any) HTMLEmbed {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Style(k, format string, v ...any) HTMLEmbed {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Styles(s map[string]string) HTMLEmbed {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlEmbed) TabIndex(v int) HTMLEmbed {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlEmbed) Title(format string, v ...any) HTMLEmbed {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Type(format string, v ...any) HTMLEmbed {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlEmbed) Width(v int) HTMLEmbed {
	e.setAttr("width", v)
	return e
}

func (e *htmlEmbed) On(event string, h EventHandler, options ...EventOption) HTMLEmbed {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlEmbed) OnAbort(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("abort", h, options...)
}

func (e *htmlEmbed) OnBlur(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("blur", h, options...)
}

func (e *htmlEmbed) OnCanPlay(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("canplay", h, options...)
}

func (e *htmlEmbed) OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("canplaythrough", h, options...)
}

func (e *htmlEmbed) OnChange(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("change", h, options...)
}

func (e *htmlEmbed) OnClick(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("click", h, options...)
}

func (e *htmlEmbed) OnContextMenu(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("contextmenu", h, options...)
}

func (e *htmlEmbed) OnCopy(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("copy", h, options...)
}

func (e *htmlEmbed) OnCueChange(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("cuechange", h, options...)
}

func (e *htmlEmbed) OnCut(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("cut", h, options...)
}

func (e *htmlEmbed) OnDblClick(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dblclick", h, options...)
}

func (e *htmlEmbed) OnDrag(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("drag", h, options...)
}

func (e *htmlEmbed) OnDragEnd(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dragend", h, options...)
}

func (e *htmlEmbed) OnDragEnter(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dragenter", h, options...)
}

func (e *htmlEmbed) OnDragLeave(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dragleave", h, options...)
}

func (e *htmlEmbed) OnDragOver(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dragover", h, options...)
}

func (e *htmlEmbed) OnDragStart(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("dragstart", h, options...)
}

func (e *htmlEmbed) OnDrop(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("drop", h, options...)
}

func (e *htmlEmbed) OnDurationChange(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("durationchange", h, options...)
}

func (e *htmlEmbed) OnEmptied(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("emptied", h, options...)
}

func (e *htmlEmbed) OnEnded(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("ended", h, options...)
}

func (e *htmlEmbed) OnError(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("error", h, options...)
}

func (e *htmlEmbed) OnFocus(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("focus", h, options...)
}

func (e *htmlEmbed) OnInput(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("input", h, options...)
}

func (e *htmlEmbed) OnInvalid(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("invalid", h, options...)
}

func (e *htmlEmbed) OnKeyDown(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("keydown", h, options...)
}

func (e *htmlEmbed) OnKeyPress(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("keypress", h, options...)
}

func (e *htmlEmbed) OnKeyUp(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("keyup", h, options...)
}

func (e *htmlEmbed) OnLoadStart(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("loadstart", h, options...)
}

func (e *htmlEmbed) OnLoadedData(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("loadeddata", h, options...)
}

func (e *htmlEmbed) OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("loadedmetadata", h, options...)
}

func (e *htmlEmbed) OnMouseDown(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mousedown", h, options...)
}

func (e *htmlEmbed) OnMouseEnter(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mouseenter", h, options...)
}

func (e *htmlEmbed) OnMouseLeave(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mouseleave", h, options...)
}

func (e *htmlEmbed) OnMouseMove(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mousemove", h, options...)
}

func (e *htmlEmbed) OnMouseOut(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mouseout", h, options...)
}

func (e *htmlEmbed) OnMouseOver(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mouseover", h, options...)
}

func (e *htmlEmbed) OnMouseUp(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("mouseup", h, options...)
}

func (e *htmlEmbed) OnPaste(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("paste", h, options...)
}

func (e *htmlEmbed) OnPause(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("pause", h, options...)
}

func (e *htmlEmbed) OnPlay(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("play", h, options...)
}

func (e *htmlEmbed) OnPlaying(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("playing", h, options...)
}

func (e *htmlEmbed) OnProgress(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("progress", h, options...)
}

func (e *htmlEmbed) OnRateChange(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("ratechange", h, options...)
}

func (e *htmlEmbed) OnReset(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("reset", h, options...)
}

func (e *htmlEmbed) OnScroll(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("scroll", h, options...)
}

func (e *htmlEmbed) OnSearch(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("search", h, options...)
}

func (e *htmlEmbed) OnSeeked(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("seeked", h, options...)
}

func (e *htmlEmbed) OnSeeking(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("seeking", h, options...)
}

func (e *htmlEmbed) OnSelect(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("select", h, options...)
}

func (e *htmlEmbed) OnStalled(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("stalled", h, options...)
}

func (e *htmlEmbed) OnSubmit(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("submit", h, options...)
}

func (e *htmlEmbed) OnSuspend(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("suspend", h, options...)
}

func (e *htmlEmbed) OnTimeUpdate(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("timeupdate", h, options...)
}

func (e *htmlEmbed) OnVolumeChange(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("volumechange", h, options...)
}

func (e *htmlEmbed) OnWaiting(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("waiting", h, options...)
}

func (e *htmlEmbed) OnWheel(h EventHandler, options ...EventOption) HTMLEmbed {
	return e.On("wheel", h, options...)
}

func (e *htmlEmbed) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlEmbed) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlEmbed) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlEmbed) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlEmbed) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlEmbed) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "fieldset" HTML element.
type HTMLFieldSet interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLFieldSet

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLFieldSet

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLFieldSet

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLFieldSet

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLFieldSet

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLFieldSet

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLFieldSet

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLFieldSet

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLFieldSet

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLFieldSet

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLFieldSet

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLFieldSet

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLFieldSet

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLFieldSet

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLFieldSet

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLFieldSet

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLFieldSet

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLFieldSet

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLFieldSet

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLFieldSet

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLFieldSet

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLFieldSet

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLFieldSet

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLFieldSet

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLFieldSet

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLFieldSet

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLFieldSet

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLFieldSet
}

// Returns an HTML element that clusters related input controls and labels within a form.
func FieldSet() HTMLFieldSet {
	e := &htmlFieldSet{
		htmlElement: htmlElement{
			tag:           "fieldset",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlFieldSet struct {
	htmlElement
}

func (e *htmlFieldSet) Body(v ...UI) HTMLFieldSet {
	return e.setBody(FilterUIElems(v...)).(*htmlFieldSet)
}

func (e *htmlFieldSet) Text(v any) HTMLFieldSet {
	return e.Body(Text(v))
}

func (e *htmlFieldSet) Textf(format string, v ...any) HTMLFieldSet {
	return e.Body(Textf(format, v...))
}

func (e *htmlFieldSet) AccessKey(format string, v ...any) HTMLFieldSet {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Aria(k string, v any) HTMLFieldSet {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFieldSet) Attr(n string, v any) HTMLFieldSet {
	e.setAttr(n, v)
	return e
}

func (e *htmlFieldSet) Class(v ...string) HTMLFieldSet {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlFieldSet) ContentEditable(v bool) HTMLFieldSet {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlFieldSet) DataSet(k string, v any) HTMLFieldSet {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFieldSet) DataSets(ds map[string]any) HTMLFieldSet {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlFieldSet) Dir(format string, v ...any) HTMLFieldSet {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Disabled(v bool) HTMLFieldSet {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlFieldSet) Draggable(v bool) HTMLFieldSet {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlFieldSet) Form(format string, v ...any) HTMLFieldSet {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Hidden(v bool) HTMLFieldSet {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlFieldSet) ID(format string, v ...any) HTMLFieldSet {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Lang(format string, v ...any) HTMLFieldSet {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Name(format string, v ...any) HTMLFieldSet {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Role(format string, v ...any) HTMLFieldSet {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Spellcheck(v bool) HTMLFieldSet {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlFieldSet) Style(k, format string, v ...any) HTMLFieldSet {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) Styles(s map[string]string) HTMLFieldSet {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlFieldSet) TabIndex(v int) HTMLFieldSet {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlFieldSet) Title(format string, v ...any) HTMLFieldSet {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlFieldSet) On(event string, h EventHandler, options ...EventOption) HTMLFieldSet {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlFieldSet) OnBlur(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("blur", h, options...)
}

func (e *htmlFieldSet) OnChange(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("change", h, options...)
}

func (e *htmlFieldSet) OnClick(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("click", h, options...)
}

func (e *htmlFieldSet) OnContextMenu(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("contextmenu", h, options...)
}

func (e *htmlFieldSet) OnCopy(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("copy", h, options...)
}

func (e *htmlFieldSet) OnCut(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("cut", h, options...)
}

func (e *htmlFieldSet) OnDblClick(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dblclick", h, options...)
}

func (e *htmlFieldSet) OnDrag(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("drag", h, options...)
}

func (e *htmlFieldSet) OnDragEnd(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dragend", h, options...)
}

func (e *htmlFieldSet) OnDragEnter(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dragenter", h, options...)
}

func (e *htmlFieldSet) OnDragLeave(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dragleave", h, options...)
}

func (e *htmlFieldSet) OnDragOver(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dragover", h, options...)
}

func (e *htmlFieldSet) OnDragStart(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("dragstart", h, options...)
}

func (e *htmlFieldSet) OnDrop(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("drop", h, options...)
}

func (e *htmlFieldSet) OnFocus(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("focus", h, options...)
}

func (e *htmlFieldSet) OnInput(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("input", h, options...)
}

func (e *htmlFieldSet) OnInvalid(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("invalid", h, options...)
}

func (e *htmlFieldSet) OnKeyDown(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("keydown", h, options...)
}

func (e *htmlFieldSet) OnKeyPress(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("keypress", h, options...)
}

func (e *htmlFieldSet) OnKeyUp(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("keyup", h, options...)
}

func (e *htmlFieldSet) OnMouseDown(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mousedown", h, options...)
}

func (e *htmlFieldSet) OnMouseEnter(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mouseenter", h, options...)
}

func (e *htmlFieldSet) OnMouseLeave(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mouseleave", h, options...)
}

func (e *htmlFieldSet) OnMouseMove(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mousemove", h, options...)
}

func (e *htmlFieldSet) OnMouseOut(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mouseout", h, options...)
}

func (e *htmlFieldSet) OnMouseOver(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mouseover", h, options...)
}

func (e *htmlFieldSet) OnMouseUp(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("mouseup", h, options...)
}

func (e *htmlFieldSet) OnPaste(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("paste", h, options...)
}

func (e *htmlFieldSet) OnReset(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("reset", h, options...)
}

func (e *htmlFieldSet) OnScroll(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("scroll", h, options...)
}

func (e *htmlFieldSet) OnSearch(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("search", h, options...)
}

func (e *htmlFieldSet) OnSelect(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("select", h, options...)
}

func (e *htmlFieldSet) OnSubmit(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("submit", h, options...)
}

func (e *htmlFieldSet) OnWheel(h EventHandler, options ...EventOption) HTMLFieldSet {
	return e.On("wheel", h, options...)
}

func (e *htmlFieldSet) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlFieldSet) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlFieldSet) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlFieldSet) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlFieldSet) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlFieldSet) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "figcaption" HTML element.
type HTMLFigCaption interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLFigCaption

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLFigCaption

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLFigCaption

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLFigCaption

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLFigCaption

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLFigCaption

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLFigCaption

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLFigCaption

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLFigCaption

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLFigCaption

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLFigCaption

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLFigCaption

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLFigCaption

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLFigCaption

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLFigCaption

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLFigCaption

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLFigCaption

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLFigCaption

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLFigCaption

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLFigCaption

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLFigCaption

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLFigCaption

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLFigCaption

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLFigCaption

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLFigCaption
}

// Returns an HTML element that supplies a caption or explanation for content within the <figure> element.
func FigCaption() HTMLFigCaption {
	e := &htmlFigCaption{
		htmlElement: htmlElement{
			tag:           "figcaption",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlFigCaption struct {
	htmlElement
}

func (e *htmlFigCaption) Body(v ...UI) HTMLFigCaption {
	return e.setBody(FilterUIElems(v...)).(*htmlFigCaption)
}

func (e *htmlFigCaption) Text(v any) HTMLFigCaption {
	return e.Body(Text(v))
}

func (e *htmlFigCaption) Textf(format string, v ...any) HTMLFigCaption {
	return e.Body(Textf(format, v...))
}

func (e *htmlFigCaption) AccessKey(format string, v ...any) HTMLFigCaption {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Aria(k string, v any) HTMLFigCaption {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFigCaption) Attr(n string, v any) HTMLFigCaption {
	e.setAttr(n, v)
	return e
}

func (e *htmlFigCaption) Class(v ...string) HTMLFigCaption {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlFigCaption) ContentEditable(v bool) HTMLFigCaption {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlFigCaption) DataSet(k string, v any) HTMLFigCaption {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFigCaption) DataSets(ds map[string]any) HTMLFigCaption {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlFigCaption) Dir(format string, v ...any) HTMLFigCaption {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Draggable(v bool) HTMLFigCaption {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlFigCaption) Hidden(v bool) HTMLFigCaption {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlFigCaption) ID(format string, v ...any) HTMLFigCaption {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Lang(format string, v ...any) HTMLFigCaption {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Role(format string, v ...any) HTMLFigCaption {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Spellcheck(v bool) HTMLFigCaption {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlFigCaption) Style(k, format string, v ...any) HTMLFigCaption {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) Styles(s map[string]string) HTMLFigCaption {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlFigCaption) TabIndex(v int) HTMLFigCaption {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlFigCaption) Title(format string, v ...any) HTMLFigCaption {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlFigCaption) On(event string, h EventHandler, options ...EventOption) HTMLFigCaption {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlFigCaption) OnBlur(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("blur", h, options...)
}

func (e *htmlFigCaption) OnChange(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("change", h, options...)
}

func (e *htmlFigCaption) OnClick(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("click", h, options...)
}

func (e *htmlFigCaption) OnContextMenu(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("contextmenu", h, options...)
}

func (e *htmlFigCaption) OnCopy(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("copy", h, options...)
}

func (e *htmlFigCaption) OnCut(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("cut", h, options...)
}

func (e *htmlFigCaption) OnDblClick(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dblclick", h, options...)
}

func (e *htmlFigCaption) OnDrag(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("drag", h, options...)
}

func (e *htmlFigCaption) OnDragEnd(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dragend", h, options...)
}

func (e *htmlFigCaption) OnDragEnter(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dragenter", h, options...)
}

func (e *htmlFigCaption) OnDragLeave(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dragleave", h, options...)
}

func (e *htmlFigCaption) OnDragOver(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dragover", h, options...)
}

func (e *htmlFigCaption) OnDragStart(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("dragstart", h, options...)
}

func (e *htmlFigCaption) OnDrop(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("drop", h, options...)
}

func (e *htmlFigCaption) OnFocus(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("focus", h, options...)
}

func (e *htmlFigCaption) OnInput(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("input", h, options...)
}

func (e *htmlFigCaption) OnInvalid(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("invalid", h, options...)
}

func (e *htmlFigCaption) OnKeyDown(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("keydown", h, options...)
}

func (e *htmlFigCaption) OnKeyPress(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("keypress", h, options...)
}

func (e *htmlFigCaption) OnKeyUp(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("keyup", h, options...)
}

func (e *htmlFigCaption) OnMouseDown(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mousedown", h, options...)
}

func (e *htmlFigCaption) OnMouseEnter(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mouseenter", h, options...)
}

func (e *htmlFigCaption) OnMouseLeave(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mouseleave", h, options...)
}

func (e *htmlFigCaption) OnMouseMove(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mousemove", h, options...)
}

func (e *htmlFigCaption) OnMouseOut(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mouseout", h, options...)
}

func (e *htmlFigCaption) OnMouseOver(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mouseover", h, options...)
}

func (e *htmlFigCaption) OnMouseUp(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("mouseup", h, options...)
}

func (e *htmlFigCaption) OnPaste(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("paste", h, options...)
}

func (e *htmlFigCaption) OnReset(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("reset", h, options...)
}

func (e *htmlFigCaption) OnScroll(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("scroll", h, options...)
}

func (e *htmlFigCaption) OnSearch(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("search", h, options...)
}

func (e *htmlFigCaption) OnSelect(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("select", h, options...)
}

func (e *htmlFigCaption) OnSubmit(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("submit", h, options...)
}

func (e *htmlFigCaption) OnWheel(h EventHandler, options ...EventOption) HTMLFigCaption {
	return e.On("wheel", h, options...)
}

func (e *htmlFigCaption) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlFigCaption) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlFigCaption) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlFigCaption) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlFigCaption) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlFigCaption) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "figure" HTML element.
type HTMLFigure interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLFigure

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLFigure

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLFigure

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLFigure

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLFigure

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLFigure

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLFigure

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLFigure

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLFigure

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLFigure

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLFigure

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLFigure

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLFigure

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLFigure

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLFigure

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLFigure

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLFigure

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLFigure

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLFigure

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLFigure

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLFigure

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLFigure

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLFigure

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLFigure

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLFigure

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLFigure
}

// Returns an HTML element that encapsulates media content or illustrations with an optional caption.
func Figure() HTMLFigure {
	e := &htmlFigure{
		htmlElement: htmlElement{
			tag:           "figure",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlFigure struct {
	htmlElement
}

func (e *htmlFigure) Body(v ...UI) HTMLFigure {
	return e.setBody(FilterUIElems(v...)).(*htmlFigure)
}

func (e *htmlFigure) Text(v any) HTMLFigure {
	return e.Body(Text(v))
}

func (e *htmlFigure) Textf(format string, v ...any) HTMLFigure {
	return e.Body(Textf(format, v...))
}

func (e *htmlFigure) AccessKey(format string, v ...any) HTMLFigure {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlFigure) Aria(k string, v any) HTMLFigure {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFigure) Attr(n string, v any) HTMLFigure {
	e.setAttr(n, v)
	return e
}

func (e *htmlFigure) Class(v ...string) HTMLFigure {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlFigure) ContentEditable(v bool) HTMLFigure {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlFigure) DataSet(k string, v any) HTMLFigure {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFigure) DataSets(ds map[string]any) HTMLFigure {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlFigure) Dir(format string, v ...any) HTMLFigure {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlFigure) Draggable(v bool) HTMLFigure {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlFigure) Hidden(v bool) HTMLFigure {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlFigure) ID(format string, v ...any) HTMLFigure {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlFigure) Lang(format string, v ...any) HTMLFigure {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlFigure) Role(format string, v ...any) HTMLFigure {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlFigure) Spellcheck(v bool) HTMLFigure {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlFigure) Style(k, format string, v ...any) HTMLFigure {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlFigure) Styles(s map[string]string) HTMLFigure {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlFigure) TabIndex(v int) HTMLFigure {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlFigure) Title(format string, v ...any) HTMLFigure {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlFigure) On(event string, h EventHandler, options ...EventOption) HTMLFigure {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlFigure) OnBlur(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("blur", h, options...)
}

func (e *htmlFigure) OnChange(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("change", h, options...)
}

func (e *htmlFigure) OnClick(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("click", h, options...)
}

func (e *htmlFigure) OnContextMenu(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("contextmenu", h, options...)
}

func (e *htmlFigure) OnCopy(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("copy", h, options...)
}

func (e *htmlFigure) OnCut(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("cut", h, options...)
}

func (e *htmlFigure) OnDblClick(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dblclick", h, options...)
}

func (e *htmlFigure) OnDrag(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("drag", h, options...)
}

func (e *htmlFigure) OnDragEnd(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dragend", h, options...)
}

func (e *htmlFigure) OnDragEnter(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dragenter", h, options...)
}

func (e *htmlFigure) OnDragLeave(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dragleave", h, options...)
}

func (e *htmlFigure) OnDragOver(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dragover", h, options...)
}

func (e *htmlFigure) OnDragStart(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("dragstart", h, options...)
}

func (e *htmlFigure) OnDrop(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("drop", h, options...)
}

func (e *htmlFigure) OnFocus(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("focus", h, options...)
}

func (e *htmlFigure) OnInput(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("input", h, options...)
}

func (e *htmlFigure) OnInvalid(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("invalid", h, options...)
}

func (e *htmlFigure) OnKeyDown(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("keydown", h, options...)
}

func (e *htmlFigure) OnKeyPress(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("keypress", h, options...)
}

func (e *htmlFigure) OnKeyUp(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("keyup", h, options...)
}

func (e *htmlFigure) OnMouseDown(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mousedown", h, options...)
}

func (e *htmlFigure) OnMouseEnter(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mouseenter", h, options...)
}

func (e *htmlFigure) OnMouseLeave(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mouseleave", h, options...)
}

func (e *htmlFigure) OnMouseMove(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mousemove", h, options...)
}

func (e *htmlFigure) OnMouseOut(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mouseout", h, options...)
}

func (e *htmlFigure) OnMouseOver(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mouseover", h, options...)
}

func (e *htmlFigure) OnMouseUp(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("mouseup", h, options...)
}

func (e *htmlFigure) OnPaste(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("paste", h, options...)
}

func (e *htmlFigure) OnReset(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("reset", h, options...)
}

func (e *htmlFigure) OnScroll(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("scroll", h, options...)
}

func (e *htmlFigure) OnSearch(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("search", h, options...)
}

func (e *htmlFigure) OnSelect(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("select", h, options...)
}

func (e *htmlFigure) OnSubmit(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("submit", h, options...)
}

func (e *htmlFigure) OnWheel(h EventHandler, options ...EventOption) HTMLFigure {
	return e.On("wheel", h, options...)
}

func (e *htmlFigure) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlFigure) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlFigure) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlFigure) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlFigure) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlFigure) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "footer" HTML element.
type HTMLFooter interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLFooter

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLFooter

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLFooter

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLFooter

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLFooter

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLFooter

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLFooter

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLFooter

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLFooter

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLFooter

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLFooter

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLFooter

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLFooter

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLFooter

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLFooter

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLFooter

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLFooter

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLFooter

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLFooter

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLFooter

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLFooter

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLFooter

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLFooter

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLFooter

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLFooter

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLFooter
}

// Returns an HTML element that denotes the footer of a section or the whole document, often containing metadata or author info.
func Footer() HTMLFooter {
	e := &htmlFooter{
		htmlElement: htmlElement{
			tag:           "footer",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlFooter struct {
	htmlElement
}

func (e *htmlFooter) Body(v ...UI) HTMLFooter {
	return e.setBody(FilterUIElems(v...)).(*htmlFooter)
}

func (e *htmlFooter) Text(v any) HTMLFooter {
	return e.Body(Text(v))
}

func (e *htmlFooter) Textf(format string, v ...any) HTMLFooter {
	return e.Body(Textf(format, v...))
}

func (e *htmlFooter) AccessKey(format string, v ...any) HTMLFooter {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlFooter) Aria(k string, v any) HTMLFooter {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFooter) Attr(n string, v any) HTMLFooter {
	e.setAttr(n, v)
	return e
}

func (e *htmlFooter) Class(v ...string) HTMLFooter {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlFooter) ContentEditable(v bool) HTMLFooter {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlFooter) DataSet(k string, v any) HTMLFooter {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlFooter) DataSets(ds map[string]any) HTMLFooter {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlFooter) Dir(format string, v ...any) HTMLFooter {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlFooter) Draggable(v bool) HTMLFooter {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlFooter) Hidden(v bool) HTMLFooter {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlFooter) ID(format string, v ...any) HTMLFooter {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlFooter) Lang(format string, v ...any) HTMLFooter {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlFooter) Role(format string, v ...any) HTMLFooter {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlFooter) Spellcheck(v bool) HTMLFooter {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlFooter) Style(k, format string, v ...any) HTMLFooter {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlFooter) Styles(s map[string]string) HTMLFooter {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlFooter) TabIndex(v int) HTMLFooter {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlFooter) Title(format string, v ...any) HTMLFooter {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlFooter) On(event string, h EventHandler, options ...EventOption) HTMLFooter {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlFooter) OnBlur(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("blur", h, options...)
}

func (e *htmlFooter) OnChange(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("change", h, options...)
}

func (e *htmlFooter) OnClick(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("click", h, options...)
}

func (e *htmlFooter) OnContextMenu(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("contextmenu", h, options...)
}

func (e *htmlFooter) OnCopy(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("copy", h, options...)
}

func (e *htmlFooter) OnCut(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("cut", h, options...)
}

func (e *htmlFooter) OnDblClick(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dblclick", h, options...)
}

func (e *htmlFooter) OnDrag(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("drag", h, options...)
}

func (e *htmlFooter) OnDragEnd(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dragend", h, options...)
}

func (e *htmlFooter) OnDragEnter(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dragenter", h, options...)
}

func (e *htmlFooter) OnDragLeave(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dragleave", h, options...)
}

func (e *htmlFooter) OnDragOver(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dragover", h, options...)
}

func (e *htmlFooter) OnDragStart(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("dragstart", h, options...)
}

func (e *htmlFooter) OnDrop(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("drop", h, options...)
}

func (e *htmlFooter) OnFocus(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("focus", h, options...)
}

func (e *htmlFooter) OnInput(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("input", h, options...)
}

func (e *htmlFooter) OnInvalid(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("invalid", h, options...)
}

func (e *htmlFooter) OnKeyDown(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("keydown", h, options...)
}

func (e *htmlFooter) OnKeyPress(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("keypress", h, options...)
}

func (e *htmlFooter) OnKeyUp(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("keyup", h, options...)
}

func (e *htmlFooter) OnMouseDown(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mousedown", h, options...)
}

func (e *htmlFooter) OnMouseEnter(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mouseenter", h, options...)
}

func (e *htmlFooter) OnMouseLeave(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mouseleave", h, options...)
}

func (e *htmlFooter) OnMouseMove(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mousemove", h, options...)
}

func (e *htmlFooter) OnMouseOut(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mouseout", h, options...)
}

func (e *htmlFooter) OnMouseOver(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mouseover", h, options...)
}

func (e *htmlFooter) OnMouseUp(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("mouseup", h, options...)
}

func (e *htmlFooter) OnPaste(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("paste", h, options...)
}

func (e *htmlFooter) OnReset(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("reset", h, options...)
}

func (e *htmlFooter) OnScroll(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("scroll", h, options...)
}

func (e *htmlFooter) OnSearch(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("search", h, options...)
}

func (e *htmlFooter) OnSelect(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("select", h, options...)
}

func (e *htmlFooter) OnSubmit(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("submit", h, options...)
}

func (e *htmlFooter) OnWheel(h EventHandler, options ...EventOption) HTMLFooter {
	return e.On("wheel", h, options...)
}

func (e *htmlFooter) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlFooter) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlFooter) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlFooter) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlFooter) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlFooter) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "form" HTML element.
type HTMLForm interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLForm

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLForm

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLForm

	// Restricts the character encodings accepted for form submission, ensuring compatibility.
	AcceptCharset(format string, v ...any) HTMLForm

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLForm

	// Specifies the server endpoint to which form-data should be sent upon submission.
	Action(format string, v ...any) HTMLForm

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLForm

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLForm

	// Toggles the browser's autocomplete feature, assisting users with common input values.
	AutoComplete(v bool) HTMLForm

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLForm

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLForm

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLForm

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLForm

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLForm

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLForm

	// Describes how form data should be encoded upon submission, especially vital for forms submitting file uploads.
	EncType(format string, v ...any) HTMLForm

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLForm

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLForm

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLForm

	// Determines the HTTP method for sending form data.
	Method(format string, v ...any) HTMLForm

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLForm

	// Indicates that the form should bypass validation upon submission.
	NoValidate(v bool) HTMLForm

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLForm

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLForm

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLForm

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLForm

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLForm

	// Indicates where to display the linked URL or where to submit the form. Can be called with various predefined values.
	Target(format string, v ...any) HTMLForm

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLForm

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLForm

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLForm

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLForm

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLForm

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLForm

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLForm

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLForm

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLForm

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLForm

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLForm

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLForm

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLForm

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLForm

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLForm

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLForm
}

// Returns an HTML element that constructs a user input form, allowing for various control elements and submission options.
func Form() HTMLForm {
	e := &htmlForm{
		htmlElement: htmlElement{
			tag:           "form",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlForm struct {
	htmlElement
}

func (e *htmlForm) Body(v ...UI) HTMLForm {
	return e.setBody(FilterUIElems(v...)).(*htmlForm)
}

func (e *htmlForm) Text(v any) HTMLForm {
	return e.Body(Text(v))
}

func (e *htmlForm) Textf(format string, v ...any) HTMLForm {
	return e.Body(Textf(format, v...))
}

func (e *htmlForm) AcceptCharset(format string, v ...any) HTMLForm {
	e.setAttr("accept-charset", FormatString(format, v...))
	return e
}

func (e *htmlForm) AccessKey(format string, v ...any) HTMLForm {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlForm) Action(format string, v ...any) HTMLForm {
	e.setAttr("action", FormatString(format, v...))
	return e
}

func (e *htmlForm) Aria(k string, v any) HTMLForm {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlForm) Attr(n string, v any) HTMLForm {
	e.setAttr(n, v)
	return e
}

func (e *htmlForm) AutoComplete(v bool) HTMLForm {
	s := "off"
	if v {
		s = "on"
	}

	e.setAttr("autocomplete", s)
	return e
}

func (e *htmlForm) Class(v ...string) HTMLForm {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlForm) ContentEditable(v bool) HTMLForm {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlForm) DataSet(k string, v any) HTMLForm {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlForm) DataSets(ds map[string]any) HTMLForm {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlForm) Dir(format string, v ...any) HTMLForm {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlForm) Draggable(v bool) HTMLForm {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlForm) EncType(format string, v ...any) HTMLForm {
	e.setAttr("enctype", FormatString(format, v...))
	return e
}

func (e *htmlForm) Hidden(v bool) HTMLForm {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlForm) ID(format string, v ...any) HTMLForm {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlForm) Lang(format string, v ...any) HTMLForm {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlForm) Method(format string, v ...any) HTMLForm {
	e.setAttr("method", FormatString(format, v...))
	return e
}

func (e *htmlForm) Name(format string, v ...any) HTMLForm {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlForm) NoValidate(v bool) HTMLForm {
	e.setAttr("novalidate", v)
	return e
}

func (e *htmlForm) Role(format string, v ...any) HTMLForm {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlForm) Spellcheck(v bool) HTMLForm {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlForm) Style(k, format string, v ...any) HTMLForm {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlForm) Styles(s map[string]string) HTMLForm {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlForm) TabIndex(v int) HTMLForm {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlForm) Target(format string, v ...any) HTMLForm {
	e.setAttr("target", FormatString(format, v...))
	return e
}

func (e *htmlForm) Title(format string, v ...any) HTMLForm {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlForm) On(event string, h EventHandler, options ...EventOption) HTMLForm {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlForm) OnBlur(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("blur", h, options...)
}

func (e *htmlForm) OnChange(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("change", h, options...)
}

func (e *htmlForm) OnClick(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("click", h, options...)
}

func (e *htmlForm) OnContextMenu(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("contextmenu", h, options...)
}

func (e *htmlForm) OnCopy(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("copy", h, options...)
}

func (e *htmlForm) OnCut(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("cut", h, options...)
}

func (e *htmlForm) OnDblClick(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dblclick", h, options...)
}

func (e *htmlForm) OnDrag(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("drag", h, options...)
}

func (e *htmlForm) OnDragEnd(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dragend", h, options...)
}

func (e *htmlForm) OnDragEnter(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dragenter", h, options...)
}

func (e *htmlForm) OnDragLeave(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dragleave", h, options...)
}

func (e *htmlForm) OnDragOver(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dragover", h, options...)
}

func (e *htmlForm) OnDragStart(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("dragstart", h, options...)
}

func (e *htmlForm) OnDrop(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("drop", h, options...)
}

func (e *htmlForm) OnFocus(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("focus", h, options...)
}

func (e *htmlForm) OnInput(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("input", h, options...)
}

func (e *htmlForm) OnInvalid(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("invalid", h, options...)
}

func (e *htmlForm) OnKeyDown(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("keydown", h, options...)
}

func (e *htmlForm) OnKeyPress(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("keypress", h, options...)
}

func (e *htmlForm) OnKeyUp(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("keyup", h, options...)
}

func (e *htmlForm) OnMouseDown(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mousedown", h, options...)
}

func (e *htmlForm) OnMouseEnter(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mouseenter", h, options...)
}

func (e *htmlForm) OnMouseLeave(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mouseleave", h, options...)
}

func (e *htmlForm) OnMouseMove(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mousemove", h, options...)
}

func (e *htmlForm) OnMouseOut(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mouseout", h, options...)
}

func (e *htmlForm) OnMouseOver(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mouseover", h, options...)
}

func (e *htmlForm) OnMouseUp(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("mouseup", h, options...)
}

func (e *htmlForm) OnPaste(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("paste", h, options...)
}

func (e *htmlForm) OnReset(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("reset", h, options...)
}

func (e *htmlForm) OnScroll(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("scroll", h, options...)
}

func (e *htmlForm) OnSearch(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("search", h, options...)
}

func (e *htmlForm) OnSelect(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("select", h, options...)
}

func (e *htmlForm) OnSubmit(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("submit", h, options...)
}

func (e *htmlForm) OnWheel(h EventHandler, options ...EventOption) HTMLForm {
	return e.On("wheel", h, options...)
}

func (e *htmlForm) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlForm) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlForm) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlForm) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlForm) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlForm) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h1" HTML element.
type HTMLH1 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH1

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH1

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH1

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH1

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH1

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH1

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH1

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH1

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH1

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH1

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH1

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH1

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH1

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH1

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH1

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH1

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH1

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH1

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH1

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH1

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH1

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH1

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH1

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH1

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH1

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH1

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH1

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH1

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH1

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH1

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH1

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH1

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH1

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH1

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH1

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH1
}

// Returns an HTML element that defines a level 1 HTML heading, indicating the most important topic or section.
func H1() HTMLH1 {
	e := &htmlH1{
		htmlElement: htmlElement{
			tag:           "h1",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH1 struct {
	htmlElement
}

func (e *htmlH1) Body(v ...UI) HTMLH1 {
	return e.setBody(FilterUIElems(v...)).(*htmlH1)
}

func (e *htmlH1) Text(v any) HTMLH1 {
	return e.Body(Text(v))
}

func (e *htmlH1) Textf(format string, v ...any) HTMLH1 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH1) AccessKey(format string, v ...any) HTMLH1 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH1) Aria(k string, v any) HTMLH1 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH1) Attr(n string, v any) HTMLH1 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH1) Class(v ...string) HTMLH1 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH1) ContentEditable(v bool) HTMLH1 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH1) DataSet(k string, v any) HTMLH1 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH1) DataSets(ds map[string]any) HTMLH1 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH1) Dir(format string, v ...any) HTMLH1 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH1) Draggable(v bool) HTMLH1 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH1) Hidden(v bool) HTMLH1 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH1) ID(format string, v ...any) HTMLH1 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH1) Lang(format string, v ...any) HTMLH1 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH1) Role(format string, v ...any) HTMLH1 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH1) Spellcheck(v bool) HTMLH1 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH1) Style(k, format string, v ...any) HTMLH1 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH1) Styles(s map[string]string) HTMLH1 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH1) TabIndex(v int) HTMLH1 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH1) Title(format string, v ...any) HTMLH1 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH1) On(event string, h EventHandler, options ...EventOption) HTMLH1 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH1) OnBlur(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("blur", h, options...)
}

func (e *htmlH1) OnChange(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("change", h, options...)
}

func (e *htmlH1) OnClick(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("click", h, options...)
}

func (e *htmlH1) OnContextMenu(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH1) OnCopy(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("copy", h, options...)
}

func (e *htmlH1) OnCut(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("cut", h, options...)
}

func (e *htmlH1) OnDblClick(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH1) OnDrag(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("drag", h, options...)
}

func (e *htmlH1) OnDragEnd(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dragend", h, options...)
}

func (e *htmlH1) OnDragEnter(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH1) OnDragLeave(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH1) OnDragOver(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dragover", h, options...)
}

func (e *htmlH1) OnDragStart(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH1) OnDrop(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("drop", h, options...)
}

func (e *htmlH1) OnFocus(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("focus", h, options...)
}

func (e *htmlH1) OnInput(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("input", h, options...)
}

func (e *htmlH1) OnInvalid(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("invalid", h, options...)
}

func (e *htmlH1) OnKeyDown(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("keydown", h, options...)
}

func (e *htmlH1) OnKeyPress(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("keypress", h, options...)
}

func (e *htmlH1) OnKeyUp(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("keyup", h, options...)
}

func (e *htmlH1) OnMouseDown(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH1) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH1) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH1) OnMouseMove(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH1) OnMouseOut(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH1) OnMouseOver(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH1) OnMouseUp(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH1) OnPaste(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("paste", h, options...)
}

func (e *htmlH1) OnReset(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("reset", h, options...)
}

func (e *htmlH1) OnScroll(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("scroll", h, options...)
}

func (e *htmlH1) OnSearch(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("search", h, options...)
}

func (e *htmlH1) OnSelect(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("select", h, options...)
}

func (e *htmlH1) OnSubmit(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("submit", h, options...)
}

func (e *htmlH1) OnWheel(h EventHandler, options ...EventOption) HTMLH1 {
	return e.On("wheel", h, options...)
}

func (e *htmlH1) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH1) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH1) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH1) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH1) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH1) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h2" HTML element.
type HTMLH2 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH2

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH2

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH2

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH2

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH2

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH2

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH2

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH2

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH2

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH2

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH2

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH2

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH2

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH2

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH2

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH2

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH2

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH2

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH2

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH2

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH2

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH2

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH2

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH2

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH2

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH2

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH2

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH2

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH2

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH2

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH2

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH2

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH2

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH2

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH2

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH2
}

// Returns an HTML element that defines a level 2 HTML heading, indicating a main subsection under H1.
func H2() HTMLH2 {
	e := &htmlH2{
		htmlElement: htmlElement{
			tag:           "h2",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH2 struct {
	htmlElement
}

func (e *htmlH2) Body(v ...UI) HTMLH2 {
	return e.setBody(FilterUIElems(v...)).(*htmlH2)
}

func (e *htmlH2) Text(v any) HTMLH2 {
	return e.Body(Text(v))
}

func (e *htmlH2) Textf(format string, v ...any) HTMLH2 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH2) AccessKey(format string, v ...any) HTMLH2 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH2) Aria(k string, v any) HTMLH2 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH2) Attr(n string, v any) HTMLH2 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH2) Class(v ...string) HTMLH2 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH2) ContentEditable(v bool) HTMLH2 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH2) DataSet(k string, v any) HTMLH2 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH2) DataSets(ds map[string]any) HTMLH2 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH2) Dir(format string, v ...any) HTMLH2 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH2) Draggable(v bool) HTMLH2 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH2) Hidden(v bool) HTMLH2 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH2) ID(format string, v ...any) HTMLH2 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH2) Lang(format string, v ...any) HTMLH2 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH2) Role(format string, v ...any) HTMLH2 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH2) Spellcheck(v bool) HTMLH2 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH2) Style(k, format string, v ...any) HTMLH2 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH2) Styles(s map[string]string) HTMLH2 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH2) TabIndex(v int) HTMLH2 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH2) Title(format string, v ...any) HTMLH2 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH2) On(event string, h EventHandler, options ...EventOption) HTMLH2 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH2) OnBlur(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("blur", h, options...)
}

func (e *htmlH2) OnChange(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("change", h, options...)
}

func (e *htmlH2) OnClick(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("click", h, options...)
}

func (e *htmlH2) OnContextMenu(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH2) OnCopy(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("copy", h, options...)
}

func (e *htmlH2) OnCut(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("cut", h, options...)
}

func (e *htmlH2) OnDblClick(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH2) OnDrag(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("drag", h, options...)
}

func (e *htmlH2) OnDragEnd(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dragend", h, options...)
}

func (e *htmlH2) OnDragEnter(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH2) OnDragLeave(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH2) OnDragOver(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dragover", h, options...)
}

func (e *htmlH2) OnDragStart(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH2) OnDrop(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("drop", h, options...)
}

func (e *htmlH2) OnFocus(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("focus", h, options...)
}

func (e *htmlH2) OnInput(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("input", h, options...)
}

func (e *htmlH2) OnInvalid(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("invalid", h, options...)
}

func (e *htmlH2) OnKeyDown(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("keydown", h, options...)
}

func (e *htmlH2) OnKeyPress(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("keypress", h, options...)
}

func (e *htmlH2) OnKeyUp(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("keyup", h, options...)
}

func (e *htmlH2) OnMouseDown(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH2) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH2) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH2) OnMouseMove(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH2) OnMouseOut(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH2) OnMouseOver(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH2) OnMouseUp(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH2) OnPaste(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("paste", h, options...)
}

func (e *htmlH2) OnReset(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("reset", h, options...)
}

func (e *htmlH2) OnScroll(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("scroll", h, options...)
}

func (e *htmlH2) OnSearch(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("search", h, options...)
}

func (e *htmlH2) OnSelect(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("select", h, options...)
}

func (e *htmlH2) OnSubmit(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("submit", h, options...)
}

func (e *htmlH2) OnWheel(h EventHandler, options ...EventOption) HTMLH2 {
	return e.On("wheel", h, options...)
}

func (e *htmlH2) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH2) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH2) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH2) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH2) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH2) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h3" HTML element.
type HTMLH3 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH3

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH3

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH3

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH3

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH3

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH3

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH3

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH3

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH3

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH3

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH3

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH3

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH3

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH3

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH3

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH3

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH3

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH3

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH3

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH3

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH3

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH3

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH3

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH3

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH3

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH3

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH3

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH3

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH3

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH3

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH3

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH3

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH3

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH3

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH3

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH3
}

// Returns an HTML element that defines a level 3 HTML heading, indicating a subsection under H2.
func H3() HTMLH3 {
	e := &htmlH3{
		htmlElement: htmlElement{
			tag:           "h3",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH3 struct {
	htmlElement
}

func (e *htmlH3) Body(v ...UI) HTMLH3 {
	return e.setBody(FilterUIElems(v...)).(*htmlH3)
}

func (e *htmlH3) Text(v any) HTMLH3 {
	return e.Body(Text(v))
}

func (e *htmlH3) Textf(format string, v ...any) HTMLH3 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH3) AccessKey(format string, v ...any) HTMLH3 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH3) Aria(k string, v any) HTMLH3 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH3) Attr(n string, v any) HTMLH3 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH3) Class(v ...string) HTMLH3 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH3) ContentEditable(v bool) HTMLH3 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH3) DataSet(k string, v any) HTMLH3 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH3) DataSets(ds map[string]any) HTMLH3 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH3) Dir(format string, v ...any) HTMLH3 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH3) Draggable(v bool) HTMLH3 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH3) Hidden(v bool) HTMLH3 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH3) ID(format string, v ...any) HTMLH3 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH3) Lang(format string, v ...any) HTMLH3 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH3) Role(format string, v ...any) HTMLH3 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH3) Spellcheck(v bool) HTMLH3 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH3) Style(k, format string, v ...any) HTMLH3 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH3) Styles(s map[string]string) HTMLH3 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH3) TabIndex(v int) HTMLH3 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH3) Title(format string, v ...any) HTMLH3 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH3) On(event string, h EventHandler, options ...EventOption) HTMLH3 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH3) OnBlur(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("blur", h, options...)
}

func (e *htmlH3) OnChange(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("change", h, options...)
}

func (e *htmlH3) OnClick(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("click", h, options...)
}

func (e *htmlH3) OnContextMenu(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH3) OnCopy(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("copy", h, options...)
}

func (e *htmlH3) OnCut(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("cut", h, options...)
}

func (e *htmlH3) OnDblClick(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH3) OnDrag(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("drag", h, options...)
}

func (e *htmlH3) OnDragEnd(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dragend", h, options...)
}

func (e *htmlH3) OnDragEnter(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH3) OnDragLeave(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH3) OnDragOver(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dragover", h, options...)
}

func (e *htmlH3) OnDragStart(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH3) OnDrop(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("drop", h, options...)
}

func (e *htmlH3) OnFocus(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("focus", h, options...)
}

func (e *htmlH3) OnInput(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("input", h, options...)
}

func (e *htmlH3) OnInvalid(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("invalid", h, options...)
}

func (e *htmlH3) OnKeyDown(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("keydown", h, options...)
}

func (e *htmlH3) OnKeyPress(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("keypress", h, options...)
}

func (e *htmlH3) OnKeyUp(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("keyup", h, options...)
}

func (e *htmlH3) OnMouseDown(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH3) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH3) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH3) OnMouseMove(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH3) OnMouseOut(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH3) OnMouseOver(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH3) OnMouseUp(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH3) OnPaste(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("paste", h, options...)
}

func (e *htmlH3) OnReset(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("reset", h, options...)
}

func (e *htmlH3) OnScroll(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("scroll", h, options...)
}

func (e *htmlH3) OnSearch(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("search", h, options...)
}

func (e *htmlH3) OnSelect(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("select", h, options...)
}

func (e *htmlH3) OnSubmit(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("submit", h, options...)
}

func (e *htmlH3) OnWheel(h EventHandler, options ...EventOption) HTMLH3 {
	return e.On("wheel", h, options...)
}

func (e *htmlH3) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH3) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH3) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH3) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH3) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH3) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h4" HTML element.
type HTMLH4 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH4

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH4

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH4

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH4

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH4

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH4

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH4

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH4

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH4

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH4

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH4

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH4

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH4

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH4

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH4

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH4

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH4

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH4

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH4

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH4

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH4

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH4

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH4

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH4

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH4

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH4

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH4

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH4

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH4

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH4

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH4

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH4

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH4

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH4

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH4

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH4
}

// Returns an HTML element that defines a level 4 HTML heading, indicating topics that fall under the H3 section.
func H4() HTMLH4 {
	e := &htmlH4{
		htmlElement: htmlElement{
			tag:           "h4",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH4 struct {
	htmlElement
}

func (e *htmlH4) Body(v ...UI) HTMLH4 {
	return e.setBody(FilterUIElems(v...)).(*htmlH4)
}

func (e *htmlH4) Text(v any) HTMLH4 {
	return e.Body(Text(v))
}

func (e *htmlH4) Textf(format string, v ...any) HTMLH4 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH4) AccessKey(format string, v ...any) HTMLH4 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH4) Aria(k string, v any) HTMLH4 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH4) Attr(n string, v any) HTMLH4 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH4) Class(v ...string) HTMLH4 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH4) ContentEditable(v bool) HTMLH4 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH4) DataSet(k string, v any) HTMLH4 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH4) DataSets(ds map[string]any) HTMLH4 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH4) Dir(format string, v ...any) HTMLH4 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH4) Draggable(v bool) HTMLH4 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH4) Hidden(v bool) HTMLH4 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH4) ID(format string, v ...any) HTMLH4 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH4) Lang(format string, v ...any) HTMLH4 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH4) Role(format string, v ...any) HTMLH4 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH4) Spellcheck(v bool) HTMLH4 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH4) Style(k, format string, v ...any) HTMLH4 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH4) Styles(s map[string]string) HTMLH4 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH4) TabIndex(v int) HTMLH4 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH4) Title(format string, v ...any) HTMLH4 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH4) On(event string, h EventHandler, options ...EventOption) HTMLH4 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH4) OnBlur(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("blur", h, options...)
}

func (e *htmlH4) OnChange(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("change", h, options...)
}

func (e *htmlH4) OnClick(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("click", h, options...)
}

func (e *htmlH4) OnContextMenu(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH4) OnCopy(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("copy", h, options...)
}

func (e *htmlH4) OnCut(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("cut", h, options...)
}

func (e *htmlH4) OnDblClick(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH4) OnDrag(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("drag", h, options...)
}

func (e *htmlH4) OnDragEnd(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dragend", h, options...)
}

func (e *htmlH4) OnDragEnter(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH4) OnDragLeave(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH4) OnDragOver(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dragover", h, options...)
}

func (e *htmlH4) OnDragStart(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH4) OnDrop(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("drop", h, options...)
}

func (e *htmlH4) OnFocus(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("focus", h, options...)
}

func (e *htmlH4) OnInput(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("input", h, options...)
}

func (e *htmlH4) OnInvalid(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("invalid", h, options...)
}

func (e *htmlH4) OnKeyDown(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("keydown", h, options...)
}

func (e *htmlH4) OnKeyPress(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("keypress", h, options...)
}

func (e *htmlH4) OnKeyUp(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("keyup", h, options...)
}

func (e *htmlH4) OnMouseDown(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH4) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH4) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH4) OnMouseMove(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH4) OnMouseOut(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH4) OnMouseOver(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH4) OnMouseUp(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH4) OnPaste(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("paste", h, options...)
}

func (e *htmlH4) OnReset(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("reset", h, options...)
}

func (e *htmlH4) OnScroll(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("scroll", h, options...)
}

func (e *htmlH4) OnSearch(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("search", h, options...)
}

func (e *htmlH4) OnSelect(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("select", h, options...)
}

func (e *htmlH4) OnSubmit(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("submit", h, options...)
}

func (e *htmlH4) OnWheel(h EventHandler, options ...EventOption) HTMLH4 {
	return e.On("wheel", h, options...)
}

func (e *htmlH4) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH4) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH4) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH4) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH4) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH4) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h5" HTML element.
type HTMLH5 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH5

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH5

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH5

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH5

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH5

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH5

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH5

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH5

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH5

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH5

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH5

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH5

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH5

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH5

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH5

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH5

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH5

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH5

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH5

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH5

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH5

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH5

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH5

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH5

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH5

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH5

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH5

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH5

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH5

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH5

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH5

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH5

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH5

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH5

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH5

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH5
}

// Returns an HTML element that defines a level 5 HTML heading, typically used for finer details under an H4 section.
func H5() HTMLH5 {
	e := &htmlH5{
		htmlElement: htmlElement{
			tag:           "h5",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH5 struct {
	htmlElement
}

func (e *htmlH5) Body(v ...UI) HTMLH5 {
	return e.setBody(FilterUIElems(v...)).(*htmlH5)
}

func (e *htmlH5) Text(v any) HTMLH5 {
	return e.Body(Text(v))
}

func (e *htmlH5) Textf(format string, v ...any) HTMLH5 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH5) AccessKey(format string, v ...any) HTMLH5 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH5) Aria(k string, v any) HTMLH5 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH5) Attr(n string, v any) HTMLH5 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH5) Class(v ...string) HTMLH5 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH5) ContentEditable(v bool) HTMLH5 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH5) DataSet(k string, v any) HTMLH5 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH5) DataSets(ds map[string]any) HTMLH5 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH5) Dir(format string, v ...any) HTMLH5 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH5) Draggable(v bool) HTMLH5 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH5) Hidden(v bool) HTMLH5 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH5) ID(format string, v ...any) HTMLH5 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH5) Lang(format string, v ...any) HTMLH5 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH5) Role(format string, v ...any) HTMLH5 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH5) Spellcheck(v bool) HTMLH5 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH5) Style(k, format string, v ...any) HTMLH5 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH5) Styles(s map[string]string) HTMLH5 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH5) TabIndex(v int) HTMLH5 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH5) Title(format string, v ...any) HTMLH5 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH5) On(event string, h EventHandler, options ...EventOption) HTMLH5 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH5) OnBlur(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("blur", h, options...)
}

func (e *htmlH5) OnChange(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("change", h, options...)
}

func (e *htmlH5) OnClick(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("click", h, options...)
}

func (e *htmlH5) OnContextMenu(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH5) OnCopy(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("copy", h, options...)
}

func (e *htmlH5) OnCut(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("cut", h, options...)
}

func (e *htmlH5) OnDblClick(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH5) OnDrag(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("drag", h, options...)
}

func (e *htmlH5) OnDragEnd(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dragend", h, options...)
}

func (e *htmlH5) OnDragEnter(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH5) OnDragLeave(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH5) OnDragOver(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dragover", h, options...)
}

func (e *htmlH5) OnDragStart(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH5) OnDrop(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("drop", h, options...)
}

func (e *htmlH5) OnFocus(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("focus", h, options...)
}

func (e *htmlH5) OnInput(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("input", h, options...)
}

func (e *htmlH5) OnInvalid(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("invalid", h, options...)
}

func (e *htmlH5) OnKeyDown(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("keydown", h, options...)
}

func (e *htmlH5) OnKeyPress(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("keypress", h, options...)
}

func (e *htmlH5) OnKeyUp(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("keyup", h, options...)
}

func (e *htmlH5) OnMouseDown(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH5) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH5) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH5) OnMouseMove(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH5) OnMouseOut(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH5) OnMouseOver(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH5) OnMouseUp(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH5) OnPaste(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("paste", h, options...)
}

func (e *htmlH5) OnReset(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("reset", h, options...)
}

func (e *htmlH5) OnScroll(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("scroll", h, options...)
}

func (e *htmlH5) OnSearch(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("search", h, options...)
}

func (e *htmlH5) OnSelect(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("select", h, options...)
}

func (e *htmlH5) OnSubmit(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("submit", h, options...)
}

func (e *htmlH5) OnWheel(h EventHandler, options ...EventOption) HTMLH5 {
	return e.On("wheel", h, options...)
}

func (e *htmlH5) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH5) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH5) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH5) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH5) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH5) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "h6" HTML element.
type HTMLH6 interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLH6

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLH6

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLH6

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLH6

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLH6

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLH6

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLH6

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLH6

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLH6

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLH6

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLH6

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLH6

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLH6

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLH6

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLH6

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLH6

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLH6

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLH6

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLH6

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLH6

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLH6

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLH6

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLH6

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLH6

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLH6

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLH6

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLH6

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLH6

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLH6

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLH6

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLH6

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLH6

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLH6

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLH6

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLH6

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLH6
}

// Returns an HTML element that defines a level 6 HTML heading, used for the smallest granularity of topics or details.
func H6() HTMLH6 {
	e := &htmlH6{
		htmlElement: htmlElement{
			tag:           "h6",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlH6 struct {
	htmlElement
}

func (e *htmlH6) Body(v ...UI) HTMLH6 {
	return e.setBody(FilterUIElems(v...)).(*htmlH6)
}

func (e *htmlH6) Text(v any) HTMLH6 {
	return e.Body(Text(v))
}

func (e *htmlH6) Textf(format string, v ...any) HTMLH6 {
	return e.Body(Textf(format, v...))
}

func (e *htmlH6) AccessKey(format string, v ...any) HTMLH6 {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlH6) Aria(k string, v any) HTMLH6 {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH6) Attr(n string, v any) HTMLH6 {
	e.setAttr(n, v)
	return e
}

func (e *htmlH6) Class(v ...string) HTMLH6 {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlH6) ContentEditable(v bool) HTMLH6 {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlH6) DataSet(k string, v any) HTMLH6 {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlH6) DataSets(ds map[string]any) HTMLH6 {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlH6) Dir(format string, v ...any) HTMLH6 {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlH6) Draggable(v bool) HTMLH6 {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlH6) Hidden(v bool) HTMLH6 {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlH6) ID(format string, v ...any) HTMLH6 {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlH6) Lang(format string, v ...any) HTMLH6 {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlH6) Role(format string, v ...any) HTMLH6 {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlH6) Spellcheck(v bool) HTMLH6 {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlH6) Style(k, format string, v ...any) HTMLH6 {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlH6) Styles(s map[string]string) HTMLH6 {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlH6) TabIndex(v int) HTMLH6 {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlH6) Title(format string, v ...any) HTMLH6 {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlH6) On(event string, h EventHandler, options ...EventOption) HTMLH6 {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlH6) OnBlur(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("blur", h, options...)
}

func (e *htmlH6) OnChange(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("change", h, options...)
}

func (e *htmlH6) OnClick(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("click", h, options...)
}

func (e *htmlH6) OnContextMenu(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("contextmenu", h, options...)
}

func (e *htmlH6) OnCopy(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("copy", h, options...)
}

func (e *htmlH6) OnCut(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("cut", h, options...)
}

func (e *htmlH6) OnDblClick(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dblclick", h, options...)
}

func (e *htmlH6) OnDrag(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("drag", h, options...)
}

func (e *htmlH6) OnDragEnd(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dragend", h, options...)
}

func (e *htmlH6) OnDragEnter(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dragenter", h, options...)
}

func (e *htmlH6) OnDragLeave(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dragleave", h, options...)
}

func (e *htmlH6) OnDragOver(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dragover", h, options...)
}

func (e *htmlH6) OnDragStart(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("dragstart", h, options...)
}

func (e *htmlH6) OnDrop(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("drop", h, options...)
}

func (e *htmlH6) OnFocus(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("focus", h, options...)
}

func (e *htmlH6) OnInput(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("input", h, options...)
}

func (e *htmlH6) OnInvalid(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("invalid", h, options...)
}

func (e *htmlH6) OnKeyDown(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("keydown", h, options...)
}

func (e *htmlH6) OnKeyPress(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("keypress", h, options...)
}

func (e *htmlH6) OnKeyUp(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("keyup", h, options...)
}

func (e *htmlH6) OnMouseDown(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mousedown", h, options...)
}

func (e *htmlH6) OnMouseEnter(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mouseenter", h, options...)
}

func (e *htmlH6) OnMouseLeave(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mouseleave", h, options...)
}

func (e *htmlH6) OnMouseMove(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mousemove", h, options...)
}

func (e *htmlH6) OnMouseOut(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mouseout", h, options...)
}

func (e *htmlH6) OnMouseOver(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mouseover", h, options...)
}

func (e *htmlH6) OnMouseUp(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("mouseup", h, options...)
}

func (e *htmlH6) OnPaste(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("paste", h, options...)
}

func (e *htmlH6) OnReset(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("reset", h, options...)
}

func (e *htmlH6) OnScroll(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("scroll", h, options...)
}

func (e *htmlH6) OnSearch(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("search", h, options...)
}

func (e *htmlH6) OnSelect(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("select", h, options...)
}

func (e *htmlH6) OnSubmit(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("submit", h, options...)
}

func (e *htmlH6) OnWheel(h EventHandler, options ...EventOption) HTMLH6 {
	return e.On("wheel", h, options...)
}

func (e *htmlH6) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlH6) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlH6) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlH6) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlH6) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlH6) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "head" HTML element.
type HTMLHead interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLHead

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLHead

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLHead

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLHead

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLHead

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLHead

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLHead

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLHead

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLHead

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLHead

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLHead

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLHead

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLHead

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLHead

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLHead

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLHead

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLHead

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLHead

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLHead

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLHead

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLHead

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLHead
}

// Returns an HTML element that defines information about the document.
func Head() HTMLHead {
	e := &htmlHead{
		htmlElement: htmlElement{
			tag:           "head",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlHead struct {
	htmlElement
}

func (e *htmlHead) Body(v ...UI) HTMLHead {
	return e.setBody(FilterUIElems(v...)).(*htmlHead)
}

func (e *htmlHead) Text(v any) HTMLHead {
	return e.Body(Text(v))
}

func (e *htmlHead) Textf(format string, v ...any) HTMLHead {
	return e.Body(Textf(format, v...))
}

func (e *htmlHead) AccessKey(format string, v ...any) HTMLHead {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlHead) Aria(k string, v any) HTMLHead {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHead) Attr(n string, v any) HTMLHead {
	e.setAttr(n, v)
	return e
}

func (e *htmlHead) Class(v ...string) HTMLHead {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlHead) ContentEditable(v bool) HTMLHead {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlHead) DataSet(k string, v any) HTMLHead {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHead) DataSets(ds map[string]any) HTMLHead {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlHead) Dir(format string, v ...any) HTMLHead {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlHead) Draggable(v bool) HTMLHead {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlHead) Hidden(v bool) HTMLHead {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlHead) ID(format string, v ...any) HTMLHead {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlHead) Lang(format string, v ...any) HTMLHead {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlHead) Role(format string, v ...any) HTMLHead {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlHead) Spellcheck(v bool) HTMLHead {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlHead) Style(k, format string, v ...any) HTMLHead {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlHead) Styles(s map[string]string) HTMLHead {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlHead) TabIndex(v int) HTMLHead {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlHead) Title(format string, v ...any) HTMLHead {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlHead) On(event string, h EventHandler, options ...EventOption) HTMLHead {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlHead) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlHead) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlHead) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlHead) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlHead) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlHead) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "header" HTML element.
type HTMLHeader interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLHeader

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLHeader

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLHeader

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLHeader

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLHeader

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLHeader

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLHeader

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLHeader

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLHeader

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLHeader

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLHeader

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLHeader

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLHeader

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLHeader

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLHeader

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLHeader

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLHeader

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLHeader

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLHeader

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLHeader

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLHeader

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLHeader

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLHeader

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLHeader

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLHeader

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLHeader
}

// Returns an HTML element that defines a header for a document or section.
func Header() HTMLHeader {
	e := &htmlHeader{
		htmlElement: htmlElement{
			tag:           "header",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlHeader struct {
	htmlElement
}

func (e *htmlHeader) Body(v ...UI) HTMLHeader {
	return e.setBody(FilterUIElems(v...)).(*htmlHeader)
}

func (e *htmlHeader) Text(v any) HTMLHeader {
	return e.Body(Text(v))
}

func (e *htmlHeader) Textf(format string, v ...any) HTMLHeader {
	return e.Body(Textf(format, v...))
}

func (e *htmlHeader) AccessKey(format string, v ...any) HTMLHeader {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlHeader) Aria(k string, v any) HTMLHeader {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHeader) Attr(n string, v any) HTMLHeader {
	e.setAttr(n, v)
	return e
}

func (e *htmlHeader) Class(v ...string) HTMLHeader {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlHeader) ContentEditable(v bool) HTMLHeader {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlHeader) DataSet(k string, v any) HTMLHeader {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHeader) DataSets(ds map[string]any) HTMLHeader {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlHeader) Dir(format string, v ...any) HTMLHeader {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlHeader) Draggable(v bool) HTMLHeader {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlHeader) Hidden(v bool) HTMLHeader {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlHeader) ID(format string, v ...any) HTMLHeader {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlHeader) Lang(format string, v ...any) HTMLHeader {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlHeader) Role(format string, v ...any) HTMLHeader {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlHeader) Spellcheck(v bool) HTMLHeader {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlHeader) Style(k, format string, v ...any) HTMLHeader {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlHeader) Styles(s map[string]string) HTMLHeader {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlHeader) TabIndex(v int) HTMLHeader {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlHeader) Title(format string, v ...any) HTMLHeader {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlHeader) On(event string, h EventHandler, options ...EventOption) HTMLHeader {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlHeader) OnBlur(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("blur", h, options...)
}

func (e *htmlHeader) OnChange(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("change", h, options...)
}

func (e *htmlHeader) OnClick(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("click", h, options...)
}

func (e *htmlHeader) OnContextMenu(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("contextmenu", h, options...)
}

func (e *htmlHeader) OnCopy(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("copy", h, options...)
}

func (e *htmlHeader) OnCut(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("cut", h, options...)
}

func (e *htmlHeader) OnDblClick(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dblclick", h, options...)
}

func (e *htmlHeader) OnDrag(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("drag", h, options...)
}

func (e *htmlHeader) OnDragEnd(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dragend", h, options...)
}

func (e *htmlHeader) OnDragEnter(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dragenter", h, options...)
}

func (e *htmlHeader) OnDragLeave(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dragleave", h, options...)
}

func (e *htmlHeader) OnDragOver(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dragover", h, options...)
}

func (e *htmlHeader) OnDragStart(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("dragstart", h, options...)
}

func (e *htmlHeader) OnDrop(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("drop", h, options...)
}

func (e *htmlHeader) OnFocus(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("focus", h, options...)
}

func (e *htmlHeader) OnInput(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("input", h, options...)
}

func (e *htmlHeader) OnInvalid(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("invalid", h, options...)
}

func (e *htmlHeader) OnKeyDown(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("keydown", h, options...)
}

func (e *htmlHeader) OnKeyPress(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("keypress", h, options...)
}

func (e *htmlHeader) OnKeyUp(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("keyup", h, options...)
}

func (e *htmlHeader) OnMouseDown(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mousedown", h, options...)
}

func (e *htmlHeader) OnMouseEnter(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mouseenter", h, options...)
}

func (e *htmlHeader) OnMouseLeave(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mouseleave", h, options...)
}

func (e *htmlHeader) OnMouseMove(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mousemove", h, options...)
}

func (e *htmlHeader) OnMouseOut(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mouseout", h, options...)
}

func (e *htmlHeader) OnMouseOver(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mouseover", h, options...)
}

func (e *htmlHeader) OnMouseUp(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("mouseup", h, options...)
}

func (e *htmlHeader) OnPaste(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("paste", h, options...)
}

func (e *htmlHeader) OnReset(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("reset", h, options...)
}

func (e *htmlHeader) OnScroll(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("scroll", h, options...)
}

func (e *htmlHeader) OnSearch(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("search", h, options...)
}

func (e *htmlHeader) OnSelect(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("select", h, options...)
}

func (e *htmlHeader) OnSubmit(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("submit", h, options...)
}

func (e *htmlHeader) OnWheel(h EventHandler, options ...EventOption) HTMLHeader {
	return e.On("wheel", h, options...)
}

func (e *htmlHeader) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlHeader) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlHeader) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlHeader) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlHeader) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlHeader) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "hr" HTML element.
type HTMLHr interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLHr

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLHr

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLHr

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLHr

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLHr

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLHr

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLHr

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLHr

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLHr

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLHr

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLHr

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLHr

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLHr

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLHr

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLHr

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLHr

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLHr

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLHr

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLHr

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLHr

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLHr

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLHr

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLHr

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLHr

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLHr

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLHr

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLHr

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLHr

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLHr

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLHr

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLHr

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLHr

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLHr
}

// Returns an HTML element that defines a thematic change in the content.
func Hr() HTMLHr {
	e := &htmlHr{
		htmlElement: htmlElement{
			tag:           "hr",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlHr struct {
	htmlElement
}

func (e *htmlHr) AccessKey(format string, v ...any) HTMLHr {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlHr) Aria(k string, v any) HTMLHr {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHr) Attr(n string, v any) HTMLHr {
	e.setAttr(n, v)
	return e
}

func (e *htmlHr) Class(v ...string) HTMLHr {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlHr) ContentEditable(v bool) HTMLHr {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlHr) DataSet(k string, v any) HTMLHr {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHr) DataSets(ds map[string]any) HTMLHr {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlHr) Dir(format string, v ...any) HTMLHr {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlHr) Draggable(v bool) HTMLHr {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlHr) Hidden(v bool) HTMLHr {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlHr) ID(format string, v ...any) HTMLHr {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlHr) Lang(format string, v ...any) HTMLHr {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlHr) Role(format string, v ...any) HTMLHr {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlHr) Spellcheck(v bool) HTMLHr {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlHr) Style(k, format string, v ...any) HTMLHr {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlHr) Styles(s map[string]string) HTMLHr {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlHr) TabIndex(v int) HTMLHr {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlHr) Title(format string, v ...any) HTMLHr {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlHr) On(event string, h EventHandler, options ...EventOption) HTMLHr {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlHr) OnBlur(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("blur", h, options...)
}

func (e *htmlHr) OnChange(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("change", h, options...)
}

func (e *htmlHr) OnClick(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("click", h, options...)
}

func (e *htmlHr) OnContextMenu(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("contextmenu", h, options...)
}

func (e *htmlHr) OnCopy(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("copy", h, options...)
}

func (e *htmlHr) OnCut(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("cut", h, options...)
}

func (e *htmlHr) OnDblClick(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dblclick", h, options...)
}

func (e *htmlHr) OnDrag(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("drag", h, options...)
}

func (e *htmlHr) OnDragEnd(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dragend", h, options...)
}

func (e *htmlHr) OnDragEnter(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dragenter", h, options...)
}

func (e *htmlHr) OnDragLeave(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dragleave", h, options...)
}

func (e *htmlHr) OnDragOver(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dragover", h, options...)
}

func (e *htmlHr) OnDragStart(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("dragstart", h, options...)
}

func (e *htmlHr) OnDrop(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("drop", h, options...)
}

func (e *htmlHr) OnFocus(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("focus", h, options...)
}

func (e *htmlHr) OnInput(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("input", h, options...)
}

func (e *htmlHr) OnInvalid(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("invalid", h, options...)
}

func (e *htmlHr) OnKeyDown(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("keydown", h, options...)
}

func (e *htmlHr) OnKeyPress(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("keypress", h, options...)
}

func (e *htmlHr) OnKeyUp(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("keyup", h, options...)
}

func (e *htmlHr) OnMouseDown(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mousedown", h, options...)
}

func (e *htmlHr) OnMouseEnter(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mouseenter", h, options...)
}

func (e *htmlHr) OnMouseLeave(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mouseleave", h, options...)
}

func (e *htmlHr) OnMouseMove(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mousemove", h, options...)
}

func (e *htmlHr) OnMouseOut(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mouseout", h, options...)
}

func (e *htmlHr) OnMouseOver(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mouseover", h, options...)
}

func (e *htmlHr) OnMouseUp(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("mouseup", h, options...)
}

func (e *htmlHr) OnPaste(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("paste", h, options...)
}

func (e *htmlHr) OnReset(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("reset", h, options...)
}

func (e *htmlHr) OnScroll(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("scroll", h, options...)
}

func (e *htmlHr) OnSearch(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("search", h, options...)
}

func (e *htmlHr) OnSelect(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("select", h, options...)
}

func (e *htmlHr) OnSubmit(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("submit", h, options...)
}

func (e *htmlHr) OnWheel(h EventHandler, options ...EventOption) HTMLHr {
	return e.On("wheel", h, options...)
}

func (e *htmlHr) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlHr) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlHr) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlHr) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlHr) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlHr) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "html" HTML element.
type HTMLHtml interface {
	HTML

	privateBody(elems ...UI) HTMLHtml

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLHtml

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLHtml

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLHtml

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLHtml

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLHtml

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLHtml

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLHtml

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLHtml

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLHtml

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLHtml

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLHtml

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLHtml

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLHtml

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLHtml

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLHtml

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLHtml

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLHtml

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLHtml

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLHtml
}

// Returns an HTML element that defines the root of an HTML document.
func Html() HTMLHtml {
	e := &htmlHtml{
		htmlElement: htmlElement{
			tag:           "html",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlHtml struct {
	htmlElement
}

func (e *htmlHtml) privateBody(v ...UI) HTMLHtml {
	return e.setBody(FilterUIElems(v...)).(*htmlHtml)
}

func (e *htmlHtml) AccessKey(format string, v ...any) HTMLHtml {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlHtml) Aria(k string, v any) HTMLHtml {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHtml) Attr(n string, v any) HTMLHtml {
	e.setAttr(n, v)
	return e
}

func (e *htmlHtml) Class(v ...string) HTMLHtml {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlHtml) ContentEditable(v bool) HTMLHtml {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlHtml) DataSet(k string, v any) HTMLHtml {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlHtml) DataSets(ds map[string]any) HTMLHtml {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlHtml) Dir(format string, v ...any) HTMLHtml {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlHtml) Draggable(v bool) HTMLHtml {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlHtml) Hidden(v bool) HTMLHtml {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlHtml) ID(format string, v ...any) HTMLHtml {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlHtml) Lang(format string, v ...any) HTMLHtml {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlHtml) Role(format string, v ...any) HTMLHtml {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlHtml) Spellcheck(v bool) HTMLHtml {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlHtml) Style(k, format string, v ...any) HTMLHtml {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlHtml) Styles(s map[string]string) HTMLHtml {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlHtml) TabIndex(v int) HTMLHtml {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlHtml) Title(format string, v ...any) HTMLHtml {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlHtml) On(event string, h EventHandler, options ...EventOption) HTMLHtml {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlHtml) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlHtml) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlHtml) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlHtml) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlHtml) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlHtml) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "i" HTML element.
type HTMLI interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLI

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLI

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLI

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLI

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLI

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLI

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLI

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLI

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLI

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLI

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLI

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLI

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLI

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLI

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLI

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLI

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLI

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLI

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLI

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLI

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLI

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLI

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLI

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLI

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLI

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLI

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLI

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLI

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLI

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLI

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLI

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLI

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLI

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLI

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLI

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLI

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLI

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLI

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLI

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLI

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLI

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLI

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLI

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLI

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLI

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLI

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLI

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLI

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLI

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLI
}

// Returns an HTML element that defines a part of text in an alternate voice or mood.
func I() HTMLI {
	e := &htmlI{
		htmlElement: htmlElement{
			tag:           "i",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlI struct {
	htmlElement
}

func (e *htmlI) Body(v ...UI) HTMLI {
	return e.setBody(FilterUIElems(v...)).(*htmlI)
}

func (e *htmlI) Text(v any) HTMLI {
	return e.Body(Text(v))
}

func (e *htmlI) Textf(format string, v ...any) HTMLI {
	return e.Body(Textf(format, v...))
}

func (e *htmlI) AccessKey(format string, v ...any) HTMLI {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlI) Aria(k string, v any) HTMLI {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlI) Attr(n string, v any) HTMLI {
	e.setAttr(n, v)
	return e
}

func (e *htmlI) Class(v ...string) HTMLI {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlI) ContentEditable(v bool) HTMLI {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlI) DataSet(k string, v any) HTMLI {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlI) DataSets(ds map[string]any) HTMLI {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlI) Dir(format string, v ...any) HTMLI {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlI) Draggable(v bool) HTMLI {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlI) Hidden(v bool) HTMLI {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlI) ID(format string, v ...any) HTMLI {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlI) Lang(format string, v ...any) HTMLI {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlI) Role(format string, v ...any) HTMLI {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlI) Spellcheck(v bool) HTMLI {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlI) Style(k, format string, v ...any) HTMLI {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlI) Styles(s map[string]string) HTMLI {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlI) TabIndex(v int) HTMLI {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlI) Title(format string, v ...any) HTMLI {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlI) On(event string, h EventHandler, options ...EventOption) HTMLI {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlI) OnBlur(h EventHandler, options ...EventOption) HTMLI {
	return e.On("blur", h, options...)
}

func (e *htmlI) OnChange(h EventHandler, options ...EventOption) HTMLI {
	return e.On("change", h, options...)
}

func (e *htmlI) OnClick(h EventHandler, options ...EventOption) HTMLI {
	return e.On("click", h, options...)
}

func (e *htmlI) OnContextMenu(h EventHandler, options ...EventOption) HTMLI {
	return e.On("contextmenu", h, options...)
}

func (e *htmlI) OnCopy(h EventHandler, options ...EventOption) HTMLI {
	return e.On("copy", h, options...)
}

func (e *htmlI) OnCut(h EventHandler, options ...EventOption) HTMLI {
	return e.On("cut", h, options...)
}

func (e *htmlI) OnDblClick(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dblclick", h, options...)
}

func (e *htmlI) OnDrag(h EventHandler, options ...EventOption) HTMLI {
	return e.On("drag", h, options...)
}

func (e *htmlI) OnDragEnd(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dragend", h, options...)
}

func (e *htmlI) OnDragEnter(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dragenter", h, options...)
}

func (e *htmlI) OnDragLeave(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dragleave", h, options...)
}

func (e *htmlI) OnDragOver(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dragover", h, options...)
}

func (e *htmlI) OnDragStart(h EventHandler, options ...EventOption) HTMLI {
	return e.On("dragstart", h, options...)
}

func (e *htmlI) OnDrop(h EventHandler, options ...EventOption) HTMLI {
	return e.On("drop", h, options...)
}

func (e *htmlI) OnFocus(h EventHandler, options ...EventOption) HTMLI {
	return e.On("focus", h, options...)
}

func (e *htmlI) OnInput(h EventHandler, options ...EventOption) HTMLI {
	return e.On("input", h, options...)
}

func (e *htmlI) OnInvalid(h EventHandler, options ...EventOption) HTMLI {
	return e.On("invalid", h, options...)
}

func (e *htmlI) OnKeyDown(h EventHandler, options ...EventOption) HTMLI {
	return e.On("keydown", h, options...)
}

func (e *htmlI) OnKeyPress(h EventHandler, options ...EventOption) HTMLI {
	return e.On("keypress", h, options...)
}

func (e *htmlI) OnKeyUp(h EventHandler, options ...EventOption) HTMLI {
	return e.On("keyup", h, options...)
}

func (e *htmlI) OnMouseDown(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mousedown", h, options...)
}

func (e *htmlI) OnMouseEnter(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mouseenter", h, options...)
}

func (e *htmlI) OnMouseLeave(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mouseleave", h, options...)
}

func (e *htmlI) OnMouseMove(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mousemove", h, options...)
}

func (e *htmlI) OnMouseOut(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mouseout", h, options...)
}

func (e *htmlI) OnMouseOver(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mouseover", h, options...)
}

func (e *htmlI) OnMouseUp(h EventHandler, options ...EventOption) HTMLI {
	return e.On("mouseup", h, options...)
}

func (e *htmlI) OnPaste(h EventHandler, options ...EventOption) HTMLI {
	return e.On("paste", h, options...)
}

func (e *htmlI) OnReset(h EventHandler, options ...EventOption) HTMLI {
	return e.On("reset", h, options...)
}

func (e *htmlI) OnScroll(h EventHandler, options ...EventOption) HTMLI {
	return e.On("scroll", h, options...)
}

func (e *htmlI) OnSearch(h EventHandler, options ...EventOption) HTMLI {
	return e.On("search", h, options...)
}

func (e *htmlI) OnSelect(h EventHandler, options ...EventOption) HTMLI {
	return e.On("select", h, options...)
}

func (e *htmlI) OnSubmit(h EventHandler, options ...EventOption) HTMLI {
	return e.On("submit", h, options...)
}

func (e *htmlI) OnWheel(h EventHandler, options ...EventOption) HTMLI {
	return e.On("wheel", h, options...)
}

func (e *htmlI) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlI) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlI) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlI) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlI) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlI) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "iframe" HTML element.
type HTMLIFrame interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLIFrame

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLIFrame

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLIFrame

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLIFrame

	// Sets a feature policy, enhancing security by controlling certain browser features. Allows multiple policies.
	Allow(format string, v ...any) HTMLIFrame

	// Grants an iframe the capability to request fullscreen mode.
	AllowFullscreen(v bool) HTMLIFrame

	// Grants an iframe the permission to use the Payment Request API for smoother online transactions.
	AllowPaymentRequest(v bool) HTMLIFrame

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLIFrame

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLIFrame

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLIFrame

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLIFrame

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLIFrame

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLIFrame

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLIFrame

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLIFrame

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLIFrame

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLIFrame

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLIFrame

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLIFrame

	// Determines the browser's loading behavior ('eager' or 'lazy').
	Loading(format string, v ...any) HTMLIFrame

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLIFrame

	// Determines the amount of referrer information sent when processing iframe attributes.
	ReferrerPolicy(format string, v ...any) HTMLIFrame

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLIFrame

	// Applies extra security restrictions to content within an iframe.
	Sandbox(format string, v ...any) HTMLIFrame

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLIFrame

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLIFrame

	// Defines the HTML content to be displayed within an iframe. Uses the given format and values.
	SrcDoc(format string, v ...any) HTMLIFrame

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLIFrame

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLIFrame

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLIFrame

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLIFrame

	// Sets the width of the element.
	Width(v int) HTMLIFrame

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLIFrame

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLIFrame

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLIFrame

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLIFrame
}

// Returns an HTML element that defines an inline frame.
func IFrame() HTMLIFrame {
	e := &htmlIFrame{
		htmlElement: htmlElement{
			tag:           "iframe",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlIFrame struct {
	htmlElement
}

func (e *htmlIFrame) Body(v ...UI) HTMLIFrame {
	return e.setBody(FilterUIElems(v...)).(*htmlIFrame)
}

func (e *htmlIFrame) Text(v any) HTMLIFrame {
	return e.Body(Text(v))
}

func (e *htmlIFrame) Textf(format string, v ...any) HTMLIFrame {
	return e.Body(Textf(format, v...))
}

func (e *htmlIFrame) AccessKey(format string, v ...any) HTMLIFrame {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Allow(format string, v ...any) HTMLIFrame {
	e.setAttr("allow", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) AllowFullscreen(v bool) HTMLIFrame {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("allowfullscreen", s)
	return e
}

func (e *htmlIFrame) AllowPaymentRequest(v bool) HTMLIFrame {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("allowpaymentrequest", s)
	return e
}

func (e *htmlIFrame) Aria(k string, v any) HTMLIFrame {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlIFrame) Attr(n string, v any) HTMLIFrame {
	e.setAttr(n, v)
	return e
}

func (e *htmlIFrame) Class(v ...string) HTMLIFrame {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlIFrame) ContentEditable(v bool) HTMLIFrame {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlIFrame) DataSet(k string, v any) HTMLIFrame {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlIFrame) DataSets(ds map[string]any) HTMLIFrame {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlIFrame) Dir(format string, v ...any) HTMLIFrame {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Draggable(v bool) HTMLIFrame {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlIFrame) Height(v int) HTMLIFrame {
	e.setAttr("height", v)
	return e
}

func (e *htmlIFrame) Hidden(v bool) HTMLIFrame {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlIFrame) ID(format string, v ...any) HTMLIFrame {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Lang(format string, v ...any) HTMLIFrame {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Loading(format string, v ...any) HTMLIFrame {
	e.setAttr("loading", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Name(format string, v ...any) HTMLIFrame {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) ReferrerPolicy(format string, v ...any) HTMLIFrame {
	e.setAttr("referrerpolicy", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Role(format string, v ...any) HTMLIFrame {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Sandbox(format string, v ...any) HTMLIFrame {
	e.setAttr("sandbox", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Spellcheck(v bool) HTMLIFrame {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlIFrame) Src(format string, v ...any) HTMLIFrame {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) SrcDoc(format string, v ...any) HTMLIFrame {
	e.setAttr("srcdoc", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Style(k, format string, v ...any) HTMLIFrame {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Styles(s map[string]string) HTMLIFrame {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlIFrame) TabIndex(v int) HTMLIFrame {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlIFrame) Title(format string, v ...any) HTMLIFrame {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlIFrame) Width(v int) HTMLIFrame {
	e.setAttr("width", v)
	return e
}

func (e *htmlIFrame) On(event string, h EventHandler, options ...EventOption) HTMLIFrame {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlIFrame) OnBlur(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("blur", h, options...)
}

func (e *htmlIFrame) OnChange(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("change", h, options...)
}

func (e *htmlIFrame) OnClick(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("click", h, options...)
}

func (e *htmlIFrame) OnContextMenu(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("contextmenu", h, options...)
}

func (e *htmlIFrame) OnCopy(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("copy", h, options...)
}

func (e *htmlIFrame) OnCut(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("cut", h, options...)
}

func (e *htmlIFrame) OnDblClick(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dblclick", h, options...)
}

func (e *htmlIFrame) OnDrag(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("drag", h, options...)
}

func (e *htmlIFrame) OnDragEnd(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dragend", h, options...)
}

func (e *htmlIFrame) OnDragEnter(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dragenter", h, options...)
}

func (e *htmlIFrame) OnDragLeave(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dragleave", h, options...)
}

func (e *htmlIFrame) OnDragOver(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dragover", h, options...)
}

func (e *htmlIFrame) OnDragStart(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("dragstart", h, options...)
}

func (e *htmlIFrame) OnDrop(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("drop", h, options...)
}

func (e *htmlIFrame) OnFocus(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("focus", h, options...)
}

func (e *htmlIFrame) OnInput(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("input", h, options...)
}

func (e *htmlIFrame) OnInvalid(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("invalid", h, options...)
}

func (e *htmlIFrame) OnKeyDown(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("keydown", h, options...)
}

func (e *htmlIFrame) OnKeyPress(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("keypress", h, options...)
}

func (e *htmlIFrame) OnKeyUp(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("keyup", h, options...)
}

func (e *htmlIFrame) OnLoad(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("load", h, options...)
}

func (e *htmlIFrame) OnMouseDown(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mousedown", h, options...)
}

func (e *htmlIFrame) OnMouseEnter(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mouseenter", h, options...)
}

func (e *htmlIFrame) OnMouseLeave(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mouseleave", h, options...)
}

func (e *htmlIFrame) OnMouseMove(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mousemove", h, options...)
}

func (e *htmlIFrame) OnMouseOut(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mouseout", h, options...)
}

func (e *htmlIFrame) OnMouseOver(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mouseover", h, options...)
}

func (e *htmlIFrame) OnMouseUp(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("mouseup", h, options...)
}

func (e *htmlIFrame) OnPaste(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("paste", h, options...)
}

func (e *htmlIFrame) OnReset(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("reset", h, options...)
}

func (e *htmlIFrame) OnScroll(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("scroll", h, options...)
}

func (e *htmlIFrame) OnSearch(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("search", h, options...)
}

func (e *htmlIFrame) OnSelect(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("select", h, options...)
}

func (e *htmlIFrame) OnSubmit(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("submit", h, options...)
}

func (e *htmlIFrame) OnWheel(h EventHandler, options ...EventOption) HTMLIFrame {
	return e.On("wheel", h, options...)
}

func (e *htmlIFrame) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlIFrame) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlIFrame) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlIFrame) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlIFrame) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlIFrame) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "img" HTML element.
type HTMLImg interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLImg

	// Provides a text alternative for elements (often images) ensuring content is accessible when visuals can't be rendered.
	Alt(format string, v ...any) HTMLImg

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLImg

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLImg

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLImg

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLImg

	// Controls how cross-origin requests are managed for the element, supporting secure content integration from different origins.
	CrossOrigin(format string, v ...any) HTMLImg

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLImg

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLImg

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLImg

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLImg

	// Provides a hint to the browser about how it should prioritize the fetch of the image in relation to other images.
	FetchPriority(format string, v ...any) HTMLImg

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLImg

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLImg

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLImg

	// Marks an image as a server-side image-map.
	IsMap(v bool) HTMLImg

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLImg

	// Determines the browser's loading behavior ('eager' or 'lazy').
	Loading(format string, v ...any) HTMLImg

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLImg

	// Specifies sizes of icons and images for different page or screen scenarios. Uses the given format and values.
	Sizes(format string, v ...any) HTMLImg

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLImg

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLImg

	// Provides URLs of images to display in varied resolutions or viewport conditions. Uses the given format and values.
	SrcSet(format string, v ...any) HTMLImg

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLImg

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLImg

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLImg

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLImg

	// Associates the element with a client-side image map. Can be called with the designated format and values.
	UseMap(format string, v ...any) HTMLImg

	// Sets the width of the element.
	Width(v int) HTMLImg

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when media loading is aborted.
	OnAbort(h EventHandler, options ...EventOption) HTMLImg

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler when media has buffered sufficiently to begin playback.
	OnCanPlay(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when media can be played through without buffering interruptions.
	OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler upon cue changes within a track element.
	OnCueChange(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLImg

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler when the media's duration changes.
	OnDurationChange(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when media unexpectedly becomes unavailable.
	OnEmptied(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when media playback reaches the end.
	OnEnded(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLImg

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLImg

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLImg

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when media loading commences.
	OnLoadStart(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler as media data finishes loading.
	OnLoadedData(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when metadata (like duration and dimensions) are fully loaded.
	OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLImg

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLImg

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler when media playback is paused.
	OnPause(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when media starts its playback.
	OnPlay(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler once the media has initiated playback.
	OnPlaying(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler while the browser fetches media data.
	OnProgress(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when playback rate changes (e.g., slow motion or fast forward).
	OnRateChange(h EventHandler, options ...EventOption) HTMLImg

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler post seeking completion.
	OnSeeked(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler during the seeking process.
	OnSeeking(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler when media data fetching stalls.
	OnStalled(h EventHandler, options ...EventOption) HTMLImg

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when media data fetching is suspended.
	OnSuspend(h EventHandler, options ...EventOption) HTMLImg

	// Executes the handler when the media's playback position changes.
	OnTimeUpdate(h EventHandler, options ...EventOption) HTMLImg

	// Invokes the handler upon volume changes or muting.
	OnVolumeChange(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the handler when media pauses, awaiting further buffering.
	OnWaiting(h EventHandler, options ...EventOption) HTMLImg

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLImg
}

// Returns an HTML element that defines an image.
func Img() HTMLImg {
	e := &htmlImg{
		htmlElement: htmlElement{
			tag:           "img",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlImg struct {
	htmlElement
}

func (e *htmlImg) AccessKey(format string, v ...any) HTMLImg {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlImg) Alt(format string, v ...any) HTMLImg {
	e.setAttr("alt", FormatString(format, v...))
	return e
}

func (e *htmlImg) Aria(k string, v any) HTMLImg {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlImg) Attr(n string, v any) HTMLImg {
	e.setAttr(n, v)
	return e
}

func (e *htmlImg) Class(v ...string) HTMLImg {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlImg) ContentEditable(v bool) HTMLImg {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlImg) CrossOrigin(format string, v ...any) HTMLImg {
	e.setAttr("crossorigin", FormatString(format, v...))
	return e
}

func (e *htmlImg) DataSet(k string, v any) HTMLImg {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlImg) DataSets(ds map[string]any) HTMLImg {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlImg) Dir(format string, v ...any) HTMLImg {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlImg) Draggable(v bool) HTMLImg {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlImg) FetchPriority(format string, v ...any) HTMLImg {
	e.setAttr("fetchpriority", FormatString(format, v...))
	return e
}

func (e *htmlImg) Height(v int) HTMLImg {
	e.setAttr("height", v)
	return e
}

func (e *htmlImg) Hidden(v bool) HTMLImg {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlImg) ID(format string, v ...any) HTMLImg {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlImg) IsMap(v bool) HTMLImg {
	e.setAttr("ismap", v)
	return e
}

func (e *htmlImg) Lang(format string, v ...any) HTMLImg {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlImg) Loading(format string, v ...any) HTMLImg {
	e.setAttr("loading", FormatString(format, v...))
	return e
}

func (e *htmlImg) Role(format string, v ...any) HTMLImg {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlImg) Sizes(format string, v ...any) HTMLImg {
	e.setAttr("sizes", FormatString(format, v...))
	return e
}

func (e *htmlImg) Spellcheck(v bool) HTMLImg {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlImg) Src(format string, v ...any) HTMLImg {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlImg) SrcSet(format string, v ...any) HTMLImg {
	e.setAttr("srcset", FormatString(format, v...))
	return e
}

func (e *htmlImg) Style(k, format string, v ...any) HTMLImg {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlImg) Styles(s map[string]string) HTMLImg {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlImg) TabIndex(v int) HTMLImg {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlImg) Title(format string, v ...any) HTMLImg {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlImg) UseMap(format string, v ...any) HTMLImg {
	e.setAttr("usemap", FormatString(format, v...))
	return e
}

func (e *htmlImg) Width(v int) HTMLImg {
	e.setAttr("width", v)
	return e
}

func (e *htmlImg) On(event string, h EventHandler, options ...EventOption) HTMLImg {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlImg) OnAbort(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("abort", h, options...)
}

func (e *htmlImg) OnBlur(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("blur", h, options...)
}

func (e *htmlImg) OnCanPlay(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("canplay", h, options...)
}

func (e *htmlImg) OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("canplaythrough", h, options...)
}

func (e *htmlImg) OnChange(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("change", h, options...)
}

func (e *htmlImg) OnClick(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("click", h, options...)
}

func (e *htmlImg) OnContextMenu(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("contextmenu", h, options...)
}

func (e *htmlImg) OnCopy(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("copy", h, options...)
}

func (e *htmlImg) OnCueChange(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("cuechange", h, options...)
}

func (e *htmlImg) OnCut(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("cut", h, options...)
}

func (e *htmlImg) OnDblClick(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dblclick", h, options...)
}

func (e *htmlImg) OnDrag(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("drag", h, options...)
}

func (e *htmlImg) OnDragEnd(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dragend", h, options...)
}

func (e *htmlImg) OnDragEnter(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dragenter", h, options...)
}

func (e *htmlImg) OnDragLeave(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dragleave", h, options...)
}

func (e *htmlImg) OnDragOver(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dragover", h, options...)
}

func (e *htmlImg) OnDragStart(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("dragstart", h, options...)
}

func (e *htmlImg) OnDrop(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("drop", h, options...)
}

func (e *htmlImg) OnDurationChange(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("durationchange", h, options...)
}

func (e *htmlImg) OnEmptied(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("emptied", h, options...)
}

func (e *htmlImg) OnEnded(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("ended", h, options...)
}

func (e *htmlImg) OnError(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("error", h, options...)
}

func (e *htmlImg) OnFocus(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("focus", h, options...)
}

func (e *htmlImg) OnInput(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("input", h, options...)
}

func (e *htmlImg) OnInvalid(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("invalid", h, options...)
}

func (e *htmlImg) OnKeyDown(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("keydown", h, options...)
}

func (e *htmlImg) OnKeyPress(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("keypress", h, options...)
}

func (e *htmlImg) OnKeyUp(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("keyup", h, options...)
}

func (e *htmlImg) OnLoad(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("load", h, options...)
}

func (e *htmlImg) OnLoadStart(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("loadstart", h, options...)
}

func (e *htmlImg) OnLoadedData(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("loadeddata", h, options...)
}

func (e *htmlImg) OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("loadedmetadata", h, options...)
}

func (e *htmlImg) OnMouseDown(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mousedown", h, options...)
}

func (e *htmlImg) OnMouseEnter(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mouseenter", h, options...)
}

func (e *htmlImg) OnMouseLeave(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mouseleave", h, options...)
}

func (e *htmlImg) OnMouseMove(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mousemove", h, options...)
}

func (e *htmlImg) OnMouseOut(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mouseout", h, options...)
}

func (e *htmlImg) OnMouseOver(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mouseover", h, options...)
}

func (e *htmlImg) OnMouseUp(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("mouseup", h, options...)
}

func (e *htmlImg) OnPaste(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("paste", h, options...)
}

func (e *htmlImg) OnPause(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("pause", h, options...)
}

func (e *htmlImg) OnPlay(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("play", h, options...)
}

func (e *htmlImg) OnPlaying(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("playing", h, options...)
}

func (e *htmlImg) OnProgress(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("progress", h, options...)
}

func (e *htmlImg) OnRateChange(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("ratechange", h, options...)
}

func (e *htmlImg) OnReset(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("reset", h, options...)
}

func (e *htmlImg) OnScroll(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("scroll", h, options...)
}

func (e *htmlImg) OnSearch(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("search", h, options...)
}

func (e *htmlImg) OnSeeked(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("seeked", h, options...)
}

func (e *htmlImg) OnSeeking(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("seeking", h, options...)
}

func (e *htmlImg) OnSelect(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("select", h, options...)
}

func (e *htmlImg) OnStalled(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("stalled", h, options...)
}

func (e *htmlImg) OnSubmit(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("submit", h, options...)
}

func (e *htmlImg) OnSuspend(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("suspend", h, options...)
}

func (e *htmlImg) OnTimeUpdate(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("timeupdate", h, options...)
}

func (e *htmlImg) OnVolumeChange(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("volumechange", h, options...)
}

func (e *htmlImg) OnWaiting(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("waiting", h, options...)
}

func (e *htmlImg) OnWheel(h EventHandler, options ...EventOption) HTMLImg {
	return e.On("wheel", h, options...)
}

func (e *htmlImg) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlImg) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlImg) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlImg) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlImg) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlImg) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "input" HTML element.
type HTMLInput interface {
	HTML

	// Restricts file types the server accepts, especially used for file input elements.
	Accept(format string, v ...any) HTMLInput

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLInput

	// Provides a text alternative for elements (often images) ensuring content is accessible when visuals can't be rendered.
	Alt(format string, v ...any) HTMLInput

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLInput

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLInput

	// Toggles the browser's autocomplete feature, assisting users with common input values.
	AutoComplete(v bool) HTMLInput

	// Instructs the browser to focus this element automatically when the page loads.
	AutoFocus(v bool) HTMLInput

	// Directs how media capture for file uploads should be handled, such as using the device's camera or microphone.
	Capture(format string, v ...any) HTMLInput

	// Indicates that an input element (checkbox or radio) should start in a selected state upon page load.
	Checked(v bool) HTMLInput

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLInput

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLInput

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLInput

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLInput

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLInput

	// Instructs the browser to also submit the text direction of a form field when the form is submitted.
	DirName(format string, v ...any) HTMLInput

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLInput

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLInput

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLInput

	// Defines the URL to which form data should be sent upon submission. Applicable only to 'submit' type inputs.
	FormAction(format string, v ...any) HTMLInput

	// Dictates the encoding method for form data prior to its submission to a server. Applicable only to 'submit' type inputs.
	FormEncType(format string, v ...any) HTMLInput

	// Determines the HTTP method for sending form data. Applicable only to 'submit' type inputs.
	FormMethod(format string, v ...any) HTMLInput

	// Indicates that the form data should bypass validation upon submission. Applicable only to 'submit' type inputs.
	FormNoValidate(v bool) HTMLInput

	// Specifies where the server's response will be displayed after form submission. Applicable only to 'submit' type inputs.
	FormTarget(format string, v ...any) HTMLInput

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLInput

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLInput

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLInput

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLInput

	// Links to a datalist element offering predefined options for an input element.
	List(format string, v ...any) HTMLInput

	// Establishes the maximum permissible value.
	Max(v any) HTMLInput

	// Defines the maximum number of characters permissible in an element.
	MaxLength(v int) HTMLInput

	// Establishes the minimum permissible value.
	Min(v any) HTMLInput

	// Allows users to input multiple values.
	Multiple(v bool) HTMLInput

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLInput

	// Establishes a regular expression against which an input element's value is validated.
	Pattern(format string, v ...any) HTMLInput

	// Provides a brief hint describing the expected value of the element.
	Placeholder(format string, v ...any) HTMLInput

	// Indicates that the element's value cannot be edited by the user.
	ReadOnly(v bool) HTMLInput

	// Indicates that the element must contain a value before form submission.
	Required(v bool) HTMLInput

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLInput

	// Indicates the width of the element, usually in characters for input elements.
	Size(v int) HTMLInput

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLInput

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLInput

	// Specifies the interval between permissible values for an input field.
	Step(v float64) HTMLInput

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLInput

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLInput

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLInput

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLInput

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLInput

	// Assigns a value to the element.
	Value(v any) HTMLInput

	// Sets the width of the element.
	Width(v int) HTMLInput

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLInput

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLInput

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLInput

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLInput

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLInput

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLInput

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLInput

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLInput

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLInput

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLInput

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLInput

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLInput

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLInput

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLInput

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLInput

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLInput
}

// Returns an HTML element that defines an input control.
func Input() HTMLInput {
	e := &htmlInput{
		htmlElement: htmlElement{
			tag:           "input",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlInput struct {
	htmlElement
}

func (e *htmlInput) Accept(format string, v ...any) HTMLInput {
	e.setAttr("accept", FormatString(format, v...))
	return e
}

func (e *htmlInput) AccessKey(format string, v ...any) HTMLInput {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlInput) Alt(format string, v ...any) HTMLInput {
	e.setAttr("alt", FormatString(format, v...))
	return e
}

func (e *htmlInput) Aria(k string, v any) HTMLInput {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlInput) Attr(n string, v any) HTMLInput {
	e.setAttr(n, v)
	return e
}

func (e *htmlInput) AutoComplete(v bool) HTMLInput {
	s := "off"
	if v {
		s = "on"
	}

	e.setAttr("autocomplete", s)
	return e
}

func (e *htmlInput) AutoFocus(v bool) HTMLInput {
	e.setAttr("autofocus", v)
	return e
}

func (e *htmlInput) Capture(format string, v ...any) HTMLInput {
	e.setAttr("capture", FormatString(format, v...))
	return e
}

func (e *htmlInput) Checked(v bool) HTMLInput {
	e.setAttr("checked", v)
	return e
}

func (e *htmlInput) Class(v ...string) HTMLInput {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlInput) ContentEditable(v bool) HTMLInput {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlInput) DataSet(k string, v any) HTMLInput {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlInput) DataSets(ds map[string]any) HTMLInput {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlInput) Dir(format string, v ...any) HTMLInput {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlInput) DirName(format string, v ...any) HTMLInput {
	e.setAttr("dirname", FormatString(format, v...))
	return e
}

func (e *htmlInput) Disabled(v bool) HTMLInput {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlInput) Draggable(v bool) HTMLInput {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlInput) Form(format string, v ...any) HTMLInput {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlInput) FormAction(format string, v ...any) HTMLInput {
	e.setAttr("formaction", FormatString(format, v...))
	return e
}

func (e *htmlInput) FormEncType(format string, v ...any) HTMLInput {
	e.setAttr("formenctype", FormatString(format, v...))
	return e
}

func (e *htmlInput) FormMethod(format string, v ...any) HTMLInput {
	e.setAttr("formmethod", FormatString(format, v...))
	return e
}

func (e *htmlInput) FormNoValidate(v bool) HTMLInput {
	e.setAttr("formnovalidate", v)
	return e
}

func (e *htmlInput) FormTarget(format string, v ...any) HTMLInput {
	e.setAttr("formtarget", FormatString(format, v...))
	return e
}

func (e *htmlInput) Height(v int) HTMLInput {
	e.setAttr("height", v)
	return e
}

func (e *htmlInput) Hidden(v bool) HTMLInput {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlInput) ID(format string, v ...any) HTMLInput {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlInput) Lang(format string, v ...any) HTMLInput {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlInput) List(format string, v ...any) HTMLInput {
	e.setAttr("list", FormatString(format, v...))
	return e
}

func (e *htmlInput) Max(v any) HTMLInput {
	e.setAttr("max", v)
	return e
}

func (e *htmlInput) MaxLength(v int) HTMLInput {
	e.setAttr("maxlength", v)
	return e
}

func (e *htmlInput) Min(v any) HTMLInput {
	e.setAttr("min", v)
	return e
}

func (e *htmlInput) Multiple(v bool) HTMLInput {
	e.setAttr("multiple", v)
	return e
}

func (e *htmlInput) Name(format string, v ...any) HTMLInput {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlInput) Pattern(format string, v ...any) HTMLInput {
	e.setAttr("pattern", FormatString(format, v...))
	return e
}

func (e *htmlInput) Placeholder(format string, v ...any) HTMLInput {
	e.setAttr("placeholder", FormatString(format, v...))
	return e
}

func (e *htmlInput) ReadOnly(v bool) HTMLInput {
	e.setAttr("readonly", v)
	return e
}

func (e *htmlInput) Required(v bool) HTMLInput {
	e.setAttr("required", v)
	return e
}

func (e *htmlInput) Role(format string, v ...any) HTMLInput {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlInput) Size(v int) HTMLInput {
	e.setAttr("size", v)
	return e
}

func (e *htmlInput) Spellcheck(v bool) HTMLInput {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlInput) Src(format string, v ...any) HTMLInput {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlInput) Step(v float64) HTMLInput {
	e.setAttr("step", v)
	return e
}

func (e *htmlInput) Style(k, format string, v ...any) HTMLInput {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlInput) Styles(s map[string]string) HTMLInput {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlInput) TabIndex(v int) HTMLInput {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlInput) Title(format string, v ...any) HTMLInput {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlInput) Type(format string, v ...any) HTMLInput {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlInput) Value(v any) HTMLInput {
	e.setAttr("value", v)
	return e
}

func (e *htmlInput) Width(v int) HTMLInput {
	e.setAttr("width", v)
	return e
}

func (e *htmlInput) On(event string, h EventHandler, options ...EventOption) HTMLInput {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlInput) OnBlur(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("blur", h, options...)
}

func (e *htmlInput) OnChange(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("change", h, options...)
}

func (e *htmlInput) OnClick(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("click", h, options...)
}

func (e *htmlInput) OnContextMenu(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("contextmenu", h, options...)
}

func (e *htmlInput) OnCopy(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("copy", h, options...)
}

func (e *htmlInput) OnCut(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("cut", h, options...)
}

func (e *htmlInput) OnDblClick(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dblclick", h, options...)
}

func (e *htmlInput) OnDrag(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("drag", h, options...)
}

func (e *htmlInput) OnDragEnd(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dragend", h, options...)
}

func (e *htmlInput) OnDragEnter(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dragenter", h, options...)
}

func (e *htmlInput) OnDragLeave(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dragleave", h, options...)
}

func (e *htmlInput) OnDragOver(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dragover", h, options...)
}

func (e *htmlInput) OnDragStart(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("dragstart", h, options...)
}

func (e *htmlInput) OnDrop(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("drop", h, options...)
}

func (e *htmlInput) OnFocus(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("focus", h, options...)
}

func (e *htmlInput) OnInput(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("input", h, options...)
}

func (e *htmlInput) OnInvalid(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("invalid", h, options...)
}

func (e *htmlInput) OnKeyDown(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("keydown", h, options...)
}

func (e *htmlInput) OnKeyPress(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("keypress", h, options...)
}

func (e *htmlInput) OnKeyUp(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("keyup", h, options...)
}

func (e *htmlInput) OnLoad(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("load", h, options...)
}

func (e *htmlInput) OnMouseDown(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mousedown", h, options...)
}

func (e *htmlInput) OnMouseEnter(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mouseenter", h, options...)
}

func (e *htmlInput) OnMouseLeave(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mouseleave", h, options...)
}

func (e *htmlInput) OnMouseMove(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mousemove", h, options...)
}

func (e *htmlInput) OnMouseOut(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mouseout", h, options...)
}

func (e *htmlInput) OnMouseOver(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mouseover", h, options...)
}

func (e *htmlInput) OnMouseUp(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("mouseup", h, options...)
}

func (e *htmlInput) OnPaste(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("paste", h, options...)
}

func (e *htmlInput) OnReset(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("reset", h, options...)
}

func (e *htmlInput) OnScroll(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("scroll", h, options...)
}

func (e *htmlInput) OnSearch(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("search", h, options...)
}

func (e *htmlInput) OnSelect(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("select", h, options...)
}

func (e *htmlInput) OnSubmit(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("submit", h, options...)
}

func (e *htmlInput) OnWheel(h EventHandler, options ...EventOption) HTMLInput {
	return e.On("wheel", h, options...)
}

func (e *htmlInput) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlInput) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlInput) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlInput) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlInput) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlInput) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "ins" HTML element.
type HTMLIns interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLIns

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLIns

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLIns

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLIns

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLIns

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLIns

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLIns

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLIns

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLIns

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLIns

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLIns

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLIns

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLIns

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLIns

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLIns

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLIns

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLIns

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLIns

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLIns

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLIns

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLIns

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLIns

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLIns

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLIns

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLIns

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLIns

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLIns

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLIns

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLIns

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLIns

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLIns

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLIns

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLIns

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLIns

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLIns

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLIns
}

// Returns an HTML element that defines text that has been inserted into a document.
func Ins() HTMLIns {
	e := &htmlIns{
		htmlElement: htmlElement{
			tag:           "ins",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlIns struct {
	htmlElement
}

func (e *htmlIns) Body(v ...UI) HTMLIns {
	return e.setBody(FilterUIElems(v...)).(*htmlIns)
}

func (e *htmlIns) Text(v any) HTMLIns {
	return e.Body(Text(v))
}

func (e *htmlIns) Textf(format string, v ...any) HTMLIns {
	return e.Body(Textf(format, v...))
}

func (e *htmlIns) AccessKey(format string, v ...any) HTMLIns {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlIns) Aria(k string, v any) HTMLIns {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlIns) Attr(n string, v any) HTMLIns {
	e.setAttr(n, v)
	return e
}

func (e *htmlIns) Class(v ...string) HTMLIns {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlIns) ContentEditable(v bool) HTMLIns {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlIns) DataSet(k string, v any) HTMLIns {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlIns) DataSets(ds map[string]any) HTMLIns {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlIns) Dir(format string, v ...any) HTMLIns {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlIns) Draggable(v bool) HTMLIns {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlIns) Hidden(v bool) HTMLIns {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlIns) ID(format string, v ...any) HTMLIns {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlIns) Lang(format string, v ...any) HTMLIns {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlIns) Role(format string, v ...any) HTMLIns {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlIns) Spellcheck(v bool) HTMLIns {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlIns) Style(k, format string, v ...any) HTMLIns {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlIns) Styles(s map[string]string) HTMLIns {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlIns) TabIndex(v int) HTMLIns {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlIns) Title(format string, v ...any) HTMLIns {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlIns) On(event string, h EventHandler, options ...EventOption) HTMLIns {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlIns) OnBlur(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("blur", h, options...)
}

func (e *htmlIns) OnChange(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("change", h, options...)
}

func (e *htmlIns) OnClick(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("click", h, options...)
}

func (e *htmlIns) OnContextMenu(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("contextmenu", h, options...)
}

func (e *htmlIns) OnCopy(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("copy", h, options...)
}

func (e *htmlIns) OnCut(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("cut", h, options...)
}

func (e *htmlIns) OnDblClick(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dblclick", h, options...)
}

func (e *htmlIns) OnDrag(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("drag", h, options...)
}

func (e *htmlIns) OnDragEnd(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dragend", h, options...)
}

func (e *htmlIns) OnDragEnter(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dragenter", h, options...)
}

func (e *htmlIns) OnDragLeave(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dragleave", h, options...)
}

func (e *htmlIns) OnDragOver(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dragover", h, options...)
}

func (e *htmlIns) OnDragStart(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("dragstart", h, options...)
}

func (e *htmlIns) OnDrop(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("drop", h, options...)
}

func (e *htmlIns) OnFocus(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("focus", h, options...)
}

func (e *htmlIns) OnInput(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("input", h, options...)
}

func (e *htmlIns) OnInvalid(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("invalid", h, options...)
}

func (e *htmlIns) OnKeyDown(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("keydown", h, options...)
}

func (e *htmlIns) OnKeyPress(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("keypress", h, options...)
}

func (e *htmlIns) OnKeyUp(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("keyup", h, options...)
}

func (e *htmlIns) OnMouseDown(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mousedown", h, options...)
}

func (e *htmlIns) OnMouseEnter(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mouseenter", h, options...)
}

func (e *htmlIns) OnMouseLeave(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mouseleave", h, options...)
}

func (e *htmlIns) OnMouseMove(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mousemove", h, options...)
}

func (e *htmlIns) OnMouseOut(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mouseout", h, options...)
}

func (e *htmlIns) OnMouseOver(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mouseover", h, options...)
}

func (e *htmlIns) OnMouseUp(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("mouseup", h, options...)
}

func (e *htmlIns) OnPaste(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("paste", h, options...)
}

func (e *htmlIns) OnReset(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("reset", h, options...)
}

func (e *htmlIns) OnScroll(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("scroll", h, options...)
}

func (e *htmlIns) OnSearch(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("search", h, options...)
}

func (e *htmlIns) OnSelect(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("select", h, options...)
}

func (e *htmlIns) OnSubmit(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("submit", h, options...)
}

func (e *htmlIns) OnWheel(h EventHandler, options ...EventOption) HTMLIns {
	return e.On("wheel", h, options...)
}

func (e *htmlIns) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlIns) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlIns) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlIns) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlIns) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlIns) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "kbd" HTML element.
type HTMLKbd interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLKbd

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLKbd

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLKbd

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLKbd

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLKbd

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLKbd

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLKbd

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLKbd

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLKbd

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLKbd

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLKbd

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLKbd

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLKbd

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLKbd

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLKbd

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLKbd

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLKbd

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLKbd

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLKbd

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLKbd

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLKbd

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLKbd

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLKbd

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLKbd

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLKbd

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLKbd
}

// Returns an HTML element that represents keyboard input.
func Kbd() HTMLKbd {
	e := &htmlKbd{
		htmlElement: htmlElement{
			tag:           "kbd",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlKbd struct {
	htmlElement
}

func (e *htmlKbd) Body(v ...UI) HTMLKbd {
	return e.setBody(FilterUIElems(v...)).(*htmlKbd)
}

func (e *htmlKbd) Text(v any) HTMLKbd {
	return e.Body(Text(v))
}

func (e *htmlKbd) Textf(format string, v ...any) HTMLKbd {
	return e.Body(Textf(format, v...))
}

func (e *htmlKbd) AccessKey(format string, v ...any) HTMLKbd {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlKbd) Aria(k string, v any) HTMLKbd {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlKbd) Attr(n string, v any) HTMLKbd {
	e.setAttr(n, v)
	return e
}

func (e *htmlKbd) Class(v ...string) HTMLKbd {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlKbd) ContentEditable(v bool) HTMLKbd {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlKbd) DataSet(k string, v any) HTMLKbd {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlKbd) DataSets(ds map[string]any) HTMLKbd {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlKbd) Dir(format string, v ...any) HTMLKbd {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlKbd) Draggable(v bool) HTMLKbd {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlKbd) Hidden(v bool) HTMLKbd {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlKbd) ID(format string, v ...any) HTMLKbd {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlKbd) Lang(format string, v ...any) HTMLKbd {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlKbd) Role(format string, v ...any) HTMLKbd {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlKbd) Spellcheck(v bool) HTMLKbd {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlKbd) Style(k, format string, v ...any) HTMLKbd {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlKbd) Styles(s map[string]string) HTMLKbd {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlKbd) TabIndex(v int) HTMLKbd {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlKbd) Title(format string, v ...any) HTMLKbd {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlKbd) On(event string, h EventHandler, options ...EventOption) HTMLKbd {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlKbd) OnBlur(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("blur", h, options...)
}

func (e *htmlKbd) OnChange(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("change", h, options...)
}

func (e *htmlKbd) OnClick(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("click", h, options...)
}

func (e *htmlKbd) OnContextMenu(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("contextmenu", h, options...)
}

func (e *htmlKbd) OnCopy(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("copy", h, options...)
}

func (e *htmlKbd) OnCut(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("cut", h, options...)
}

func (e *htmlKbd) OnDblClick(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dblclick", h, options...)
}

func (e *htmlKbd) OnDrag(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("drag", h, options...)
}

func (e *htmlKbd) OnDragEnd(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dragend", h, options...)
}

func (e *htmlKbd) OnDragEnter(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dragenter", h, options...)
}

func (e *htmlKbd) OnDragLeave(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dragleave", h, options...)
}

func (e *htmlKbd) OnDragOver(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dragover", h, options...)
}

func (e *htmlKbd) OnDragStart(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("dragstart", h, options...)
}

func (e *htmlKbd) OnDrop(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("drop", h, options...)
}

func (e *htmlKbd) OnFocus(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("focus", h, options...)
}

func (e *htmlKbd) OnInput(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("input", h, options...)
}

func (e *htmlKbd) OnInvalid(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("invalid", h, options...)
}

func (e *htmlKbd) OnKeyDown(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("keydown", h, options...)
}

func (e *htmlKbd) OnKeyPress(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("keypress", h, options...)
}

func (e *htmlKbd) OnKeyUp(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("keyup", h, options...)
}

func (e *htmlKbd) OnMouseDown(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mousedown", h, options...)
}

func (e *htmlKbd) OnMouseEnter(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mouseenter", h, options...)
}

func (e *htmlKbd) OnMouseLeave(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mouseleave", h, options...)
}

func (e *htmlKbd) OnMouseMove(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mousemove", h, options...)
}

func (e *htmlKbd) OnMouseOut(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mouseout", h, options...)
}

func (e *htmlKbd) OnMouseOver(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mouseover", h, options...)
}

func (e *htmlKbd) OnMouseUp(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("mouseup", h, options...)
}

func (e *htmlKbd) OnPaste(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("paste", h, options...)
}

func (e *htmlKbd) OnReset(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("reset", h, options...)
}

func (e *htmlKbd) OnScroll(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("scroll", h, options...)
}

func (e *htmlKbd) OnSearch(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("search", h, options...)
}

func (e *htmlKbd) OnSelect(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("select", h, options...)
}

func (e *htmlKbd) OnSubmit(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("submit", h, options...)
}

func (e *htmlKbd) OnWheel(h EventHandler, options ...EventOption) HTMLKbd {
	return e.On("wheel", h, options...)
}

func (e *htmlKbd) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlKbd) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlKbd) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlKbd) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlKbd) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlKbd) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "label" HTML element.
type HTMLLabel interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLLabel

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLLabel

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLLabel

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLLabel

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLLabel

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLLabel

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLLabel

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLLabel

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLLabel

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLLabel

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLLabel

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLLabel

	// Associates a label or calculation with specific form element(s).
	For(format string, v ...any) HTMLLabel

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLLabel

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLLabel

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLLabel

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLLabel

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLLabel

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLLabel

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLLabel

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLLabel

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLLabel

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLLabel

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLLabel

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLLabel

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLLabel

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLLabel

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLLabel
}

// Returns an HTML element that represents a label for an input element.
func Label() HTMLLabel {
	e := &htmlLabel{
		htmlElement: htmlElement{
			tag:           "label",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlLabel struct {
	htmlElement
}

func (e *htmlLabel) Body(v ...UI) HTMLLabel {
	return e.setBody(FilterUIElems(v...)).(*htmlLabel)
}

func (e *htmlLabel) Text(v any) HTMLLabel {
	return e.Body(Text(v))
}

func (e *htmlLabel) Textf(format string, v ...any) HTMLLabel {
	return e.Body(Textf(format, v...))
}

func (e *htmlLabel) AccessKey(format string, v ...any) HTMLLabel {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Aria(k string, v any) HTMLLabel {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLabel) Attr(n string, v any) HTMLLabel {
	e.setAttr(n, v)
	return e
}

func (e *htmlLabel) Class(v ...string) HTMLLabel {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlLabel) ContentEditable(v bool) HTMLLabel {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlLabel) DataSet(k string, v any) HTMLLabel {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLabel) DataSets(ds map[string]any) HTMLLabel {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlLabel) Dir(format string, v ...any) HTMLLabel {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Draggable(v bool) HTMLLabel {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlLabel) For(format string, v ...any) HTMLLabel {
	e.setAttr("for", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Form(format string, v ...any) HTMLLabel {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Hidden(v bool) HTMLLabel {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlLabel) ID(format string, v ...any) HTMLLabel {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Lang(format string, v ...any) HTMLLabel {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Role(format string, v ...any) HTMLLabel {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlLabel) Spellcheck(v bool) HTMLLabel {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlLabel) Style(k, format string, v ...any) HTMLLabel {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlLabel) Styles(s map[string]string) HTMLLabel {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlLabel) TabIndex(v int) HTMLLabel {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlLabel) Title(format string, v ...any) HTMLLabel {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlLabel) On(event string, h EventHandler, options ...EventOption) HTMLLabel {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlLabel) OnBlur(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("blur", h, options...)
}

func (e *htmlLabel) OnChange(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("change", h, options...)
}

func (e *htmlLabel) OnClick(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("click", h, options...)
}

func (e *htmlLabel) OnContextMenu(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("contextmenu", h, options...)
}

func (e *htmlLabel) OnCopy(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("copy", h, options...)
}

func (e *htmlLabel) OnCut(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("cut", h, options...)
}

func (e *htmlLabel) OnDblClick(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dblclick", h, options...)
}

func (e *htmlLabel) OnDrag(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("drag", h, options...)
}

func (e *htmlLabel) OnDragEnd(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dragend", h, options...)
}

func (e *htmlLabel) OnDragEnter(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dragenter", h, options...)
}

func (e *htmlLabel) OnDragLeave(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dragleave", h, options...)
}

func (e *htmlLabel) OnDragOver(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dragover", h, options...)
}

func (e *htmlLabel) OnDragStart(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("dragstart", h, options...)
}

func (e *htmlLabel) OnDrop(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("drop", h, options...)
}

func (e *htmlLabel) OnFocus(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("focus", h, options...)
}

func (e *htmlLabel) OnInput(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("input", h, options...)
}

func (e *htmlLabel) OnInvalid(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("invalid", h, options...)
}

func (e *htmlLabel) OnKeyDown(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("keydown", h, options...)
}

func (e *htmlLabel) OnKeyPress(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("keypress", h, options...)
}

func (e *htmlLabel) OnKeyUp(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("keyup", h, options...)
}

func (e *htmlLabel) OnMouseDown(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mousedown", h, options...)
}

func (e *htmlLabel) OnMouseEnter(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mouseenter", h, options...)
}

func (e *htmlLabel) OnMouseLeave(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mouseleave", h, options...)
}

func (e *htmlLabel) OnMouseMove(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mousemove", h, options...)
}

func (e *htmlLabel) OnMouseOut(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mouseout", h, options...)
}

func (e *htmlLabel) OnMouseOver(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mouseover", h, options...)
}

func (e *htmlLabel) OnMouseUp(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("mouseup", h, options...)
}

func (e *htmlLabel) OnPaste(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("paste", h, options...)
}

func (e *htmlLabel) OnReset(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("reset", h, options...)
}

func (e *htmlLabel) OnScroll(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("scroll", h, options...)
}

func (e *htmlLabel) OnSearch(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("search", h, options...)
}

func (e *htmlLabel) OnSelect(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("select", h, options...)
}

func (e *htmlLabel) OnSubmit(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("submit", h, options...)
}

func (e *htmlLabel) OnWheel(h EventHandler, options ...EventOption) HTMLLabel {
	return e.On("wheel", h, options...)
}

func (e *htmlLabel) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlLabel) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlLabel) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlLabel) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlLabel) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlLabel) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "legend" HTML element.
type HTMLLegend interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLLegend

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLLegend

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLLegend

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLLegend

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLLegend

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLLegend

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLLegend

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLLegend

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLLegend

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLLegend

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLLegend

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLLegend

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLLegend

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLLegend

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLLegend

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLLegend

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLLegend

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLLegend

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLLegend

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLLegend

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLLegend

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLLegend

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLLegend

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLLegend

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLLegend

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLLegend
}

// Returns an HTML element that represents a caption for a fieldset element.
func Legend() HTMLLegend {
	e := &htmlLegend{
		htmlElement: htmlElement{
			tag:           "legend",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlLegend struct {
	htmlElement
}

func (e *htmlLegend) Body(v ...UI) HTMLLegend {
	return e.setBody(FilterUIElems(v...)).(*htmlLegend)
}

func (e *htmlLegend) Text(v any) HTMLLegend {
	return e.Body(Text(v))
}

func (e *htmlLegend) Textf(format string, v ...any) HTMLLegend {
	return e.Body(Textf(format, v...))
}

func (e *htmlLegend) AccessKey(format string, v ...any) HTMLLegend {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlLegend) Aria(k string, v any) HTMLLegend {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLegend) Attr(n string, v any) HTMLLegend {
	e.setAttr(n, v)
	return e
}

func (e *htmlLegend) Class(v ...string) HTMLLegend {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlLegend) ContentEditable(v bool) HTMLLegend {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlLegend) DataSet(k string, v any) HTMLLegend {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLegend) DataSets(ds map[string]any) HTMLLegend {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlLegend) Dir(format string, v ...any) HTMLLegend {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlLegend) Draggable(v bool) HTMLLegend {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlLegend) Hidden(v bool) HTMLLegend {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlLegend) ID(format string, v ...any) HTMLLegend {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlLegend) Lang(format string, v ...any) HTMLLegend {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlLegend) Role(format string, v ...any) HTMLLegend {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlLegend) Spellcheck(v bool) HTMLLegend {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlLegend) Style(k, format string, v ...any) HTMLLegend {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlLegend) Styles(s map[string]string) HTMLLegend {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlLegend) TabIndex(v int) HTMLLegend {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlLegend) Title(format string, v ...any) HTMLLegend {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlLegend) On(event string, h EventHandler, options ...EventOption) HTMLLegend {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlLegend) OnBlur(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("blur", h, options...)
}

func (e *htmlLegend) OnChange(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("change", h, options...)
}

func (e *htmlLegend) OnClick(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("click", h, options...)
}

func (e *htmlLegend) OnContextMenu(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("contextmenu", h, options...)
}

func (e *htmlLegend) OnCopy(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("copy", h, options...)
}

func (e *htmlLegend) OnCut(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("cut", h, options...)
}

func (e *htmlLegend) OnDblClick(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dblclick", h, options...)
}

func (e *htmlLegend) OnDrag(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("drag", h, options...)
}

func (e *htmlLegend) OnDragEnd(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dragend", h, options...)
}

func (e *htmlLegend) OnDragEnter(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dragenter", h, options...)
}

func (e *htmlLegend) OnDragLeave(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dragleave", h, options...)
}

func (e *htmlLegend) OnDragOver(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dragover", h, options...)
}

func (e *htmlLegend) OnDragStart(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("dragstart", h, options...)
}

func (e *htmlLegend) OnDrop(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("drop", h, options...)
}

func (e *htmlLegend) OnFocus(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("focus", h, options...)
}

func (e *htmlLegend) OnInput(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("input", h, options...)
}

func (e *htmlLegend) OnInvalid(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("invalid", h, options...)
}

func (e *htmlLegend) OnKeyDown(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("keydown", h, options...)
}

func (e *htmlLegend) OnKeyPress(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("keypress", h, options...)
}

func (e *htmlLegend) OnKeyUp(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("keyup", h, options...)
}

func (e *htmlLegend) OnMouseDown(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mousedown", h, options...)
}

func (e *htmlLegend) OnMouseEnter(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mouseenter", h, options...)
}

func (e *htmlLegend) OnMouseLeave(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mouseleave", h, options...)
}

func (e *htmlLegend) OnMouseMove(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mousemove", h, options...)
}

func (e *htmlLegend) OnMouseOut(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mouseout", h, options...)
}

func (e *htmlLegend) OnMouseOver(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mouseover", h, options...)
}

func (e *htmlLegend) OnMouseUp(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("mouseup", h, options...)
}

func (e *htmlLegend) OnPaste(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("paste", h, options...)
}

func (e *htmlLegend) OnReset(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("reset", h, options...)
}

func (e *htmlLegend) OnScroll(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("scroll", h, options...)
}

func (e *htmlLegend) OnSearch(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("search", h, options...)
}

func (e *htmlLegend) OnSelect(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("select", h, options...)
}

func (e *htmlLegend) OnSubmit(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("submit", h, options...)
}

func (e *htmlLegend) OnWheel(h EventHandler, options ...EventOption) HTMLLegend {
	return e.On("wheel", h, options...)
}

func (e *htmlLegend) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlLegend) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlLegend) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlLegend) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlLegend) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlLegend) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "li" HTML element.
type HTMLLi interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLLi

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLLi

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLLi

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLLi

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLLi

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLLi

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLLi

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLLi

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLLi

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLLi

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLLi

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLLi

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLLi

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLLi

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLLi

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLLi

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLLi

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLLi

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLLi

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLLi

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLLi

	// Assigns a value to the element.
	Value(v any) HTMLLi

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLLi

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLLi

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLLi

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLLi

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLLi

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLLi

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLLi

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLLi

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLLi

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLLi

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLLi

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLLi

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLLi

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLLi

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLLi
}

// Returns an HTML element that represents a list item.
func Li() HTMLLi {
	e := &htmlLi{
		htmlElement: htmlElement{
			tag:           "li",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlLi struct {
	htmlElement
}

func (e *htmlLi) Body(v ...UI) HTMLLi {
	return e.setBody(FilterUIElems(v...)).(*htmlLi)
}

func (e *htmlLi) Text(v any) HTMLLi {
	return e.Body(Text(v))
}

func (e *htmlLi) Textf(format string, v ...any) HTMLLi {
	return e.Body(Textf(format, v...))
}

func (e *htmlLi) AccessKey(format string, v ...any) HTMLLi {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlLi) Aria(k string, v any) HTMLLi {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLi) Attr(n string, v any) HTMLLi {
	e.setAttr(n, v)
	return e
}

func (e *htmlLi) Class(v ...string) HTMLLi {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlLi) ContentEditable(v bool) HTMLLi {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlLi) DataSet(k string, v any) HTMLLi {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLi) DataSets(ds map[string]any) HTMLLi {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlLi) Dir(format string, v ...any) HTMLLi {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlLi) Draggable(v bool) HTMLLi {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlLi) Hidden(v bool) HTMLLi {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlLi) ID(format string, v ...any) HTMLLi {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlLi) Lang(format string, v ...any) HTMLLi {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlLi) Role(format string, v ...any) HTMLLi {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlLi) Spellcheck(v bool) HTMLLi {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlLi) Style(k, format string, v ...any) HTMLLi {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlLi) Styles(s map[string]string) HTMLLi {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlLi) TabIndex(v int) HTMLLi {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlLi) Title(format string, v ...any) HTMLLi {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlLi) Value(v any) HTMLLi {
	e.setAttr("value", v)
	return e
}

func (e *htmlLi) On(event string, h EventHandler, options ...EventOption) HTMLLi {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlLi) OnBlur(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("blur", h, options...)
}

func (e *htmlLi) OnChange(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("change", h, options...)
}

func (e *htmlLi) OnClick(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("click", h, options...)
}

func (e *htmlLi) OnContextMenu(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("contextmenu", h, options...)
}

func (e *htmlLi) OnCopy(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("copy", h, options...)
}

func (e *htmlLi) OnCut(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("cut", h, options...)
}

func (e *htmlLi) OnDblClick(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dblclick", h, options...)
}

func (e *htmlLi) OnDrag(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("drag", h, options...)
}

func (e *htmlLi) OnDragEnd(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dragend", h, options...)
}

func (e *htmlLi) OnDragEnter(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dragenter", h, options...)
}

func (e *htmlLi) OnDragLeave(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dragleave", h, options...)
}

func (e *htmlLi) OnDragOver(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dragover", h, options...)
}

func (e *htmlLi) OnDragStart(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("dragstart", h, options...)
}

func (e *htmlLi) OnDrop(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("drop", h, options...)
}

func (e *htmlLi) OnFocus(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("focus", h, options...)
}

func (e *htmlLi) OnInput(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("input", h, options...)
}

func (e *htmlLi) OnInvalid(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("invalid", h, options...)
}

func (e *htmlLi) OnKeyDown(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("keydown", h, options...)
}

func (e *htmlLi) OnKeyPress(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("keypress", h, options...)
}

func (e *htmlLi) OnKeyUp(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("keyup", h, options...)
}

func (e *htmlLi) OnMouseDown(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mousedown", h, options...)
}

func (e *htmlLi) OnMouseEnter(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mouseenter", h, options...)
}

func (e *htmlLi) OnMouseLeave(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mouseleave", h, options...)
}

func (e *htmlLi) OnMouseMove(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mousemove", h, options...)
}

func (e *htmlLi) OnMouseOut(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mouseout", h, options...)
}

func (e *htmlLi) OnMouseOver(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mouseover", h, options...)
}

func (e *htmlLi) OnMouseUp(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("mouseup", h, options...)
}

func (e *htmlLi) OnPaste(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("paste", h, options...)
}

func (e *htmlLi) OnReset(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("reset", h, options...)
}

func (e *htmlLi) OnScroll(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("scroll", h, options...)
}

func (e *htmlLi) OnSearch(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("search", h, options...)
}

func (e *htmlLi) OnSelect(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("select", h, options...)
}

func (e *htmlLi) OnSubmit(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("submit", h, options...)
}

func (e *htmlLi) OnWheel(h EventHandler, options ...EventOption) HTMLLi {
	return e.On("wheel", h, options...)
}

func (e *htmlLi) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlLi) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlLi) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlLi) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlLi) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlLi) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "link" HTML element.
type HTMLLink interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLLink

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLLink

	// Hints the type of content to preload, optimizing loading for certain resources.
	As(format string, v ...any) HTMLLink

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLLink

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLLink

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLLink

	// Controls how cross-origin requests are managed for the element, supporting secure content integration from different origins.
	CrossOrigin(format string, v ...any) HTMLLink

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLLink

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLLink

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLLink

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLLink

	// Provides a hint to the browser about how it should prioritize the fetch of the image in relation to other images.
	FetchPriority(format string, v ...any) HTMLLink

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLLink

	// Points to the URL of the destination when the link is clicked.
	Href(format string, v ...any) HTMLLink

	// Declares the language of the linked document's content.
	HrefLang(format string, v ...any) HTMLLink

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLLink

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLLink

	// Indicates the intended media or device for the linked document.
	Media(format string, v ...any) HTMLLink

	// Describes the relationship between the current and linked documents.
	Rel(format string, v ...any) HTMLLink

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLLink

	// Specifies sizes of icons and images for different page or screen scenarios. Uses the given format and values.
	Sizes(format string, v ...any) HTMLLink

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLLink

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLLink

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLLink

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLLink

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLLink

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLLink

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLLink

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLLink

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLLink

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLLink

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLLink

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLLink

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLLink

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLLink

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLLink

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLLink

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLLink

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLLink

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLLink

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLLink

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLLink

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLLink
}

// Returns an HTML element that describes the relationship between a document and an external resource (most commonly used to link to style sheets).
func Link() HTMLLink {
	e := &htmlLink{
		htmlElement: htmlElement{
			tag:           "link",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlLink struct {
	htmlElement
}

func (e *htmlLink) AccessKey(format string, v ...any) HTMLLink {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlLink) Aria(k string, v any) HTMLLink {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLink) As(format string, v ...any) HTMLLink {
	e.setAttr("as", FormatString(format, v...))
	return e
}

func (e *htmlLink) Attr(n string, v any) HTMLLink {
	e.setAttr(n, v)
	return e
}

func (e *htmlLink) Class(v ...string) HTMLLink {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlLink) ContentEditable(v bool) HTMLLink {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlLink) CrossOrigin(format string, v ...any) HTMLLink {
	e.setAttr("crossorigin", FormatString(format, v...))
	return e
}

func (e *htmlLink) DataSet(k string, v any) HTMLLink {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlLink) DataSets(ds map[string]any) HTMLLink {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlLink) Dir(format string, v ...any) HTMLLink {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlLink) Draggable(v bool) HTMLLink {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlLink) FetchPriority(format string, v ...any) HTMLLink {
	e.setAttr("fetchpriority", FormatString(format, v...))
	return e
}

func (e *htmlLink) Hidden(v bool) HTMLLink {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlLink) Href(format string, v ...any) HTMLLink {
	e.setAttr("href", FormatString(format, v...))
	return e
}

func (e *htmlLink) HrefLang(format string, v ...any) HTMLLink {
	e.setAttr("hreflang", FormatString(format, v...))
	return e
}

func (e *htmlLink) ID(format string, v ...any) HTMLLink {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlLink) Lang(format string, v ...any) HTMLLink {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlLink) Media(format string, v ...any) HTMLLink {
	e.setAttr("media", FormatString(format, v...))
	return e
}

func (e *htmlLink) Rel(format string, v ...any) HTMLLink {
	e.setAttr("rel", FormatString(format, v...))
	return e
}

func (e *htmlLink) Role(format string, v ...any) HTMLLink {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlLink) Sizes(format string, v ...any) HTMLLink {
	e.setAttr("sizes", FormatString(format, v...))
	return e
}

func (e *htmlLink) Spellcheck(v bool) HTMLLink {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlLink) Style(k, format string, v ...any) HTMLLink {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlLink) Styles(s map[string]string) HTMLLink {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlLink) TabIndex(v int) HTMLLink {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlLink) Title(format string, v ...any) HTMLLink {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlLink) Type(format string, v ...any) HTMLLink {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlLink) On(event string, h EventHandler, options ...EventOption) HTMLLink {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlLink) OnBlur(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("blur", h, options...)
}

func (e *htmlLink) OnChange(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("change", h, options...)
}

func (e *htmlLink) OnClick(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("click", h, options...)
}

func (e *htmlLink) OnContextMenu(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("contextmenu", h, options...)
}

func (e *htmlLink) OnCopy(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("copy", h, options...)
}

func (e *htmlLink) OnCut(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("cut", h, options...)
}

func (e *htmlLink) OnDblClick(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dblclick", h, options...)
}

func (e *htmlLink) OnDrag(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("drag", h, options...)
}

func (e *htmlLink) OnDragEnd(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dragend", h, options...)
}

func (e *htmlLink) OnDragEnter(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dragenter", h, options...)
}

func (e *htmlLink) OnDragLeave(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dragleave", h, options...)
}

func (e *htmlLink) OnDragOver(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dragover", h, options...)
}

func (e *htmlLink) OnDragStart(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("dragstart", h, options...)
}

func (e *htmlLink) OnDrop(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("drop", h, options...)
}

func (e *htmlLink) OnFocus(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("focus", h, options...)
}

func (e *htmlLink) OnInput(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("input", h, options...)
}

func (e *htmlLink) OnInvalid(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("invalid", h, options...)
}

func (e *htmlLink) OnKeyDown(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("keydown", h, options...)
}

func (e *htmlLink) OnKeyPress(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("keypress", h, options...)
}

func (e *htmlLink) OnKeyUp(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("keyup", h, options...)
}

func (e *htmlLink) OnLoad(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("load", h, options...)
}

func (e *htmlLink) OnMouseDown(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mousedown", h, options...)
}

func (e *htmlLink) OnMouseEnter(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mouseenter", h, options...)
}

func (e *htmlLink) OnMouseLeave(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mouseleave", h, options...)
}

func (e *htmlLink) OnMouseMove(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mousemove", h, options...)
}

func (e *htmlLink) OnMouseOut(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mouseout", h, options...)
}

func (e *htmlLink) OnMouseOver(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mouseover", h, options...)
}

func (e *htmlLink) OnMouseUp(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("mouseup", h, options...)
}

func (e *htmlLink) OnPaste(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("paste", h, options...)
}

func (e *htmlLink) OnReset(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("reset", h, options...)
}

func (e *htmlLink) OnScroll(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("scroll", h, options...)
}

func (e *htmlLink) OnSearch(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("search", h, options...)
}

func (e *htmlLink) OnSelect(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("select", h, options...)
}

func (e *htmlLink) OnSubmit(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("submit", h, options...)
}

func (e *htmlLink) OnWheel(h EventHandler, options ...EventOption) HTMLLink {
	return e.On("wheel", h, options...)
}

func (e *htmlLink) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlLink) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlLink) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlLink) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlLink) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlLink) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "main" HTML element.
type HTMLMain interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLMain

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLMain

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLMain

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMain

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMain

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMain

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMain

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMain

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMain

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMain

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMain

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMain

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMain

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMain

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMain

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMain

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMain

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMain

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMain

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMain

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMain

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMain

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLMain

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLMain

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLMain

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLMain

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLMain

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLMain

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLMain

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLMain

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLMain

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLMain

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLMain

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLMain

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLMain

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLMain
}

// Returns an HTML element that specifies the main content of a document.
func Main() HTMLMain {
	e := &htmlMain{
		htmlElement: htmlElement{
			tag:           "main",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlMain struct {
	htmlElement
}

func (e *htmlMain) Body(v ...UI) HTMLMain {
	return e.setBody(FilterUIElems(v...)).(*htmlMain)
}

func (e *htmlMain) Text(v any) HTMLMain {
	return e.Body(Text(v))
}

func (e *htmlMain) Textf(format string, v ...any) HTMLMain {
	return e.Body(Textf(format, v...))
}

func (e *htmlMain) AccessKey(format string, v ...any) HTMLMain {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMain) Aria(k string, v any) HTMLMain {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMain) Attr(n string, v any) HTMLMain {
	e.setAttr(n, v)
	return e
}

func (e *htmlMain) Class(v ...string) HTMLMain {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMain) ContentEditable(v bool) HTMLMain {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMain) DataSet(k string, v any) HTMLMain {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMain) DataSets(ds map[string]any) HTMLMain {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMain) Dir(format string, v ...any) HTMLMain {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMain) Draggable(v bool) HTMLMain {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMain) Hidden(v bool) HTMLMain {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMain) ID(format string, v ...any) HTMLMain {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMain) Lang(format string, v ...any) HTMLMain {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMain) Role(format string, v ...any) HTMLMain {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMain) Spellcheck(v bool) HTMLMain {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMain) Style(k, format string, v ...any) HTMLMain {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMain) Styles(s map[string]string) HTMLMain {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMain) TabIndex(v int) HTMLMain {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMain) Title(format string, v ...any) HTMLMain {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMain) On(event string, h EventHandler, options ...EventOption) HTMLMain {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMain) OnBlur(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("blur", h, options...)
}

func (e *htmlMain) OnChange(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("change", h, options...)
}

func (e *htmlMain) OnClick(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("click", h, options...)
}

func (e *htmlMain) OnContextMenu(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("contextmenu", h, options...)
}

func (e *htmlMain) OnCopy(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("copy", h, options...)
}

func (e *htmlMain) OnCut(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("cut", h, options...)
}

func (e *htmlMain) OnDblClick(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dblclick", h, options...)
}

func (e *htmlMain) OnDrag(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("drag", h, options...)
}

func (e *htmlMain) OnDragEnd(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dragend", h, options...)
}

func (e *htmlMain) OnDragEnter(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dragenter", h, options...)
}

func (e *htmlMain) OnDragLeave(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dragleave", h, options...)
}

func (e *htmlMain) OnDragOver(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dragover", h, options...)
}

func (e *htmlMain) OnDragStart(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("dragstart", h, options...)
}

func (e *htmlMain) OnDrop(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("drop", h, options...)
}

func (e *htmlMain) OnFocus(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("focus", h, options...)
}

func (e *htmlMain) OnInput(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("input", h, options...)
}

func (e *htmlMain) OnInvalid(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("invalid", h, options...)
}

func (e *htmlMain) OnKeyDown(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("keydown", h, options...)
}

func (e *htmlMain) OnKeyPress(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("keypress", h, options...)
}

func (e *htmlMain) OnKeyUp(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("keyup", h, options...)
}

func (e *htmlMain) OnMouseDown(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mousedown", h, options...)
}

func (e *htmlMain) OnMouseEnter(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mouseenter", h, options...)
}

func (e *htmlMain) OnMouseLeave(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mouseleave", h, options...)
}

func (e *htmlMain) OnMouseMove(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mousemove", h, options...)
}

func (e *htmlMain) OnMouseOut(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mouseout", h, options...)
}

func (e *htmlMain) OnMouseOver(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mouseover", h, options...)
}

func (e *htmlMain) OnMouseUp(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("mouseup", h, options...)
}

func (e *htmlMain) OnPaste(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("paste", h, options...)
}

func (e *htmlMain) OnReset(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("reset", h, options...)
}

func (e *htmlMain) OnScroll(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("scroll", h, options...)
}

func (e *htmlMain) OnSearch(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("search", h, options...)
}

func (e *htmlMain) OnSelect(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("select", h, options...)
}

func (e *htmlMain) OnSubmit(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("submit", h, options...)
}

func (e *htmlMain) OnWheel(h EventHandler, options ...EventOption) HTMLMain {
	return e.On("wheel", h, options...)
}

func (e *htmlMain) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMain) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMain) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMain) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMain) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMain) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "map" HTML element.
type HTMLMap interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLMap

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLMap

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLMap

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMap

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMap

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMap

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMap

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMap

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMap

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMap

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMap

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMap

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMap

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMap

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMap

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLMap

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMap

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMap

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMap

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMap

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMap

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMap

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMap

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLMap

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLMap

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLMap

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLMap

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLMap

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLMap

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLMap

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLMap

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLMap

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLMap

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLMap

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLMap

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLMap

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLMap
}

// Returns an HTML element that represents a client-side image-map.
func Map() HTMLMap {
	e := &htmlMap{
		htmlElement: htmlElement{
			tag:           "map",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlMap struct {
	htmlElement
}

func (e *htmlMap) Body(v ...UI) HTMLMap {
	return e.setBody(FilterUIElems(v...)).(*htmlMap)
}

func (e *htmlMap) Text(v any) HTMLMap {
	return e.Body(Text(v))
}

func (e *htmlMap) Textf(format string, v ...any) HTMLMap {
	return e.Body(Textf(format, v...))
}

func (e *htmlMap) AccessKey(format string, v ...any) HTMLMap {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMap) Aria(k string, v any) HTMLMap {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMap) Attr(n string, v any) HTMLMap {
	e.setAttr(n, v)
	return e
}

func (e *htmlMap) Class(v ...string) HTMLMap {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMap) ContentEditable(v bool) HTMLMap {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMap) DataSet(k string, v any) HTMLMap {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMap) DataSets(ds map[string]any) HTMLMap {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMap) Dir(format string, v ...any) HTMLMap {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMap) Draggable(v bool) HTMLMap {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMap) Hidden(v bool) HTMLMap {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMap) ID(format string, v ...any) HTMLMap {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMap) Lang(format string, v ...any) HTMLMap {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMap) Name(format string, v ...any) HTMLMap {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlMap) Role(format string, v ...any) HTMLMap {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMap) Spellcheck(v bool) HTMLMap {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMap) Style(k, format string, v ...any) HTMLMap {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMap) Styles(s map[string]string) HTMLMap {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMap) TabIndex(v int) HTMLMap {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMap) Title(format string, v ...any) HTMLMap {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMap) On(event string, h EventHandler, options ...EventOption) HTMLMap {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMap) OnBlur(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("blur", h, options...)
}

func (e *htmlMap) OnChange(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("change", h, options...)
}

func (e *htmlMap) OnClick(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("click", h, options...)
}

func (e *htmlMap) OnContextMenu(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("contextmenu", h, options...)
}

func (e *htmlMap) OnCopy(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("copy", h, options...)
}

func (e *htmlMap) OnCut(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("cut", h, options...)
}

func (e *htmlMap) OnDblClick(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dblclick", h, options...)
}

func (e *htmlMap) OnDrag(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("drag", h, options...)
}

func (e *htmlMap) OnDragEnd(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dragend", h, options...)
}

func (e *htmlMap) OnDragEnter(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dragenter", h, options...)
}

func (e *htmlMap) OnDragLeave(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dragleave", h, options...)
}

func (e *htmlMap) OnDragOver(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dragover", h, options...)
}

func (e *htmlMap) OnDragStart(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("dragstart", h, options...)
}

func (e *htmlMap) OnDrop(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("drop", h, options...)
}

func (e *htmlMap) OnFocus(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("focus", h, options...)
}

func (e *htmlMap) OnInput(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("input", h, options...)
}

func (e *htmlMap) OnInvalid(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("invalid", h, options...)
}

func (e *htmlMap) OnKeyDown(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("keydown", h, options...)
}

func (e *htmlMap) OnKeyPress(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("keypress", h, options...)
}

func (e *htmlMap) OnKeyUp(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("keyup", h, options...)
}

func (e *htmlMap) OnMouseDown(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mousedown", h, options...)
}

func (e *htmlMap) OnMouseEnter(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mouseenter", h, options...)
}

func (e *htmlMap) OnMouseLeave(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mouseleave", h, options...)
}

func (e *htmlMap) OnMouseMove(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mousemove", h, options...)
}

func (e *htmlMap) OnMouseOut(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mouseout", h, options...)
}

func (e *htmlMap) OnMouseOver(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mouseover", h, options...)
}

func (e *htmlMap) OnMouseUp(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("mouseup", h, options...)
}

func (e *htmlMap) OnPaste(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("paste", h, options...)
}

func (e *htmlMap) OnReset(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("reset", h, options...)
}

func (e *htmlMap) OnScroll(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("scroll", h, options...)
}

func (e *htmlMap) OnSearch(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("search", h, options...)
}

func (e *htmlMap) OnSelect(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("select", h, options...)
}

func (e *htmlMap) OnSubmit(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("submit", h, options...)
}

func (e *htmlMap) OnWheel(h EventHandler, options ...EventOption) HTMLMap {
	return e.On("wheel", h, options...)
}

func (e *htmlMap) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMap) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMap) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMap) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMap) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMap) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "mark" HTML element.
type HTMLMark interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLMark

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLMark

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLMark

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMark

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMark

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMark

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMark

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMark

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMark

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMark

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMark

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMark

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMark

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMark

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMark

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMark

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMark

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMark

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMark

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMark

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMark

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMark

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLMark

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLMark

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLMark

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLMark

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLMark

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLMark

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLMark

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLMark

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLMark

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLMark

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLMark

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLMark

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLMark

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLMark
}

// Returns an HTML element that represents marked/highlighted text.
func Mark() HTMLMark {
	e := &htmlMark{
		htmlElement: htmlElement{
			tag:           "mark",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlMark struct {
	htmlElement
}

func (e *htmlMark) Body(v ...UI) HTMLMark {
	return e.setBody(FilterUIElems(v...)).(*htmlMark)
}

func (e *htmlMark) Text(v any) HTMLMark {
	return e.Body(Text(v))
}

func (e *htmlMark) Textf(format string, v ...any) HTMLMark {
	return e.Body(Textf(format, v...))
}

func (e *htmlMark) AccessKey(format string, v ...any) HTMLMark {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMark) Aria(k string, v any) HTMLMark {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMark) Attr(n string, v any) HTMLMark {
	e.setAttr(n, v)
	return e
}

func (e *htmlMark) Class(v ...string) HTMLMark {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMark) ContentEditable(v bool) HTMLMark {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMark) DataSet(k string, v any) HTMLMark {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMark) DataSets(ds map[string]any) HTMLMark {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMark) Dir(format string, v ...any) HTMLMark {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMark) Draggable(v bool) HTMLMark {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMark) Hidden(v bool) HTMLMark {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMark) ID(format string, v ...any) HTMLMark {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMark) Lang(format string, v ...any) HTMLMark {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMark) Role(format string, v ...any) HTMLMark {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMark) Spellcheck(v bool) HTMLMark {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMark) Style(k, format string, v ...any) HTMLMark {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMark) Styles(s map[string]string) HTMLMark {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMark) TabIndex(v int) HTMLMark {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMark) Title(format string, v ...any) HTMLMark {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMark) On(event string, h EventHandler, options ...EventOption) HTMLMark {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMark) OnBlur(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("blur", h, options...)
}

func (e *htmlMark) OnChange(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("change", h, options...)
}

func (e *htmlMark) OnClick(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("click", h, options...)
}

func (e *htmlMark) OnContextMenu(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("contextmenu", h, options...)
}

func (e *htmlMark) OnCopy(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("copy", h, options...)
}

func (e *htmlMark) OnCut(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("cut", h, options...)
}

func (e *htmlMark) OnDblClick(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dblclick", h, options...)
}

func (e *htmlMark) OnDrag(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("drag", h, options...)
}

func (e *htmlMark) OnDragEnd(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dragend", h, options...)
}

func (e *htmlMark) OnDragEnter(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dragenter", h, options...)
}

func (e *htmlMark) OnDragLeave(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dragleave", h, options...)
}

func (e *htmlMark) OnDragOver(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dragover", h, options...)
}

func (e *htmlMark) OnDragStart(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("dragstart", h, options...)
}

func (e *htmlMark) OnDrop(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("drop", h, options...)
}

func (e *htmlMark) OnFocus(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("focus", h, options...)
}

func (e *htmlMark) OnInput(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("input", h, options...)
}

func (e *htmlMark) OnInvalid(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("invalid", h, options...)
}

func (e *htmlMark) OnKeyDown(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("keydown", h, options...)
}

func (e *htmlMark) OnKeyPress(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("keypress", h, options...)
}

func (e *htmlMark) OnKeyUp(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("keyup", h, options...)
}

func (e *htmlMark) OnMouseDown(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mousedown", h, options...)
}

func (e *htmlMark) OnMouseEnter(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mouseenter", h, options...)
}

func (e *htmlMark) OnMouseLeave(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mouseleave", h, options...)
}

func (e *htmlMark) OnMouseMove(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mousemove", h, options...)
}

func (e *htmlMark) OnMouseOut(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mouseout", h, options...)
}

func (e *htmlMark) OnMouseOver(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mouseover", h, options...)
}

func (e *htmlMark) OnMouseUp(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("mouseup", h, options...)
}

func (e *htmlMark) OnPaste(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("paste", h, options...)
}

func (e *htmlMark) OnReset(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("reset", h, options...)
}

func (e *htmlMark) OnScroll(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("scroll", h, options...)
}

func (e *htmlMark) OnSearch(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("search", h, options...)
}

func (e *htmlMark) OnSelect(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("select", h, options...)
}

func (e *htmlMark) OnSubmit(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("submit", h, options...)
}

func (e *htmlMark) OnWheel(h EventHandler, options ...EventOption) HTMLMark {
	return e.On("wheel", h, options...)
}

func (e *htmlMark) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMark) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMark) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMark) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMark) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMark) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "menu" HTML element.
type HTMLMenu interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLMenu

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLMenu

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLMenu

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMenu

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMenu

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMenu

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMenu

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMenu

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMenu

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMenu

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMenu

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMenu

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMenu

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMenu

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMenu

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMenu

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMenu

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMenu

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMenu

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMenu

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMenu

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMenu

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLMenu

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLMenu

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLMenu

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLMenu
}

// Returns an HTML element that represents an unordered list of items.
func Menu() HTMLMenu {
	e := &htmlMenu{
		htmlElement: htmlElement{
			tag:           "menu",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlMenu struct {
	htmlElement
}

func (e *htmlMenu) Body(v ...UI) HTMLMenu {
	return e.setBody(FilterUIElems(v...)).(*htmlMenu)
}

func (e *htmlMenu) Text(v any) HTMLMenu {
	return e.Body(Text(v))
}

func (e *htmlMenu) Textf(format string, v ...any) HTMLMenu {
	return e.Body(Textf(format, v...))
}

func (e *htmlMenu) AccessKey(format string, v ...any) HTMLMenu {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMenu) Aria(k string, v any) HTMLMenu {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMenu) Attr(n string, v any) HTMLMenu {
	e.setAttr(n, v)
	return e
}

func (e *htmlMenu) Class(v ...string) HTMLMenu {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMenu) ContentEditable(v bool) HTMLMenu {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMenu) DataSet(k string, v any) HTMLMenu {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMenu) DataSets(ds map[string]any) HTMLMenu {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMenu) Dir(format string, v ...any) HTMLMenu {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMenu) Draggable(v bool) HTMLMenu {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMenu) Hidden(v bool) HTMLMenu {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMenu) ID(format string, v ...any) HTMLMenu {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMenu) Lang(format string, v ...any) HTMLMenu {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMenu) Role(format string, v ...any) HTMLMenu {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMenu) Spellcheck(v bool) HTMLMenu {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMenu) Style(k, format string, v ...any) HTMLMenu {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMenu) Styles(s map[string]string) HTMLMenu {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMenu) TabIndex(v int) HTMLMenu {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMenu) Title(format string, v ...any) HTMLMenu {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMenu) On(event string, h EventHandler, options ...EventOption) HTMLMenu {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMenu) OnBlur(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("blur", h, options...)
}

func (e *htmlMenu) OnChange(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("change", h, options...)
}

func (e *htmlMenu) OnClick(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("click", h, options...)
}

func (e *htmlMenu) OnContextMenu(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("contextmenu", h, options...)
}

func (e *htmlMenu) OnCopy(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("copy", h, options...)
}

func (e *htmlMenu) OnCut(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("cut", h, options...)
}

func (e *htmlMenu) OnDblClick(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dblclick", h, options...)
}

func (e *htmlMenu) OnDrag(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("drag", h, options...)
}

func (e *htmlMenu) OnDragEnd(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dragend", h, options...)
}

func (e *htmlMenu) OnDragEnter(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dragenter", h, options...)
}

func (e *htmlMenu) OnDragLeave(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dragleave", h, options...)
}

func (e *htmlMenu) OnDragOver(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dragover", h, options...)
}

func (e *htmlMenu) OnDragStart(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("dragstart", h, options...)
}

func (e *htmlMenu) OnDrop(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("drop", h, options...)
}

func (e *htmlMenu) OnFocus(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("focus", h, options...)
}

func (e *htmlMenu) OnInput(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("input", h, options...)
}

func (e *htmlMenu) OnInvalid(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("invalid", h, options...)
}

func (e *htmlMenu) OnKeyDown(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("keydown", h, options...)
}

func (e *htmlMenu) OnKeyPress(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("keypress", h, options...)
}

func (e *htmlMenu) OnKeyUp(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("keyup", h, options...)
}

func (e *htmlMenu) OnMouseDown(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mousedown", h, options...)
}

func (e *htmlMenu) OnMouseEnter(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mouseenter", h, options...)
}

func (e *htmlMenu) OnMouseLeave(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mouseleave", h, options...)
}

func (e *htmlMenu) OnMouseMove(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mousemove", h, options...)
}

func (e *htmlMenu) OnMouseOut(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mouseout", h, options...)
}

func (e *htmlMenu) OnMouseOver(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mouseover", h, options...)
}

func (e *htmlMenu) OnMouseUp(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("mouseup", h, options...)
}

func (e *htmlMenu) OnPaste(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("paste", h, options...)
}

func (e *htmlMenu) OnReset(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("reset", h, options...)
}

func (e *htmlMenu) OnScroll(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("scroll", h, options...)
}

func (e *htmlMenu) OnSearch(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("search", h, options...)
}

func (e *htmlMenu) OnSelect(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("select", h, options...)
}

func (e *htmlMenu) OnSubmit(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("submit", h, options...)
}

func (e *htmlMenu) OnWheel(h EventHandler, options ...EventOption) HTMLMenu {
	return e.On("wheel", h, options...)
}

func (e *htmlMenu) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMenu) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMenu) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMenu) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMenu) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMenu) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "meta" HTML element.
type HTMLMeta interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMeta

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMeta

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMeta

	// Specifies the character encoding for the linked document or external resource.
	Charset(format string, v ...any) HTMLMeta

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMeta

	// Specifies metadata content for the `http-equiv` or `name` attributes, often used in meta tags.
	Content(format string, v ...any) HTMLMeta

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMeta

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMeta

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMeta

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMeta

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMeta

	// Supplies an HTTP header for the content attribute, often used for refresh rates or setting a default charset.
	HTTPEquiv(format string, v ...any) HTMLMeta

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMeta

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMeta

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMeta

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLMeta

	// Defines the property name of the element.
	Property(format string, v ...any) HTMLMeta

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMeta

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMeta

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMeta

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMeta

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMeta

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMeta

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMeta
}

// Returns an HTML element that provides metadata about the HTML document.
func Meta() HTMLMeta {
	e := &htmlMeta{
		htmlElement: htmlElement{
			tag:           "meta",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlMeta struct {
	htmlElement
}

func (e *htmlMeta) AccessKey(format string, v ...any) HTMLMeta {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Aria(k string, v any) HTMLMeta {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMeta) Attr(n string, v any) HTMLMeta {
	e.setAttr(n, v)
	return e
}

func (e *htmlMeta) Charset(format string, v ...any) HTMLMeta {
	e.setAttr("charset", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Class(v ...string) HTMLMeta {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMeta) Content(format string, v ...any) HTMLMeta {
	e.setAttr("content", FormatString(format, v...))
	return e
}

func (e *htmlMeta) ContentEditable(v bool) HTMLMeta {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMeta) DataSet(k string, v any) HTMLMeta {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMeta) DataSets(ds map[string]any) HTMLMeta {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMeta) Dir(format string, v ...any) HTMLMeta {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Draggable(v bool) HTMLMeta {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMeta) HTTPEquiv(format string, v ...any) HTMLMeta {
	e.setAttr("http-equiv", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Hidden(v bool) HTMLMeta {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMeta) ID(format string, v ...any) HTMLMeta {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Lang(format string, v ...any) HTMLMeta {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Name(format string, v ...any) HTMLMeta {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Property(format string, v ...any) HTMLMeta {
	e.setAttr("property", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Role(format string, v ...any) HTMLMeta {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMeta) Spellcheck(v bool) HTMLMeta {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMeta) Style(k, format string, v ...any) HTMLMeta {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMeta) Styles(s map[string]string) HTMLMeta {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMeta) TabIndex(v int) HTMLMeta {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMeta) Title(format string, v ...any) HTMLMeta {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMeta) On(event string, h EventHandler, options ...EventOption) HTMLMeta {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMeta) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMeta) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMeta) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMeta) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMeta) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMeta) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "meter" HTML element.
type HTMLMeter interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLMeter

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLMeter

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLMeter

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLMeter

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLMeter

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLMeter

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLMeter

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLMeter

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLMeter

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLMeter

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLMeter

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLMeter

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLMeter

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLMeter

	// Defines the value threshold considered as 'high' in a range context.
	High(v float64) HTMLMeter

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLMeter

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLMeter

	// Sets the value threshold regarded as 'low' in a range context.
	Low(v float64) HTMLMeter

	// Establishes the maximum permissible value.
	Max(v any) HTMLMeter

	// Establishes the minimum permissible value.
	Min(v any) HTMLMeter

	// Sets the optimal numeric value for a gauge element.
	Optimum(v float64) HTMLMeter

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLMeter

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLMeter

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLMeter

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLMeter

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLMeter

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLMeter

	// Assigns a value to the element.
	Value(v any) HTMLMeter

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLMeter

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLMeter

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLMeter

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLMeter

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLMeter
}

// Returns an HTML element that represents a scalar measurement within a known range (like a gauge).
func Meter() HTMLMeter {
	e := &htmlMeter{
		htmlElement: htmlElement{
			tag:           "meter",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlMeter struct {
	htmlElement
}

func (e *htmlMeter) Body(v ...UI) HTMLMeter {
	return e.setBody(FilterUIElems(v...)).(*htmlMeter)
}

func (e *htmlMeter) Text(v any) HTMLMeter {
	return e.Body(Text(v))
}

func (e *htmlMeter) Textf(format string, v ...any) HTMLMeter {
	return e.Body(Textf(format, v...))
}

func (e *htmlMeter) AccessKey(format string, v ...any) HTMLMeter {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Aria(k string, v any) HTMLMeter {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMeter) Attr(n string, v any) HTMLMeter {
	e.setAttr(n, v)
	return e
}

func (e *htmlMeter) Class(v ...string) HTMLMeter {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlMeter) ContentEditable(v bool) HTMLMeter {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlMeter) DataSet(k string, v any) HTMLMeter {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlMeter) DataSets(ds map[string]any) HTMLMeter {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlMeter) Dir(format string, v ...any) HTMLMeter {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Draggable(v bool) HTMLMeter {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlMeter) Form(format string, v ...any) HTMLMeter {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Hidden(v bool) HTMLMeter {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlMeter) High(v float64) HTMLMeter {
	e.setAttr("high", v)
	return e
}

func (e *htmlMeter) ID(format string, v ...any) HTMLMeter {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Lang(format string, v ...any) HTMLMeter {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Low(v float64) HTMLMeter {
	e.setAttr("low", v)
	return e
}

func (e *htmlMeter) Max(v any) HTMLMeter {
	e.setAttr("max", v)
	return e
}

func (e *htmlMeter) Min(v any) HTMLMeter {
	e.setAttr("min", v)
	return e
}

func (e *htmlMeter) Optimum(v float64) HTMLMeter {
	e.setAttr("optimum", v)
	return e
}

func (e *htmlMeter) Role(format string, v ...any) HTMLMeter {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Spellcheck(v bool) HTMLMeter {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlMeter) Style(k, format string, v ...any) HTMLMeter {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlMeter) Styles(s map[string]string) HTMLMeter {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlMeter) TabIndex(v int) HTMLMeter {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlMeter) Title(format string, v ...any) HTMLMeter {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlMeter) Value(v any) HTMLMeter {
	e.setAttr("value", v)
	return e
}

func (e *htmlMeter) On(event string, h EventHandler, options ...EventOption) HTMLMeter {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlMeter) OnBlur(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("blur", h, options...)
}

func (e *htmlMeter) OnChange(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("change", h, options...)
}

func (e *htmlMeter) OnClick(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("click", h, options...)
}

func (e *htmlMeter) OnContextMenu(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("contextmenu", h, options...)
}

func (e *htmlMeter) OnCopy(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("copy", h, options...)
}

func (e *htmlMeter) OnCut(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("cut", h, options...)
}

func (e *htmlMeter) OnDblClick(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dblclick", h, options...)
}

func (e *htmlMeter) OnDrag(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("drag", h, options...)
}

func (e *htmlMeter) OnDragEnd(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dragend", h, options...)
}

func (e *htmlMeter) OnDragEnter(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dragenter", h, options...)
}

func (e *htmlMeter) OnDragLeave(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dragleave", h, options...)
}

func (e *htmlMeter) OnDragOver(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dragover", h, options...)
}

func (e *htmlMeter) OnDragStart(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("dragstart", h, options...)
}

func (e *htmlMeter) OnDrop(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("drop", h, options...)
}

func (e *htmlMeter) OnFocus(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("focus", h, options...)
}

func (e *htmlMeter) OnInput(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("input", h, options...)
}

func (e *htmlMeter) OnInvalid(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("invalid", h, options...)
}

func (e *htmlMeter) OnKeyDown(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("keydown", h, options...)
}

func (e *htmlMeter) OnKeyPress(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("keypress", h, options...)
}

func (e *htmlMeter) OnKeyUp(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("keyup", h, options...)
}

func (e *htmlMeter) OnMouseDown(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mousedown", h, options...)
}

func (e *htmlMeter) OnMouseEnter(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mouseenter", h, options...)
}

func (e *htmlMeter) OnMouseLeave(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mouseleave", h, options...)
}

func (e *htmlMeter) OnMouseMove(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mousemove", h, options...)
}

func (e *htmlMeter) OnMouseOut(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mouseout", h, options...)
}

func (e *htmlMeter) OnMouseOver(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mouseover", h, options...)
}

func (e *htmlMeter) OnMouseUp(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("mouseup", h, options...)
}

func (e *htmlMeter) OnPaste(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("paste", h, options...)
}

func (e *htmlMeter) OnReset(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("reset", h, options...)
}

func (e *htmlMeter) OnScroll(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("scroll", h, options...)
}

func (e *htmlMeter) OnSearch(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("search", h, options...)
}

func (e *htmlMeter) OnSelect(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("select", h, options...)
}

func (e *htmlMeter) OnSubmit(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("submit", h, options...)
}

func (e *htmlMeter) OnWheel(h EventHandler, options ...EventOption) HTMLMeter {
	return e.On("wheel", h, options...)
}

func (e *htmlMeter) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlMeter) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlMeter) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlMeter) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlMeter) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlMeter) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "nav" HTML element.
type HTMLNav interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLNav

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLNav

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLNav

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLNav

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLNav

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLNav

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLNav

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLNav

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLNav

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLNav

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLNav

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLNav

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLNav

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLNav

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLNav

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLNav

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLNav

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLNav

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLNav

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLNav

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLNav

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLNav

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLNav

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLNav

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLNav

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLNav

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLNav

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLNav

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLNav

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLNav

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLNav

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLNav

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLNav

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLNav

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLNav

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLNav
}

// Returns an HTML element that represents navigation links.
func Nav() HTMLNav {
	e := &htmlNav{
		htmlElement: htmlElement{
			tag:           "nav",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlNav struct {
	htmlElement
}

func (e *htmlNav) Body(v ...UI) HTMLNav {
	return e.setBody(FilterUIElems(v...)).(*htmlNav)
}

func (e *htmlNav) Text(v any) HTMLNav {
	return e.Body(Text(v))
}

func (e *htmlNav) Textf(format string, v ...any) HTMLNav {
	return e.Body(Textf(format, v...))
}

func (e *htmlNav) AccessKey(format string, v ...any) HTMLNav {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlNav) Aria(k string, v any) HTMLNav {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlNav) Attr(n string, v any) HTMLNav {
	e.setAttr(n, v)
	return e
}

func (e *htmlNav) Class(v ...string) HTMLNav {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlNav) ContentEditable(v bool) HTMLNav {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlNav) DataSet(k string, v any) HTMLNav {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlNav) DataSets(ds map[string]any) HTMLNav {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlNav) Dir(format string, v ...any) HTMLNav {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlNav) Draggable(v bool) HTMLNav {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlNav) Hidden(v bool) HTMLNav {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlNav) ID(format string, v ...any) HTMLNav {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlNav) Lang(format string, v ...any) HTMLNav {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlNav) Role(format string, v ...any) HTMLNav {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlNav) Spellcheck(v bool) HTMLNav {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlNav) Style(k, format string, v ...any) HTMLNav {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlNav) Styles(s map[string]string) HTMLNav {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlNav) TabIndex(v int) HTMLNav {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlNav) Title(format string, v ...any) HTMLNav {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlNav) On(event string, h EventHandler, options ...EventOption) HTMLNav {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlNav) OnBlur(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("blur", h, options...)
}

func (e *htmlNav) OnChange(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("change", h, options...)
}

func (e *htmlNav) OnClick(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("click", h, options...)
}

func (e *htmlNav) OnContextMenu(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("contextmenu", h, options...)
}

func (e *htmlNav) OnCopy(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("copy", h, options...)
}

func (e *htmlNav) OnCut(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("cut", h, options...)
}

func (e *htmlNav) OnDblClick(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dblclick", h, options...)
}

func (e *htmlNav) OnDrag(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("drag", h, options...)
}

func (e *htmlNav) OnDragEnd(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dragend", h, options...)
}

func (e *htmlNav) OnDragEnter(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dragenter", h, options...)
}

func (e *htmlNav) OnDragLeave(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dragleave", h, options...)
}

func (e *htmlNav) OnDragOver(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dragover", h, options...)
}

func (e *htmlNav) OnDragStart(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("dragstart", h, options...)
}

func (e *htmlNav) OnDrop(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("drop", h, options...)
}

func (e *htmlNav) OnFocus(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("focus", h, options...)
}

func (e *htmlNav) OnInput(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("input", h, options...)
}

func (e *htmlNav) OnInvalid(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("invalid", h, options...)
}

func (e *htmlNav) OnKeyDown(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("keydown", h, options...)
}

func (e *htmlNav) OnKeyPress(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("keypress", h, options...)
}

func (e *htmlNav) OnKeyUp(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("keyup", h, options...)
}

func (e *htmlNav) OnMouseDown(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mousedown", h, options...)
}

func (e *htmlNav) OnMouseEnter(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mouseenter", h, options...)
}

func (e *htmlNav) OnMouseLeave(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mouseleave", h, options...)
}

func (e *htmlNav) OnMouseMove(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mousemove", h, options...)
}

func (e *htmlNav) OnMouseOut(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mouseout", h, options...)
}

func (e *htmlNav) OnMouseOver(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mouseover", h, options...)
}

func (e *htmlNav) OnMouseUp(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("mouseup", h, options...)
}

func (e *htmlNav) OnPaste(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("paste", h, options...)
}

func (e *htmlNav) OnReset(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("reset", h, options...)
}

func (e *htmlNav) OnScroll(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("scroll", h, options...)
}

func (e *htmlNav) OnSearch(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("search", h, options...)
}

func (e *htmlNav) OnSelect(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("select", h, options...)
}

func (e *htmlNav) OnSubmit(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("submit", h, options...)
}

func (e *htmlNav) OnWheel(h EventHandler, options ...EventOption) HTMLNav {
	return e.On("wheel", h, options...)
}

func (e *htmlNav) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlNav) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlNav) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlNav) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlNav) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlNav) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "noscript" HTML element.
type HTMLNoScript interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLNoScript

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLNoScript

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLNoScript

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLNoScript

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLNoScript

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLNoScript

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLNoScript

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLNoScript

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLNoScript

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLNoScript

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLNoScript

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLNoScript

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLNoScript

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLNoScript

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLNoScript

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLNoScript

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLNoScript

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLNoScript

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLNoScript

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLNoScript

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLNoScript

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLNoScript
}

// Returns an HTML element that provides alternate content for users who do not support client-side scripts.
func NoScript() HTMLNoScript {
	e := &htmlNoScript{
		htmlElement: htmlElement{
			tag:           "noscript",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlNoScript struct {
	htmlElement
}

func (e *htmlNoScript) Body(v ...UI) HTMLNoScript {
	return e.setBody(FilterUIElems(v...)).(*htmlNoScript)
}

func (e *htmlNoScript) Text(v any) HTMLNoScript {
	return e.Body(Text(v))
}

func (e *htmlNoScript) Textf(format string, v ...any) HTMLNoScript {
	return e.Body(Textf(format, v...))
}

func (e *htmlNoScript) AccessKey(format string, v ...any) HTMLNoScript {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Aria(k string, v any) HTMLNoScript {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlNoScript) Attr(n string, v any) HTMLNoScript {
	e.setAttr(n, v)
	return e
}

func (e *htmlNoScript) Class(v ...string) HTMLNoScript {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlNoScript) ContentEditable(v bool) HTMLNoScript {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlNoScript) DataSet(k string, v any) HTMLNoScript {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlNoScript) DataSets(ds map[string]any) HTMLNoScript {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlNoScript) Dir(format string, v ...any) HTMLNoScript {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Draggable(v bool) HTMLNoScript {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlNoScript) Hidden(v bool) HTMLNoScript {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlNoScript) ID(format string, v ...any) HTMLNoScript {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Lang(format string, v ...any) HTMLNoScript {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Role(format string, v ...any) HTMLNoScript {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Spellcheck(v bool) HTMLNoScript {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlNoScript) Style(k, format string, v ...any) HTMLNoScript {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlNoScript) Styles(s map[string]string) HTMLNoScript {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlNoScript) TabIndex(v int) HTMLNoScript {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlNoScript) Title(format string, v ...any) HTMLNoScript {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlNoScript) On(event string, h EventHandler, options ...EventOption) HTMLNoScript {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlNoScript) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlNoScript) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlNoScript) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlNoScript) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlNoScript) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlNoScript) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "object" HTML element.
type HTMLObject interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLObject

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLObject

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLObject

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLObject

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLObject

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLObject

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLObject

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLObject

	// Specifies the URL of a resource associated with an embedded object, such as media or data.
	Data(format string, v ...any) HTMLObject

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLObject

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLObject

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLObject

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLObject

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLObject

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLObject

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLObject

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLObject

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLObject

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLObject

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLObject

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLObject

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLObject

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLObject

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLObject

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLObject

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLObject

	// Associates the element with a client-side image map. Can be called with the designated format and values.
	UseMap(format string, v ...any) HTMLObject

	// Sets the width of the element.
	Width(v int) HTMLObject

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when media loading is aborted.
	OnAbort(h EventHandler, options ...EventOption) HTMLObject

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler when media has buffered sufficiently to begin playback.
	OnCanPlay(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when media can be played through without buffering interruptions.
	OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler upon cue changes within a track element.
	OnCueChange(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLObject

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler when the media's duration changes.
	OnDurationChange(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when media unexpectedly becomes unavailable.
	OnEmptied(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when media playback reaches the end.
	OnEnded(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLObject

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLObject

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when media loading commences.
	OnLoadStart(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler as media data finishes loading.
	OnLoadedData(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when metadata (like duration and dimensions) are fully loaded.
	OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLObject

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLObject

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler when media playback is paused.
	OnPause(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when media starts its playback.
	OnPlay(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler once the media has initiated playback.
	OnPlaying(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler while the browser fetches media data.
	OnProgress(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when playback rate changes (e.g., slow motion or fast forward).
	OnRateChange(h EventHandler, options ...EventOption) HTMLObject

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler post seeking completion.
	OnSeeked(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler during the seeking process.
	OnSeeking(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler when media data fetching stalls.
	OnStalled(h EventHandler, options ...EventOption) HTMLObject

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when media data fetching is suspended.
	OnSuspend(h EventHandler, options ...EventOption) HTMLObject

	// Executes the handler when the media's playback position changes.
	OnTimeUpdate(h EventHandler, options ...EventOption) HTMLObject

	// Invokes the handler upon volume changes or muting.
	OnVolumeChange(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the handler when media pauses, awaiting further buffering.
	OnWaiting(h EventHandler, options ...EventOption) HTMLObject

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLObject
}

// Returns an HTML element that embeds an object within the document.
func Object() HTMLObject {
	e := &htmlObject{
		htmlElement: htmlElement{
			tag:           "object",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlObject struct {
	htmlElement
}

func (e *htmlObject) Body(v ...UI) HTMLObject {
	return e.setBody(FilterUIElems(v...)).(*htmlObject)
}

func (e *htmlObject) Text(v any) HTMLObject {
	return e.Body(Text(v))
}

func (e *htmlObject) Textf(format string, v ...any) HTMLObject {
	return e.Body(Textf(format, v...))
}

func (e *htmlObject) AccessKey(format string, v ...any) HTMLObject {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlObject) Aria(k string, v any) HTMLObject {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlObject) Attr(n string, v any) HTMLObject {
	e.setAttr(n, v)
	return e
}

func (e *htmlObject) Class(v ...string) HTMLObject {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlObject) ContentEditable(v bool) HTMLObject {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlObject) Data(format string, v ...any) HTMLObject {
	e.setAttr("data", FormatString(format, v...))
	return e
}

func (e *htmlObject) DataSet(k string, v any) HTMLObject {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlObject) DataSets(ds map[string]any) HTMLObject {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlObject) Dir(format string, v ...any) HTMLObject {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlObject) Draggable(v bool) HTMLObject {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlObject) Form(format string, v ...any) HTMLObject {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlObject) Height(v int) HTMLObject {
	e.setAttr("height", v)
	return e
}

func (e *htmlObject) Hidden(v bool) HTMLObject {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlObject) ID(format string, v ...any) HTMLObject {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlObject) Lang(format string, v ...any) HTMLObject {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlObject) Name(format string, v ...any) HTMLObject {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlObject) Role(format string, v ...any) HTMLObject {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlObject) Spellcheck(v bool) HTMLObject {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlObject) Style(k, format string, v ...any) HTMLObject {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlObject) Styles(s map[string]string) HTMLObject {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlObject) TabIndex(v int) HTMLObject {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlObject) Title(format string, v ...any) HTMLObject {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlObject) Type(format string, v ...any) HTMLObject {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlObject) UseMap(format string, v ...any) HTMLObject {
	e.setAttr("usemap", FormatString(format, v...))
	return e
}

func (e *htmlObject) Width(v int) HTMLObject {
	e.setAttr("width", v)
	return e
}

func (e *htmlObject) On(event string, h EventHandler, options ...EventOption) HTMLObject {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlObject) OnAbort(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("abort", h, options...)
}

func (e *htmlObject) OnBlur(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("blur", h, options...)
}

func (e *htmlObject) OnCanPlay(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("canplay", h, options...)
}

func (e *htmlObject) OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("canplaythrough", h, options...)
}

func (e *htmlObject) OnChange(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("change", h, options...)
}

func (e *htmlObject) OnClick(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("click", h, options...)
}

func (e *htmlObject) OnContextMenu(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("contextmenu", h, options...)
}

func (e *htmlObject) OnCopy(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("copy", h, options...)
}

func (e *htmlObject) OnCueChange(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("cuechange", h, options...)
}

func (e *htmlObject) OnCut(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("cut", h, options...)
}

func (e *htmlObject) OnDblClick(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dblclick", h, options...)
}

func (e *htmlObject) OnDrag(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("drag", h, options...)
}

func (e *htmlObject) OnDragEnd(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dragend", h, options...)
}

func (e *htmlObject) OnDragEnter(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dragenter", h, options...)
}

func (e *htmlObject) OnDragLeave(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dragleave", h, options...)
}

func (e *htmlObject) OnDragOver(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dragover", h, options...)
}

func (e *htmlObject) OnDragStart(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("dragstart", h, options...)
}

func (e *htmlObject) OnDrop(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("drop", h, options...)
}

func (e *htmlObject) OnDurationChange(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("durationchange", h, options...)
}

func (e *htmlObject) OnEmptied(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("emptied", h, options...)
}

func (e *htmlObject) OnEnded(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("ended", h, options...)
}

func (e *htmlObject) OnError(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("error", h, options...)
}

func (e *htmlObject) OnFocus(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("focus", h, options...)
}

func (e *htmlObject) OnInput(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("input", h, options...)
}

func (e *htmlObject) OnInvalid(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("invalid", h, options...)
}

func (e *htmlObject) OnKeyDown(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("keydown", h, options...)
}

func (e *htmlObject) OnKeyPress(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("keypress", h, options...)
}

func (e *htmlObject) OnKeyUp(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("keyup", h, options...)
}

func (e *htmlObject) OnLoadStart(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("loadstart", h, options...)
}

func (e *htmlObject) OnLoadedData(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("loadeddata", h, options...)
}

func (e *htmlObject) OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("loadedmetadata", h, options...)
}

func (e *htmlObject) OnMouseDown(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mousedown", h, options...)
}

func (e *htmlObject) OnMouseEnter(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mouseenter", h, options...)
}

func (e *htmlObject) OnMouseLeave(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mouseleave", h, options...)
}

func (e *htmlObject) OnMouseMove(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mousemove", h, options...)
}

func (e *htmlObject) OnMouseOut(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mouseout", h, options...)
}

func (e *htmlObject) OnMouseOver(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mouseover", h, options...)
}

func (e *htmlObject) OnMouseUp(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("mouseup", h, options...)
}

func (e *htmlObject) OnPaste(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("paste", h, options...)
}

func (e *htmlObject) OnPause(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("pause", h, options...)
}

func (e *htmlObject) OnPlay(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("play", h, options...)
}

func (e *htmlObject) OnPlaying(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("playing", h, options...)
}

func (e *htmlObject) OnProgress(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("progress", h, options...)
}

func (e *htmlObject) OnRateChange(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("ratechange", h, options...)
}

func (e *htmlObject) OnReset(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("reset", h, options...)
}

func (e *htmlObject) OnScroll(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("scroll", h, options...)
}

func (e *htmlObject) OnSearch(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("search", h, options...)
}

func (e *htmlObject) OnSeeked(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("seeked", h, options...)
}

func (e *htmlObject) OnSeeking(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("seeking", h, options...)
}

func (e *htmlObject) OnSelect(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("select", h, options...)
}

func (e *htmlObject) OnStalled(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("stalled", h, options...)
}

func (e *htmlObject) OnSubmit(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("submit", h, options...)
}

func (e *htmlObject) OnSuspend(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("suspend", h, options...)
}

func (e *htmlObject) OnTimeUpdate(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("timeupdate", h, options...)
}

func (e *htmlObject) OnVolumeChange(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("volumechange", h, options...)
}

func (e *htmlObject) OnWaiting(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("waiting", h, options...)
}

func (e *htmlObject) OnWheel(h EventHandler, options ...EventOption) HTMLObject {
	return e.On("wheel", h, options...)
}

func (e *htmlObject) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlObject) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlObject) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlObject) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlObject) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlObject) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "ol" HTML element.
type HTMLOl interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLOl

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLOl

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLOl

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLOl

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLOl

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLOl

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLOl

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLOl

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLOl

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLOl

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLOl

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLOl

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLOl

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLOl

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLOl

	// States that the list items should be displayed in descending order.
	Reversed(v bool) HTMLOl

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLOl

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLOl

	// Determines the starting number for an ordered list.
	Start(v int) HTMLOl

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLOl

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLOl

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLOl

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLOl

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLOl

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLOl

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLOl

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLOl

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLOl

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLOl

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLOl

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLOl

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLOl

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLOl

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLOl

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLOl

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLOl

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLOl

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLOl

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLOl
}

// Returns an HTML element that represents an ordered list.
func Ol() HTMLOl {
	e := &htmlOl{
		htmlElement: htmlElement{
			tag:           "ol",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlOl struct {
	htmlElement
}

func (e *htmlOl) Body(v ...UI) HTMLOl {
	return e.setBody(FilterUIElems(v...)).(*htmlOl)
}

func (e *htmlOl) Text(v any) HTMLOl {
	return e.Body(Text(v))
}

func (e *htmlOl) Textf(format string, v ...any) HTMLOl {
	return e.Body(Textf(format, v...))
}

func (e *htmlOl) AccessKey(format string, v ...any) HTMLOl {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlOl) Aria(k string, v any) HTMLOl {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOl) Attr(n string, v any) HTMLOl {
	e.setAttr(n, v)
	return e
}

func (e *htmlOl) Class(v ...string) HTMLOl {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlOl) ContentEditable(v bool) HTMLOl {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlOl) DataSet(k string, v any) HTMLOl {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOl) DataSets(ds map[string]any) HTMLOl {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlOl) Dir(format string, v ...any) HTMLOl {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlOl) Draggable(v bool) HTMLOl {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlOl) Hidden(v bool) HTMLOl {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlOl) ID(format string, v ...any) HTMLOl {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlOl) Lang(format string, v ...any) HTMLOl {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlOl) Reversed(v bool) HTMLOl {
	e.setAttr("reversed", v)
	return e
}

func (e *htmlOl) Role(format string, v ...any) HTMLOl {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlOl) Spellcheck(v bool) HTMLOl {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlOl) Start(v int) HTMLOl {
	e.setAttr("start", v)
	return e
}

func (e *htmlOl) Style(k, format string, v ...any) HTMLOl {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlOl) Styles(s map[string]string) HTMLOl {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlOl) TabIndex(v int) HTMLOl {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlOl) Title(format string, v ...any) HTMLOl {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlOl) Type(format string, v ...any) HTMLOl {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlOl) On(event string, h EventHandler, options ...EventOption) HTMLOl {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlOl) OnBlur(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("blur", h, options...)
}

func (e *htmlOl) OnChange(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("change", h, options...)
}

func (e *htmlOl) OnClick(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("click", h, options...)
}

func (e *htmlOl) OnContextMenu(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("contextmenu", h, options...)
}

func (e *htmlOl) OnCopy(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("copy", h, options...)
}

func (e *htmlOl) OnCut(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("cut", h, options...)
}

func (e *htmlOl) OnDblClick(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dblclick", h, options...)
}

func (e *htmlOl) OnDrag(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("drag", h, options...)
}

func (e *htmlOl) OnDragEnd(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dragend", h, options...)
}

func (e *htmlOl) OnDragEnter(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dragenter", h, options...)
}

func (e *htmlOl) OnDragLeave(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dragleave", h, options...)
}

func (e *htmlOl) OnDragOver(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dragover", h, options...)
}

func (e *htmlOl) OnDragStart(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("dragstart", h, options...)
}

func (e *htmlOl) OnDrop(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("drop", h, options...)
}

func (e *htmlOl) OnFocus(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("focus", h, options...)
}

func (e *htmlOl) OnInput(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("input", h, options...)
}

func (e *htmlOl) OnInvalid(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("invalid", h, options...)
}

func (e *htmlOl) OnKeyDown(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("keydown", h, options...)
}

func (e *htmlOl) OnKeyPress(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("keypress", h, options...)
}

func (e *htmlOl) OnKeyUp(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("keyup", h, options...)
}

func (e *htmlOl) OnMouseDown(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mousedown", h, options...)
}

func (e *htmlOl) OnMouseEnter(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mouseenter", h, options...)
}

func (e *htmlOl) OnMouseLeave(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mouseleave", h, options...)
}

func (e *htmlOl) OnMouseMove(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mousemove", h, options...)
}

func (e *htmlOl) OnMouseOut(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mouseout", h, options...)
}

func (e *htmlOl) OnMouseOver(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mouseover", h, options...)
}

func (e *htmlOl) OnMouseUp(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("mouseup", h, options...)
}

func (e *htmlOl) OnPaste(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("paste", h, options...)
}

func (e *htmlOl) OnReset(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("reset", h, options...)
}

func (e *htmlOl) OnScroll(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("scroll", h, options...)
}

func (e *htmlOl) OnSearch(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("search", h, options...)
}

func (e *htmlOl) OnSelect(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("select", h, options...)
}

func (e *htmlOl) OnSubmit(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("submit", h, options...)
}

func (e *htmlOl) OnWheel(h EventHandler, options ...EventOption) HTMLOl {
	return e.On("wheel", h, options...)
}

func (e *htmlOl) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlOl) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlOl) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlOl) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlOl) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlOl) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "optgroup" HTML element.
type HTMLOptGroup interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLOptGroup

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLOptGroup

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLOptGroup

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLOptGroup

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLOptGroup

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLOptGroup

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLOptGroup

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLOptGroup

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLOptGroup

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLOptGroup

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLOptGroup

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLOptGroup

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLOptGroup

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLOptGroup

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLOptGroup

	// Provides a concise label for an option element.
	Label(format string, v ...any) HTMLOptGroup

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLOptGroup

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLOptGroup

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLOptGroup

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLOptGroup

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLOptGroup

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLOptGroup

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLOptGroup

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLOptGroup

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLOptGroup

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLOptGroup

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLOptGroup
}

// Returns an HTML element that groups related options in a drop-down list.
func OptGroup() HTMLOptGroup {
	e := &htmlOptGroup{
		htmlElement: htmlElement{
			tag:           "optgroup",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlOptGroup struct {
	htmlElement
}

func (e *htmlOptGroup) Body(v ...UI) HTMLOptGroup {
	return e.setBody(FilterUIElems(v...)).(*htmlOptGroup)
}

func (e *htmlOptGroup) Text(v any) HTMLOptGroup {
	return e.Body(Text(v))
}

func (e *htmlOptGroup) Textf(format string, v ...any) HTMLOptGroup {
	return e.Body(Textf(format, v...))
}

func (e *htmlOptGroup) AccessKey(format string, v ...any) HTMLOptGroup {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Aria(k string, v any) HTMLOptGroup {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOptGroup) Attr(n string, v any) HTMLOptGroup {
	e.setAttr(n, v)
	return e
}

func (e *htmlOptGroup) Class(v ...string) HTMLOptGroup {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlOptGroup) ContentEditable(v bool) HTMLOptGroup {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlOptGroup) DataSet(k string, v any) HTMLOptGroup {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOptGroup) DataSets(ds map[string]any) HTMLOptGroup {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlOptGroup) Dir(format string, v ...any) HTMLOptGroup {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Disabled(v bool) HTMLOptGroup {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlOptGroup) Draggable(v bool) HTMLOptGroup {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlOptGroup) Hidden(v bool) HTMLOptGroup {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlOptGroup) ID(format string, v ...any) HTMLOptGroup {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Label(format string, v ...any) HTMLOptGroup {
	e.setAttr("label", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Lang(format string, v ...any) HTMLOptGroup {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Role(format string, v ...any) HTMLOptGroup {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Spellcheck(v bool) HTMLOptGroup {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlOptGroup) Style(k, format string, v ...any) HTMLOptGroup {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) Styles(s map[string]string) HTMLOptGroup {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlOptGroup) TabIndex(v int) HTMLOptGroup {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlOptGroup) Title(format string, v ...any) HTMLOptGroup {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlOptGroup) On(event string, h EventHandler, options ...EventOption) HTMLOptGroup {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlOptGroup) OnBlur(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("blur", h, options...)
}

func (e *htmlOptGroup) OnChange(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("change", h, options...)
}

func (e *htmlOptGroup) OnClick(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("click", h, options...)
}

func (e *htmlOptGroup) OnContextMenu(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("contextmenu", h, options...)
}

func (e *htmlOptGroup) OnCopy(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("copy", h, options...)
}

func (e *htmlOptGroup) OnCut(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("cut", h, options...)
}

func (e *htmlOptGroup) OnDblClick(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dblclick", h, options...)
}

func (e *htmlOptGroup) OnDrag(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("drag", h, options...)
}

func (e *htmlOptGroup) OnDragEnd(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dragend", h, options...)
}

func (e *htmlOptGroup) OnDragEnter(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dragenter", h, options...)
}

func (e *htmlOptGroup) OnDragLeave(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dragleave", h, options...)
}

func (e *htmlOptGroup) OnDragOver(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dragover", h, options...)
}

func (e *htmlOptGroup) OnDragStart(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("dragstart", h, options...)
}

func (e *htmlOptGroup) OnDrop(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("drop", h, options...)
}

func (e *htmlOptGroup) OnFocus(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("focus", h, options...)
}

func (e *htmlOptGroup) OnInput(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("input", h, options...)
}

func (e *htmlOptGroup) OnInvalid(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("invalid", h, options...)
}

func (e *htmlOptGroup) OnKeyDown(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("keydown", h, options...)
}

func (e *htmlOptGroup) OnKeyPress(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("keypress", h, options...)
}

func (e *htmlOptGroup) OnKeyUp(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("keyup", h, options...)
}

func (e *htmlOptGroup) OnMouseDown(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mousedown", h, options...)
}

func (e *htmlOptGroup) OnMouseEnter(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mouseenter", h, options...)
}

func (e *htmlOptGroup) OnMouseLeave(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mouseleave", h, options...)
}

func (e *htmlOptGroup) OnMouseMove(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mousemove", h, options...)
}

func (e *htmlOptGroup) OnMouseOut(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mouseout", h, options...)
}

func (e *htmlOptGroup) OnMouseOver(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mouseover", h, options...)
}

func (e *htmlOptGroup) OnMouseUp(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("mouseup", h, options...)
}

func (e *htmlOptGroup) OnPaste(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("paste", h, options...)
}

func (e *htmlOptGroup) OnReset(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("reset", h, options...)
}

func (e *htmlOptGroup) OnScroll(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("scroll", h, options...)
}

func (e *htmlOptGroup) OnSearch(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("search", h, options...)
}

func (e *htmlOptGroup) OnSelect(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("select", h, options...)
}

func (e *htmlOptGroup) OnSubmit(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("submit", h, options...)
}

func (e *htmlOptGroup) OnWheel(h EventHandler, options ...EventOption) HTMLOptGroup {
	return e.On("wheel", h, options...)
}

func (e *htmlOptGroup) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlOptGroup) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlOptGroup) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlOptGroup) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlOptGroup) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlOptGroup) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "option" HTML element.
type HTMLOption interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLOption

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLOption

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLOption

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLOption

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLOption

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLOption

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLOption

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLOption

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLOption

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLOption

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLOption

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLOption

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLOption

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLOption

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLOption

	// Provides a concise label for an option element.
	Label(format string, v ...any) HTMLOption

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLOption

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLOption

	// Indicates that an option should be pre-selected when the page loads.
	Selected(v bool) HTMLOption

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLOption

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLOption

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLOption

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLOption

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLOption

	// Assigns a value to the element.
	Value(v any) HTMLOption

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLOption

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLOption

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLOption

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLOption

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLOption

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLOption

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLOption

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLOption

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLOption

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLOption

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLOption

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLOption

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLOption

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLOption

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLOption
}

// Returns an HTML element that represents an option in a drop-down list.
func Option() HTMLOption {
	e := &htmlOption{
		htmlElement: htmlElement{
			tag:           "option",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlOption struct {
	htmlElement
}

func (e *htmlOption) Body(v ...UI) HTMLOption {
	return e.setBody(FilterUIElems(v...)).(*htmlOption)
}

func (e *htmlOption) Text(v any) HTMLOption {
	return e.Body(Text(v))
}

func (e *htmlOption) Textf(format string, v ...any) HTMLOption {
	return e.Body(Textf(format, v...))
}

func (e *htmlOption) AccessKey(format string, v ...any) HTMLOption {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlOption) Aria(k string, v any) HTMLOption {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOption) Attr(n string, v any) HTMLOption {
	e.setAttr(n, v)
	return e
}

func (e *htmlOption) Class(v ...string) HTMLOption {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlOption) ContentEditable(v bool) HTMLOption {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlOption) DataSet(k string, v any) HTMLOption {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOption) DataSets(ds map[string]any) HTMLOption {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlOption) Dir(format string, v ...any) HTMLOption {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlOption) Disabled(v bool) HTMLOption {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlOption) Draggable(v bool) HTMLOption {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlOption) Hidden(v bool) HTMLOption {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlOption) ID(format string, v ...any) HTMLOption {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlOption) Label(format string, v ...any) HTMLOption {
	e.setAttr("label", FormatString(format, v...))
	return e
}

func (e *htmlOption) Lang(format string, v ...any) HTMLOption {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlOption) Role(format string, v ...any) HTMLOption {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlOption) Selected(v bool) HTMLOption {
	e.setAttr("selected", v)
	return e
}

func (e *htmlOption) Spellcheck(v bool) HTMLOption {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlOption) Style(k, format string, v ...any) HTMLOption {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlOption) Styles(s map[string]string) HTMLOption {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlOption) TabIndex(v int) HTMLOption {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlOption) Title(format string, v ...any) HTMLOption {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlOption) Value(v any) HTMLOption {
	e.setAttr("value", v)
	return e
}

func (e *htmlOption) On(event string, h EventHandler, options ...EventOption) HTMLOption {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlOption) OnBlur(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("blur", h, options...)
}

func (e *htmlOption) OnChange(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("change", h, options...)
}

func (e *htmlOption) OnClick(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("click", h, options...)
}

func (e *htmlOption) OnContextMenu(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("contextmenu", h, options...)
}

func (e *htmlOption) OnCopy(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("copy", h, options...)
}

func (e *htmlOption) OnCut(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("cut", h, options...)
}

func (e *htmlOption) OnDblClick(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dblclick", h, options...)
}

func (e *htmlOption) OnDrag(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("drag", h, options...)
}

func (e *htmlOption) OnDragEnd(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dragend", h, options...)
}

func (e *htmlOption) OnDragEnter(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dragenter", h, options...)
}

func (e *htmlOption) OnDragLeave(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dragleave", h, options...)
}

func (e *htmlOption) OnDragOver(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dragover", h, options...)
}

func (e *htmlOption) OnDragStart(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("dragstart", h, options...)
}

func (e *htmlOption) OnDrop(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("drop", h, options...)
}

func (e *htmlOption) OnFocus(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("focus", h, options...)
}

func (e *htmlOption) OnInput(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("input", h, options...)
}

func (e *htmlOption) OnInvalid(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("invalid", h, options...)
}

func (e *htmlOption) OnKeyDown(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("keydown", h, options...)
}

func (e *htmlOption) OnKeyPress(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("keypress", h, options...)
}

func (e *htmlOption) OnKeyUp(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("keyup", h, options...)
}

func (e *htmlOption) OnMouseDown(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mousedown", h, options...)
}

func (e *htmlOption) OnMouseEnter(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mouseenter", h, options...)
}

func (e *htmlOption) OnMouseLeave(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mouseleave", h, options...)
}

func (e *htmlOption) OnMouseMove(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mousemove", h, options...)
}

func (e *htmlOption) OnMouseOut(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mouseout", h, options...)
}

func (e *htmlOption) OnMouseOver(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mouseover", h, options...)
}

func (e *htmlOption) OnMouseUp(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("mouseup", h, options...)
}

func (e *htmlOption) OnPaste(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("paste", h, options...)
}

func (e *htmlOption) OnReset(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("reset", h, options...)
}

func (e *htmlOption) OnScroll(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("scroll", h, options...)
}

func (e *htmlOption) OnSearch(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("search", h, options...)
}

func (e *htmlOption) OnSelect(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("select", h, options...)
}

func (e *htmlOption) OnSubmit(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("submit", h, options...)
}

func (e *htmlOption) OnWheel(h EventHandler, options ...EventOption) HTMLOption {
	return e.On("wheel", h, options...)
}

func (e *htmlOption) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlOption) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlOption) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlOption) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlOption) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlOption) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "output" HTML element.
type HTMLOutput interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLOutput

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLOutput

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLOutput

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLOutput

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLOutput

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLOutput

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLOutput

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLOutput

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLOutput

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLOutput

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLOutput

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLOutput

	// Associates a label or calculation with specific form element(s).
	For(format string, v ...any) HTMLOutput

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLOutput

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLOutput

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLOutput

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLOutput

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLOutput

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLOutput

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLOutput

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLOutput

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLOutput

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLOutput

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLOutput

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLOutput

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLOutput

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLOutput

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLOutput

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLOutput
}

// Returns an HTML element that displays the result of a calculation or user action.
func Output() HTMLOutput {
	e := &htmlOutput{
		htmlElement: htmlElement{
			tag:           "output",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlOutput struct {
	htmlElement
}

func (e *htmlOutput) Body(v ...UI) HTMLOutput {
	return e.setBody(FilterUIElems(v...)).(*htmlOutput)
}

func (e *htmlOutput) Text(v any) HTMLOutput {
	return e.Body(Text(v))
}

func (e *htmlOutput) Textf(format string, v ...any) HTMLOutput {
	return e.Body(Textf(format, v...))
}

func (e *htmlOutput) AccessKey(format string, v ...any) HTMLOutput {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Aria(k string, v any) HTMLOutput {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOutput) Attr(n string, v any) HTMLOutput {
	e.setAttr(n, v)
	return e
}

func (e *htmlOutput) Class(v ...string) HTMLOutput {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlOutput) ContentEditable(v bool) HTMLOutput {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlOutput) DataSet(k string, v any) HTMLOutput {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlOutput) DataSets(ds map[string]any) HTMLOutput {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlOutput) Dir(format string, v ...any) HTMLOutput {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Draggable(v bool) HTMLOutput {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlOutput) For(format string, v ...any) HTMLOutput {
	e.setAttr("for", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Form(format string, v ...any) HTMLOutput {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Hidden(v bool) HTMLOutput {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlOutput) ID(format string, v ...any) HTMLOutput {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Lang(format string, v ...any) HTMLOutput {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Name(format string, v ...any) HTMLOutput {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Role(format string, v ...any) HTMLOutput {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlOutput) Spellcheck(v bool) HTMLOutput {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlOutput) Style(k, format string, v ...any) HTMLOutput {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlOutput) Styles(s map[string]string) HTMLOutput {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlOutput) TabIndex(v int) HTMLOutput {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlOutput) Title(format string, v ...any) HTMLOutput {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlOutput) On(event string, h EventHandler, options ...EventOption) HTMLOutput {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlOutput) OnBlur(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("blur", h, options...)
}

func (e *htmlOutput) OnChange(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("change", h, options...)
}

func (e *htmlOutput) OnClick(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("click", h, options...)
}

func (e *htmlOutput) OnContextMenu(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("contextmenu", h, options...)
}

func (e *htmlOutput) OnCopy(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("copy", h, options...)
}

func (e *htmlOutput) OnCut(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("cut", h, options...)
}

func (e *htmlOutput) OnDblClick(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dblclick", h, options...)
}

func (e *htmlOutput) OnDrag(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("drag", h, options...)
}

func (e *htmlOutput) OnDragEnd(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dragend", h, options...)
}

func (e *htmlOutput) OnDragEnter(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dragenter", h, options...)
}

func (e *htmlOutput) OnDragLeave(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dragleave", h, options...)
}

func (e *htmlOutput) OnDragOver(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dragover", h, options...)
}

func (e *htmlOutput) OnDragStart(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("dragstart", h, options...)
}

func (e *htmlOutput) OnDrop(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("drop", h, options...)
}

func (e *htmlOutput) OnFocus(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("focus", h, options...)
}

func (e *htmlOutput) OnInput(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("input", h, options...)
}

func (e *htmlOutput) OnInvalid(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("invalid", h, options...)
}

func (e *htmlOutput) OnKeyDown(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("keydown", h, options...)
}

func (e *htmlOutput) OnKeyPress(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("keypress", h, options...)
}

func (e *htmlOutput) OnKeyUp(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("keyup", h, options...)
}

func (e *htmlOutput) OnMouseDown(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mousedown", h, options...)
}

func (e *htmlOutput) OnMouseEnter(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mouseenter", h, options...)
}

func (e *htmlOutput) OnMouseLeave(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mouseleave", h, options...)
}

func (e *htmlOutput) OnMouseMove(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mousemove", h, options...)
}

func (e *htmlOutput) OnMouseOut(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mouseout", h, options...)
}

func (e *htmlOutput) OnMouseOver(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mouseover", h, options...)
}

func (e *htmlOutput) OnMouseUp(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("mouseup", h, options...)
}

func (e *htmlOutput) OnPaste(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("paste", h, options...)
}

func (e *htmlOutput) OnReset(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("reset", h, options...)
}

func (e *htmlOutput) OnScroll(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("scroll", h, options...)
}

func (e *htmlOutput) OnSearch(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("search", h, options...)
}

func (e *htmlOutput) OnSelect(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("select", h, options...)
}

func (e *htmlOutput) OnSubmit(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("submit", h, options...)
}

func (e *htmlOutput) OnWheel(h EventHandler, options ...EventOption) HTMLOutput {
	return e.On("wheel", h, options...)
}

func (e *htmlOutput) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlOutput) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlOutput) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlOutput) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlOutput) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlOutput) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "p" HTML element.
type HTMLP interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLP

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLP

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLP

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLP

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLP

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLP

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLP

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLP

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLP

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLP

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLP

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLP

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLP

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLP

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLP

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLP

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLP

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLP

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLP

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLP

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLP

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLP

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLP

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLP

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLP

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLP

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLP

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLP

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLP

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLP

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLP

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLP

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLP

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLP

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLP

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLP

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLP

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLP

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLP

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLP

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLP

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLP

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLP

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLP

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLP

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLP

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLP

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLP

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLP

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLP
}

// Returns an HTML element that represents a paragraph.
func P() HTMLP {
	e := &htmlP{
		htmlElement: htmlElement{
			tag:           "p",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlP struct {
	htmlElement
}

func (e *htmlP) Body(v ...UI) HTMLP {
	return e.setBody(FilterUIElems(v...)).(*htmlP)
}

func (e *htmlP) Text(v any) HTMLP {
	return e.Body(Text(v))
}

func (e *htmlP) Textf(format string, v ...any) HTMLP {
	return e.Body(Textf(format, v...))
}

func (e *htmlP) AccessKey(format string, v ...any) HTMLP {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlP) Aria(k string, v any) HTMLP {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlP) Attr(n string, v any) HTMLP {
	e.setAttr(n, v)
	return e
}

func (e *htmlP) Class(v ...string) HTMLP {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlP) ContentEditable(v bool) HTMLP {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlP) DataSet(k string, v any) HTMLP {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlP) DataSets(ds map[string]any) HTMLP {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlP) Dir(format string, v ...any) HTMLP {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlP) Draggable(v bool) HTMLP {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlP) Hidden(v bool) HTMLP {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlP) ID(format string, v ...any) HTMLP {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlP) Lang(format string, v ...any) HTMLP {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlP) Role(format string, v ...any) HTMLP {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlP) Spellcheck(v bool) HTMLP {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlP) Style(k, format string, v ...any) HTMLP {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlP) Styles(s map[string]string) HTMLP {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlP) TabIndex(v int) HTMLP {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlP) Title(format string, v ...any) HTMLP {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlP) On(event string, h EventHandler, options ...EventOption) HTMLP {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlP) OnBlur(h EventHandler, options ...EventOption) HTMLP {
	return e.On("blur", h, options...)
}

func (e *htmlP) OnChange(h EventHandler, options ...EventOption) HTMLP {
	return e.On("change", h, options...)
}

func (e *htmlP) OnClick(h EventHandler, options ...EventOption) HTMLP {
	return e.On("click", h, options...)
}

func (e *htmlP) OnContextMenu(h EventHandler, options ...EventOption) HTMLP {
	return e.On("contextmenu", h, options...)
}

func (e *htmlP) OnCopy(h EventHandler, options ...EventOption) HTMLP {
	return e.On("copy", h, options...)
}

func (e *htmlP) OnCut(h EventHandler, options ...EventOption) HTMLP {
	return e.On("cut", h, options...)
}

func (e *htmlP) OnDblClick(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dblclick", h, options...)
}

func (e *htmlP) OnDrag(h EventHandler, options ...EventOption) HTMLP {
	return e.On("drag", h, options...)
}

func (e *htmlP) OnDragEnd(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dragend", h, options...)
}

func (e *htmlP) OnDragEnter(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dragenter", h, options...)
}

func (e *htmlP) OnDragLeave(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dragleave", h, options...)
}

func (e *htmlP) OnDragOver(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dragover", h, options...)
}

func (e *htmlP) OnDragStart(h EventHandler, options ...EventOption) HTMLP {
	return e.On("dragstart", h, options...)
}

func (e *htmlP) OnDrop(h EventHandler, options ...EventOption) HTMLP {
	return e.On("drop", h, options...)
}

func (e *htmlP) OnFocus(h EventHandler, options ...EventOption) HTMLP {
	return e.On("focus", h, options...)
}

func (e *htmlP) OnInput(h EventHandler, options ...EventOption) HTMLP {
	return e.On("input", h, options...)
}

func (e *htmlP) OnInvalid(h EventHandler, options ...EventOption) HTMLP {
	return e.On("invalid", h, options...)
}

func (e *htmlP) OnKeyDown(h EventHandler, options ...EventOption) HTMLP {
	return e.On("keydown", h, options...)
}

func (e *htmlP) OnKeyPress(h EventHandler, options ...EventOption) HTMLP {
	return e.On("keypress", h, options...)
}

func (e *htmlP) OnKeyUp(h EventHandler, options ...EventOption) HTMLP {
	return e.On("keyup", h, options...)
}

func (e *htmlP) OnMouseDown(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mousedown", h, options...)
}

func (e *htmlP) OnMouseEnter(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mouseenter", h, options...)
}

func (e *htmlP) OnMouseLeave(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mouseleave", h, options...)
}

func (e *htmlP) OnMouseMove(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mousemove", h, options...)
}

func (e *htmlP) OnMouseOut(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mouseout", h, options...)
}

func (e *htmlP) OnMouseOver(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mouseover", h, options...)
}

func (e *htmlP) OnMouseUp(h EventHandler, options ...EventOption) HTMLP {
	return e.On("mouseup", h, options...)
}

func (e *htmlP) OnPaste(h EventHandler, options ...EventOption) HTMLP {
	return e.On("paste", h, options...)
}

func (e *htmlP) OnReset(h EventHandler, options ...EventOption) HTMLP {
	return e.On("reset", h, options...)
}

func (e *htmlP) OnScroll(h EventHandler, options ...EventOption) HTMLP {
	return e.On("scroll", h, options...)
}

func (e *htmlP) OnSearch(h EventHandler, options ...EventOption) HTMLP {
	return e.On("search", h, options...)
}

func (e *htmlP) OnSelect(h EventHandler, options ...EventOption) HTMLP {
	return e.On("select", h, options...)
}

func (e *htmlP) OnSubmit(h EventHandler, options ...EventOption) HTMLP {
	return e.On("submit", h, options...)
}

func (e *htmlP) OnWheel(h EventHandler, options ...EventOption) HTMLP {
	return e.On("wheel", h, options...)
}

func (e *htmlP) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlP) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlP) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlP) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlP) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlP) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "param" HTML element.
type HTMLParam interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLParam

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLParam

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLParam

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLParam

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLParam

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLParam

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLParam

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLParam

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLParam

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLParam

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLParam

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLParam

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLParam

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLParam

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLParam

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLParam

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLParam

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLParam

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLParam

	// Assigns a value to the element.
	Value(v any) HTMLParam

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLParam

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLParam

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLParam

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLParam

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLParam

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLParam

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLParam

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLParam

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLParam

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLParam

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLParam

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLParam

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLParam

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLParam

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLParam
}

// Returns an HTML element that defines a parameter for an embedded object.
func Param() HTMLParam {
	e := &htmlParam{
		htmlElement: htmlElement{
			tag:           "param",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlParam struct {
	htmlElement
}

func (e *htmlParam) AccessKey(format string, v ...any) HTMLParam {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlParam) Aria(k string, v any) HTMLParam {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlParam) Attr(n string, v any) HTMLParam {
	e.setAttr(n, v)
	return e
}

func (e *htmlParam) Class(v ...string) HTMLParam {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlParam) ContentEditable(v bool) HTMLParam {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlParam) DataSet(k string, v any) HTMLParam {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlParam) DataSets(ds map[string]any) HTMLParam {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlParam) Dir(format string, v ...any) HTMLParam {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlParam) Draggable(v bool) HTMLParam {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlParam) Hidden(v bool) HTMLParam {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlParam) ID(format string, v ...any) HTMLParam {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlParam) Lang(format string, v ...any) HTMLParam {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlParam) Name(format string, v ...any) HTMLParam {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlParam) Role(format string, v ...any) HTMLParam {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlParam) Spellcheck(v bool) HTMLParam {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlParam) Style(k, format string, v ...any) HTMLParam {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlParam) Styles(s map[string]string) HTMLParam {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlParam) TabIndex(v int) HTMLParam {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlParam) Title(format string, v ...any) HTMLParam {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlParam) Value(v any) HTMLParam {
	e.setAttr("value", v)
	return e
}

func (e *htmlParam) On(event string, h EventHandler, options ...EventOption) HTMLParam {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlParam) OnBlur(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("blur", h, options...)
}

func (e *htmlParam) OnChange(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("change", h, options...)
}

func (e *htmlParam) OnClick(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("click", h, options...)
}

func (e *htmlParam) OnContextMenu(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("contextmenu", h, options...)
}

func (e *htmlParam) OnCopy(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("copy", h, options...)
}

func (e *htmlParam) OnCut(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("cut", h, options...)
}

func (e *htmlParam) OnDblClick(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dblclick", h, options...)
}

func (e *htmlParam) OnDrag(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("drag", h, options...)
}

func (e *htmlParam) OnDragEnd(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dragend", h, options...)
}

func (e *htmlParam) OnDragEnter(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dragenter", h, options...)
}

func (e *htmlParam) OnDragLeave(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dragleave", h, options...)
}

func (e *htmlParam) OnDragOver(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dragover", h, options...)
}

func (e *htmlParam) OnDragStart(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("dragstart", h, options...)
}

func (e *htmlParam) OnDrop(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("drop", h, options...)
}

func (e *htmlParam) OnFocus(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("focus", h, options...)
}

func (e *htmlParam) OnInput(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("input", h, options...)
}

func (e *htmlParam) OnInvalid(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("invalid", h, options...)
}

func (e *htmlParam) OnKeyDown(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("keydown", h, options...)
}

func (e *htmlParam) OnKeyPress(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("keypress", h, options...)
}

func (e *htmlParam) OnKeyUp(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("keyup", h, options...)
}

func (e *htmlParam) OnMouseDown(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mousedown", h, options...)
}

func (e *htmlParam) OnMouseEnter(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mouseenter", h, options...)
}

func (e *htmlParam) OnMouseLeave(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mouseleave", h, options...)
}

func (e *htmlParam) OnMouseMove(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mousemove", h, options...)
}

func (e *htmlParam) OnMouseOut(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mouseout", h, options...)
}

func (e *htmlParam) OnMouseOver(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mouseover", h, options...)
}

func (e *htmlParam) OnMouseUp(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("mouseup", h, options...)
}

func (e *htmlParam) OnPaste(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("paste", h, options...)
}

func (e *htmlParam) OnReset(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("reset", h, options...)
}

func (e *htmlParam) OnScroll(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("scroll", h, options...)
}

func (e *htmlParam) OnSearch(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("search", h, options...)
}

func (e *htmlParam) OnSelect(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("select", h, options...)
}

func (e *htmlParam) OnSubmit(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("submit", h, options...)
}

func (e *htmlParam) OnWheel(h EventHandler, options ...EventOption) HTMLParam {
	return e.On("wheel", h, options...)
}

func (e *htmlParam) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlParam) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlParam) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlParam) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlParam) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlParam) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "picture" HTML element.
type HTMLPicture interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLPicture

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLPicture

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLPicture

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLPicture

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLPicture

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLPicture

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLPicture

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLPicture

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLPicture

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLPicture

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLPicture

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLPicture

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLPicture

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLPicture

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLPicture

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLPicture

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLPicture

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLPicture

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLPicture

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLPicture

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLPicture

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLPicture

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLPicture

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLPicture

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLPicture

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLPicture
}

// Returns an HTML element that provides a container for multiple image sources.
func Picture() HTMLPicture {
	e := &htmlPicture{
		htmlElement: htmlElement{
			tag:           "picture",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlPicture struct {
	htmlElement
}

func (e *htmlPicture) Body(v ...UI) HTMLPicture {
	return e.setBody(FilterUIElems(v...)).(*htmlPicture)
}

func (e *htmlPicture) Text(v any) HTMLPicture {
	return e.Body(Text(v))
}

func (e *htmlPicture) Textf(format string, v ...any) HTMLPicture {
	return e.Body(Textf(format, v...))
}

func (e *htmlPicture) AccessKey(format string, v ...any) HTMLPicture {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlPicture) Aria(k string, v any) HTMLPicture {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlPicture) Attr(n string, v any) HTMLPicture {
	e.setAttr(n, v)
	return e
}

func (e *htmlPicture) Class(v ...string) HTMLPicture {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlPicture) ContentEditable(v bool) HTMLPicture {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlPicture) DataSet(k string, v any) HTMLPicture {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlPicture) DataSets(ds map[string]any) HTMLPicture {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlPicture) Dir(format string, v ...any) HTMLPicture {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlPicture) Draggable(v bool) HTMLPicture {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlPicture) Hidden(v bool) HTMLPicture {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlPicture) ID(format string, v ...any) HTMLPicture {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlPicture) Lang(format string, v ...any) HTMLPicture {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlPicture) Role(format string, v ...any) HTMLPicture {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlPicture) Spellcheck(v bool) HTMLPicture {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlPicture) Style(k, format string, v ...any) HTMLPicture {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlPicture) Styles(s map[string]string) HTMLPicture {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlPicture) TabIndex(v int) HTMLPicture {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlPicture) Title(format string, v ...any) HTMLPicture {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlPicture) On(event string, h EventHandler, options ...EventOption) HTMLPicture {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlPicture) OnBlur(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("blur", h, options...)
}

func (e *htmlPicture) OnChange(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("change", h, options...)
}

func (e *htmlPicture) OnClick(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("click", h, options...)
}

func (e *htmlPicture) OnContextMenu(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("contextmenu", h, options...)
}

func (e *htmlPicture) OnCopy(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("copy", h, options...)
}

func (e *htmlPicture) OnCut(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("cut", h, options...)
}

func (e *htmlPicture) OnDblClick(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dblclick", h, options...)
}

func (e *htmlPicture) OnDrag(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("drag", h, options...)
}

func (e *htmlPicture) OnDragEnd(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dragend", h, options...)
}

func (e *htmlPicture) OnDragEnter(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dragenter", h, options...)
}

func (e *htmlPicture) OnDragLeave(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dragleave", h, options...)
}

func (e *htmlPicture) OnDragOver(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dragover", h, options...)
}

func (e *htmlPicture) OnDragStart(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("dragstart", h, options...)
}

func (e *htmlPicture) OnDrop(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("drop", h, options...)
}

func (e *htmlPicture) OnFocus(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("focus", h, options...)
}

func (e *htmlPicture) OnInput(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("input", h, options...)
}

func (e *htmlPicture) OnInvalid(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("invalid", h, options...)
}

func (e *htmlPicture) OnKeyDown(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("keydown", h, options...)
}

func (e *htmlPicture) OnKeyPress(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("keypress", h, options...)
}

func (e *htmlPicture) OnKeyUp(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("keyup", h, options...)
}

func (e *htmlPicture) OnMouseDown(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mousedown", h, options...)
}

func (e *htmlPicture) OnMouseEnter(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mouseenter", h, options...)
}

func (e *htmlPicture) OnMouseLeave(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mouseleave", h, options...)
}

func (e *htmlPicture) OnMouseMove(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mousemove", h, options...)
}

func (e *htmlPicture) OnMouseOut(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mouseout", h, options...)
}

func (e *htmlPicture) OnMouseOver(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mouseover", h, options...)
}

func (e *htmlPicture) OnMouseUp(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("mouseup", h, options...)
}

func (e *htmlPicture) OnPaste(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("paste", h, options...)
}

func (e *htmlPicture) OnReset(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("reset", h, options...)
}

func (e *htmlPicture) OnScroll(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("scroll", h, options...)
}

func (e *htmlPicture) OnSearch(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("search", h, options...)
}

func (e *htmlPicture) OnSelect(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("select", h, options...)
}

func (e *htmlPicture) OnSubmit(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("submit", h, options...)
}

func (e *htmlPicture) OnWheel(h EventHandler, options ...EventOption) HTMLPicture {
	return e.On("wheel", h, options...)
}

func (e *htmlPicture) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlPicture) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlPicture) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlPicture) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlPicture) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlPicture) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "pre" HTML element.
type HTMLPre interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLPre

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLPre

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLPre

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLPre

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLPre

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLPre

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLPre

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLPre

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLPre

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLPre

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLPre

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLPre

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLPre

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLPre

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLPre

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLPre

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLPre

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLPre

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLPre

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLPre

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLPre

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLPre

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLPre

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLPre

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLPre

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLPre

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLPre

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLPre

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLPre

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLPre

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLPre

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLPre

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLPre

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLPre

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLPre

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLPre
}

// Returns an HTML element that displays preformatted text.
func Pre() HTMLPre {
	e := &htmlPre{
		htmlElement: htmlElement{
			tag:           "pre",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlPre struct {
	htmlElement
}

func (e *htmlPre) Body(v ...UI) HTMLPre {
	return e.setBody(FilterUIElems(v...)).(*htmlPre)
}

func (e *htmlPre) Text(v any) HTMLPre {
	return e.Body(Text(v))
}

func (e *htmlPre) Textf(format string, v ...any) HTMLPre {
	return e.Body(Textf(format, v...))
}

func (e *htmlPre) AccessKey(format string, v ...any) HTMLPre {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlPre) Aria(k string, v any) HTMLPre {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlPre) Attr(n string, v any) HTMLPre {
	e.setAttr(n, v)
	return e
}

func (e *htmlPre) Class(v ...string) HTMLPre {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlPre) ContentEditable(v bool) HTMLPre {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlPre) DataSet(k string, v any) HTMLPre {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlPre) DataSets(ds map[string]any) HTMLPre {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlPre) Dir(format string, v ...any) HTMLPre {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlPre) Draggable(v bool) HTMLPre {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlPre) Hidden(v bool) HTMLPre {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlPre) ID(format string, v ...any) HTMLPre {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlPre) Lang(format string, v ...any) HTMLPre {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlPre) Role(format string, v ...any) HTMLPre {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlPre) Spellcheck(v bool) HTMLPre {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlPre) Style(k, format string, v ...any) HTMLPre {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlPre) Styles(s map[string]string) HTMLPre {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlPre) TabIndex(v int) HTMLPre {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlPre) Title(format string, v ...any) HTMLPre {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlPre) On(event string, h EventHandler, options ...EventOption) HTMLPre {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlPre) OnBlur(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("blur", h, options...)
}

func (e *htmlPre) OnChange(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("change", h, options...)
}

func (e *htmlPre) OnClick(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("click", h, options...)
}

func (e *htmlPre) OnContextMenu(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("contextmenu", h, options...)
}

func (e *htmlPre) OnCopy(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("copy", h, options...)
}

func (e *htmlPre) OnCut(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("cut", h, options...)
}

func (e *htmlPre) OnDblClick(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dblclick", h, options...)
}

func (e *htmlPre) OnDrag(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("drag", h, options...)
}

func (e *htmlPre) OnDragEnd(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dragend", h, options...)
}

func (e *htmlPre) OnDragEnter(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dragenter", h, options...)
}

func (e *htmlPre) OnDragLeave(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dragleave", h, options...)
}

func (e *htmlPre) OnDragOver(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dragover", h, options...)
}

func (e *htmlPre) OnDragStart(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("dragstart", h, options...)
}

func (e *htmlPre) OnDrop(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("drop", h, options...)
}

func (e *htmlPre) OnFocus(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("focus", h, options...)
}

func (e *htmlPre) OnInput(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("input", h, options...)
}

func (e *htmlPre) OnInvalid(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("invalid", h, options...)
}

func (e *htmlPre) OnKeyDown(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("keydown", h, options...)
}

func (e *htmlPre) OnKeyPress(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("keypress", h, options...)
}

func (e *htmlPre) OnKeyUp(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("keyup", h, options...)
}

func (e *htmlPre) OnMouseDown(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mousedown", h, options...)
}

func (e *htmlPre) OnMouseEnter(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mouseenter", h, options...)
}

func (e *htmlPre) OnMouseLeave(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mouseleave", h, options...)
}

func (e *htmlPre) OnMouseMove(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mousemove", h, options...)
}

func (e *htmlPre) OnMouseOut(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mouseout", h, options...)
}

func (e *htmlPre) OnMouseOver(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mouseover", h, options...)
}

func (e *htmlPre) OnMouseUp(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("mouseup", h, options...)
}

func (e *htmlPre) OnPaste(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("paste", h, options...)
}

func (e *htmlPre) OnReset(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("reset", h, options...)
}

func (e *htmlPre) OnScroll(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("scroll", h, options...)
}

func (e *htmlPre) OnSearch(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("search", h, options...)
}

func (e *htmlPre) OnSelect(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("select", h, options...)
}

func (e *htmlPre) OnSubmit(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("submit", h, options...)
}

func (e *htmlPre) OnWheel(h EventHandler, options ...EventOption) HTMLPre {
	return e.On("wheel", h, options...)
}

func (e *htmlPre) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlPre) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlPre) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlPre) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlPre) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlPre) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "progress" HTML element.
type HTMLProgress interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLProgress

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLProgress

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLProgress

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLProgress

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLProgress

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLProgress

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLProgress

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLProgress

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLProgress

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLProgress

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLProgress

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLProgress

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLProgress

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLProgress

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLProgress

	// Establishes the maximum permissible value.
	Max(v any) HTMLProgress

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLProgress

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLProgress

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLProgress

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLProgress

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLProgress

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLProgress

	// Assigns a value to the element.
	Value(v any) HTMLProgress

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLProgress

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLProgress

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLProgress

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLProgress

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLProgress
}

// Returns an HTML element that visualizes the progress of a task.
func Progress() HTMLProgress {
	e := &htmlProgress{
		htmlElement: htmlElement{
			tag:           "progress",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlProgress struct {
	htmlElement
}

func (e *htmlProgress) Body(v ...UI) HTMLProgress {
	return e.setBody(FilterUIElems(v...)).(*htmlProgress)
}

func (e *htmlProgress) Text(v any) HTMLProgress {
	return e.Body(Text(v))
}

func (e *htmlProgress) Textf(format string, v ...any) HTMLProgress {
	return e.Body(Textf(format, v...))
}

func (e *htmlProgress) AccessKey(format string, v ...any) HTMLProgress {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Aria(k string, v any) HTMLProgress {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlProgress) Attr(n string, v any) HTMLProgress {
	e.setAttr(n, v)
	return e
}

func (e *htmlProgress) Class(v ...string) HTMLProgress {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlProgress) ContentEditable(v bool) HTMLProgress {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlProgress) DataSet(k string, v any) HTMLProgress {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlProgress) DataSets(ds map[string]any) HTMLProgress {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlProgress) Dir(format string, v ...any) HTMLProgress {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Draggable(v bool) HTMLProgress {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlProgress) Hidden(v bool) HTMLProgress {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlProgress) ID(format string, v ...any) HTMLProgress {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Lang(format string, v ...any) HTMLProgress {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Max(v any) HTMLProgress {
	e.setAttr("max", v)
	return e
}

func (e *htmlProgress) Role(format string, v ...any) HTMLProgress {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Spellcheck(v bool) HTMLProgress {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlProgress) Style(k, format string, v ...any) HTMLProgress {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlProgress) Styles(s map[string]string) HTMLProgress {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlProgress) TabIndex(v int) HTMLProgress {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlProgress) Title(format string, v ...any) HTMLProgress {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlProgress) Value(v any) HTMLProgress {
	e.setAttr("value", v)
	return e
}

func (e *htmlProgress) On(event string, h EventHandler, options ...EventOption) HTMLProgress {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlProgress) OnBlur(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("blur", h, options...)
}

func (e *htmlProgress) OnChange(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("change", h, options...)
}

func (e *htmlProgress) OnClick(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("click", h, options...)
}

func (e *htmlProgress) OnContextMenu(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("contextmenu", h, options...)
}

func (e *htmlProgress) OnCopy(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("copy", h, options...)
}

func (e *htmlProgress) OnCut(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("cut", h, options...)
}

func (e *htmlProgress) OnDblClick(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dblclick", h, options...)
}

func (e *htmlProgress) OnDrag(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("drag", h, options...)
}

func (e *htmlProgress) OnDragEnd(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dragend", h, options...)
}

func (e *htmlProgress) OnDragEnter(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dragenter", h, options...)
}

func (e *htmlProgress) OnDragLeave(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dragleave", h, options...)
}

func (e *htmlProgress) OnDragOver(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dragover", h, options...)
}

func (e *htmlProgress) OnDragStart(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("dragstart", h, options...)
}

func (e *htmlProgress) OnDrop(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("drop", h, options...)
}

func (e *htmlProgress) OnFocus(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("focus", h, options...)
}

func (e *htmlProgress) OnInput(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("input", h, options...)
}

func (e *htmlProgress) OnInvalid(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("invalid", h, options...)
}

func (e *htmlProgress) OnKeyDown(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("keydown", h, options...)
}

func (e *htmlProgress) OnKeyPress(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("keypress", h, options...)
}

func (e *htmlProgress) OnKeyUp(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("keyup", h, options...)
}

func (e *htmlProgress) OnMouseDown(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mousedown", h, options...)
}

func (e *htmlProgress) OnMouseEnter(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mouseenter", h, options...)
}

func (e *htmlProgress) OnMouseLeave(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mouseleave", h, options...)
}

func (e *htmlProgress) OnMouseMove(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mousemove", h, options...)
}

func (e *htmlProgress) OnMouseOut(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mouseout", h, options...)
}

func (e *htmlProgress) OnMouseOver(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mouseover", h, options...)
}

func (e *htmlProgress) OnMouseUp(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("mouseup", h, options...)
}

func (e *htmlProgress) OnPaste(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("paste", h, options...)
}

func (e *htmlProgress) OnReset(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("reset", h, options...)
}

func (e *htmlProgress) OnScroll(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("scroll", h, options...)
}

func (e *htmlProgress) OnSearch(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("search", h, options...)
}

func (e *htmlProgress) OnSelect(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("select", h, options...)
}

func (e *htmlProgress) OnSubmit(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("submit", h, options...)
}

func (e *htmlProgress) OnWheel(h EventHandler, options ...EventOption) HTMLProgress {
	return e.On("wheel", h, options...)
}

func (e *htmlProgress) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlProgress) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlProgress) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlProgress) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlProgress) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlProgress) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "q" HTML element.
type HTMLQ interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLQ

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLQ

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLQ

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLQ

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLQ

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLQ

	// Provides a reference or link to a source explaining quoted or modified content in the element.
	Cite(format string, v ...any) HTMLQ

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLQ

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLQ

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLQ

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLQ

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLQ

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLQ

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLQ

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLQ

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLQ

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLQ

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLQ

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLQ

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLQ

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLQ

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLQ

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLQ

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLQ

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLQ

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLQ

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLQ

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLQ

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLQ

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLQ

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLQ

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLQ

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLQ

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLQ

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLQ

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLQ

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLQ
}

// Returns an HTML element that represents a short quotation.
func Q() HTMLQ {
	e := &htmlQ{
		htmlElement: htmlElement{
			tag:           "q",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlQ struct {
	htmlElement
}

func (e *htmlQ) Body(v ...UI) HTMLQ {
	return e.setBody(FilterUIElems(v...)).(*htmlQ)
}

func (e *htmlQ) Text(v any) HTMLQ {
	return e.Body(Text(v))
}

func (e *htmlQ) Textf(format string, v ...any) HTMLQ {
	return e.Body(Textf(format, v...))
}

func (e *htmlQ) AccessKey(format string, v ...any) HTMLQ {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlQ) Aria(k string, v any) HTMLQ {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlQ) Attr(n string, v any) HTMLQ {
	e.setAttr(n, v)
	return e
}

func (e *htmlQ) Cite(format string, v ...any) HTMLQ {
	e.setAttr("cite", FormatString(format, v...))
	return e
}

func (e *htmlQ) Class(v ...string) HTMLQ {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlQ) ContentEditable(v bool) HTMLQ {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlQ) DataSet(k string, v any) HTMLQ {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlQ) DataSets(ds map[string]any) HTMLQ {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlQ) Dir(format string, v ...any) HTMLQ {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlQ) Draggable(v bool) HTMLQ {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlQ) Hidden(v bool) HTMLQ {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlQ) ID(format string, v ...any) HTMLQ {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlQ) Lang(format string, v ...any) HTMLQ {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlQ) Role(format string, v ...any) HTMLQ {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlQ) Spellcheck(v bool) HTMLQ {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlQ) Style(k, format string, v ...any) HTMLQ {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlQ) Styles(s map[string]string) HTMLQ {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlQ) TabIndex(v int) HTMLQ {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlQ) Title(format string, v ...any) HTMLQ {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlQ) On(event string, h EventHandler, options ...EventOption) HTMLQ {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlQ) OnBlur(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("blur", h, options...)
}

func (e *htmlQ) OnChange(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("change", h, options...)
}

func (e *htmlQ) OnClick(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("click", h, options...)
}

func (e *htmlQ) OnContextMenu(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("contextmenu", h, options...)
}

func (e *htmlQ) OnCopy(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("copy", h, options...)
}

func (e *htmlQ) OnCut(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("cut", h, options...)
}

func (e *htmlQ) OnDblClick(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dblclick", h, options...)
}

func (e *htmlQ) OnDrag(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("drag", h, options...)
}

func (e *htmlQ) OnDragEnd(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dragend", h, options...)
}

func (e *htmlQ) OnDragEnter(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dragenter", h, options...)
}

func (e *htmlQ) OnDragLeave(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dragleave", h, options...)
}

func (e *htmlQ) OnDragOver(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dragover", h, options...)
}

func (e *htmlQ) OnDragStart(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("dragstart", h, options...)
}

func (e *htmlQ) OnDrop(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("drop", h, options...)
}

func (e *htmlQ) OnFocus(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("focus", h, options...)
}

func (e *htmlQ) OnInput(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("input", h, options...)
}

func (e *htmlQ) OnInvalid(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("invalid", h, options...)
}

func (e *htmlQ) OnKeyDown(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("keydown", h, options...)
}

func (e *htmlQ) OnKeyPress(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("keypress", h, options...)
}

func (e *htmlQ) OnKeyUp(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("keyup", h, options...)
}

func (e *htmlQ) OnMouseDown(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mousedown", h, options...)
}

func (e *htmlQ) OnMouseEnter(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mouseenter", h, options...)
}

func (e *htmlQ) OnMouseLeave(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mouseleave", h, options...)
}

func (e *htmlQ) OnMouseMove(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mousemove", h, options...)
}

func (e *htmlQ) OnMouseOut(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mouseout", h, options...)
}

func (e *htmlQ) OnMouseOver(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mouseover", h, options...)
}

func (e *htmlQ) OnMouseUp(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("mouseup", h, options...)
}

func (e *htmlQ) OnPaste(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("paste", h, options...)
}

func (e *htmlQ) OnReset(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("reset", h, options...)
}

func (e *htmlQ) OnScroll(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("scroll", h, options...)
}

func (e *htmlQ) OnSearch(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("search", h, options...)
}

func (e *htmlQ) OnSelect(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("select", h, options...)
}

func (e *htmlQ) OnSubmit(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("submit", h, options...)
}

func (e *htmlQ) OnWheel(h EventHandler, options ...EventOption) HTMLQ {
	return e.On("wheel", h, options...)
}

func (e *htmlQ) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlQ) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlQ) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlQ) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlQ) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlQ) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "rp" HTML element.
type HTMLRp interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLRp

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLRp

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLRp

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLRp

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLRp

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLRp

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLRp

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLRp

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLRp

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLRp

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLRp

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLRp

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLRp

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLRp

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLRp

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLRp

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLRp

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLRp

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLRp

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLRp

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLRp

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLRp

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLRp

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLRp

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLRp

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLRp

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLRp

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLRp

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLRp

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLRp

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLRp

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLRp

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLRp

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLRp

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLRp

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLRp
}

// Returns an HTML element that indicates text for browsers not supporting ruby annotations.
func Rp() HTMLRp {
	e := &htmlRp{
		htmlElement: htmlElement{
			tag:           "rp",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlRp struct {
	htmlElement
}

func (e *htmlRp) Body(v ...UI) HTMLRp {
	return e.setBody(FilterUIElems(v...)).(*htmlRp)
}

func (e *htmlRp) Text(v any) HTMLRp {
	return e.Body(Text(v))
}

func (e *htmlRp) Textf(format string, v ...any) HTMLRp {
	return e.Body(Textf(format, v...))
}

func (e *htmlRp) AccessKey(format string, v ...any) HTMLRp {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlRp) Aria(k string, v any) HTMLRp {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRp) Attr(n string, v any) HTMLRp {
	e.setAttr(n, v)
	return e
}

func (e *htmlRp) Class(v ...string) HTMLRp {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlRp) ContentEditable(v bool) HTMLRp {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlRp) DataSet(k string, v any) HTMLRp {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRp) DataSets(ds map[string]any) HTMLRp {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlRp) Dir(format string, v ...any) HTMLRp {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlRp) Draggable(v bool) HTMLRp {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlRp) Hidden(v bool) HTMLRp {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlRp) ID(format string, v ...any) HTMLRp {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlRp) Lang(format string, v ...any) HTMLRp {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlRp) Role(format string, v ...any) HTMLRp {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlRp) Spellcheck(v bool) HTMLRp {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlRp) Style(k, format string, v ...any) HTMLRp {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlRp) Styles(s map[string]string) HTMLRp {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlRp) TabIndex(v int) HTMLRp {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlRp) Title(format string, v ...any) HTMLRp {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlRp) On(event string, h EventHandler, options ...EventOption) HTMLRp {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlRp) OnBlur(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("blur", h, options...)
}

func (e *htmlRp) OnChange(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("change", h, options...)
}

func (e *htmlRp) OnClick(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("click", h, options...)
}

func (e *htmlRp) OnContextMenu(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("contextmenu", h, options...)
}

func (e *htmlRp) OnCopy(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("copy", h, options...)
}

func (e *htmlRp) OnCut(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("cut", h, options...)
}

func (e *htmlRp) OnDblClick(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dblclick", h, options...)
}

func (e *htmlRp) OnDrag(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("drag", h, options...)
}

func (e *htmlRp) OnDragEnd(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dragend", h, options...)
}

func (e *htmlRp) OnDragEnter(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dragenter", h, options...)
}

func (e *htmlRp) OnDragLeave(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dragleave", h, options...)
}

func (e *htmlRp) OnDragOver(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dragover", h, options...)
}

func (e *htmlRp) OnDragStart(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("dragstart", h, options...)
}

func (e *htmlRp) OnDrop(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("drop", h, options...)
}

func (e *htmlRp) OnFocus(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("focus", h, options...)
}

func (e *htmlRp) OnInput(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("input", h, options...)
}

func (e *htmlRp) OnInvalid(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("invalid", h, options...)
}

func (e *htmlRp) OnKeyDown(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("keydown", h, options...)
}

func (e *htmlRp) OnKeyPress(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("keypress", h, options...)
}

func (e *htmlRp) OnKeyUp(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("keyup", h, options...)
}

func (e *htmlRp) OnMouseDown(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mousedown", h, options...)
}

func (e *htmlRp) OnMouseEnter(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mouseenter", h, options...)
}

func (e *htmlRp) OnMouseLeave(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mouseleave", h, options...)
}

func (e *htmlRp) OnMouseMove(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mousemove", h, options...)
}

func (e *htmlRp) OnMouseOut(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mouseout", h, options...)
}

func (e *htmlRp) OnMouseOver(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mouseover", h, options...)
}

func (e *htmlRp) OnMouseUp(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("mouseup", h, options...)
}

func (e *htmlRp) OnPaste(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("paste", h, options...)
}

func (e *htmlRp) OnReset(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("reset", h, options...)
}

func (e *htmlRp) OnScroll(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("scroll", h, options...)
}

func (e *htmlRp) OnSearch(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("search", h, options...)
}

func (e *htmlRp) OnSelect(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("select", h, options...)
}

func (e *htmlRp) OnSubmit(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("submit", h, options...)
}

func (e *htmlRp) OnWheel(h EventHandler, options ...EventOption) HTMLRp {
	return e.On("wheel", h, options...)
}

func (e *htmlRp) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlRp) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlRp) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlRp) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlRp) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlRp) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "rt" HTML element.
type HTMLRt interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLRt

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLRt

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLRt

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLRt

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLRt

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLRt

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLRt

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLRt

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLRt

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLRt

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLRt

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLRt

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLRt

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLRt

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLRt

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLRt

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLRt

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLRt

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLRt

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLRt

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLRt

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLRt

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLRt

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLRt

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLRt

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLRt

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLRt

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLRt

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLRt

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLRt

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLRt

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLRt

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLRt

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLRt

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLRt

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLRt
}

// Returns an HTML element that provides explanation or pronunciation of characters (used in East Asian typography).
func Rt() HTMLRt {
	e := &htmlRt{
		htmlElement: htmlElement{
			tag:           "rt",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlRt struct {
	htmlElement
}

func (e *htmlRt) Body(v ...UI) HTMLRt {
	return e.setBody(FilterUIElems(v...)).(*htmlRt)
}

func (e *htmlRt) Text(v any) HTMLRt {
	return e.Body(Text(v))
}

func (e *htmlRt) Textf(format string, v ...any) HTMLRt {
	return e.Body(Textf(format, v...))
}

func (e *htmlRt) AccessKey(format string, v ...any) HTMLRt {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlRt) Aria(k string, v any) HTMLRt {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRt) Attr(n string, v any) HTMLRt {
	e.setAttr(n, v)
	return e
}

func (e *htmlRt) Class(v ...string) HTMLRt {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlRt) ContentEditable(v bool) HTMLRt {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlRt) DataSet(k string, v any) HTMLRt {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRt) DataSets(ds map[string]any) HTMLRt {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlRt) Dir(format string, v ...any) HTMLRt {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlRt) Draggable(v bool) HTMLRt {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlRt) Hidden(v bool) HTMLRt {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlRt) ID(format string, v ...any) HTMLRt {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlRt) Lang(format string, v ...any) HTMLRt {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlRt) Role(format string, v ...any) HTMLRt {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlRt) Spellcheck(v bool) HTMLRt {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlRt) Style(k, format string, v ...any) HTMLRt {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlRt) Styles(s map[string]string) HTMLRt {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlRt) TabIndex(v int) HTMLRt {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlRt) Title(format string, v ...any) HTMLRt {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlRt) On(event string, h EventHandler, options ...EventOption) HTMLRt {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlRt) OnBlur(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("blur", h, options...)
}

func (e *htmlRt) OnChange(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("change", h, options...)
}

func (e *htmlRt) OnClick(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("click", h, options...)
}

func (e *htmlRt) OnContextMenu(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("contextmenu", h, options...)
}

func (e *htmlRt) OnCopy(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("copy", h, options...)
}

func (e *htmlRt) OnCut(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("cut", h, options...)
}

func (e *htmlRt) OnDblClick(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dblclick", h, options...)
}

func (e *htmlRt) OnDrag(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("drag", h, options...)
}

func (e *htmlRt) OnDragEnd(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dragend", h, options...)
}

func (e *htmlRt) OnDragEnter(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dragenter", h, options...)
}

func (e *htmlRt) OnDragLeave(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dragleave", h, options...)
}

func (e *htmlRt) OnDragOver(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dragover", h, options...)
}

func (e *htmlRt) OnDragStart(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("dragstart", h, options...)
}

func (e *htmlRt) OnDrop(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("drop", h, options...)
}

func (e *htmlRt) OnFocus(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("focus", h, options...)
}

func (e *htmlRt) OnInput(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("input", h, options...)
}

func (e *htmlRt) OnInvalid(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("invalid", h, options...)
}

func (e *htmlRt) OnKeyDown(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("keydown", h, options...)
}

func (e *htmlRt) OnKeyPress(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("keypress", h, options...)
}

func (e *htmlRt) OnKeyUp(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("keyup", h, options...)
}

func (e *htmlRt) OnMouseDown(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mousedown", h, options...)
}

func (e *htmlRt) OnMouseEnter(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mouseenter", h, options...)
}

func (e *htmlRt) OnMouseLeave(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mouseleave", h, options...)
}

func (e *htmlRt) OnMouseMove(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mousemove", h, options...)
}

func (e *htmlRt) OnMouseOut(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mouseout", h, options...)
}

func (e *htmlRt) OnMouseOver(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mouseover", h, options...)
}

func (e *htmlRt) OnMouseUp(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("mouseup", h, options...)
}

func (e *htmlRt) OnPaste(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("paste", h, options...)
}

func (e *htmlRt) OnReset(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("reset", h, options...)
}

func (e *htmlRt) OnScroll(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("scroll", h, options...)
}

func (e *htmlRt) OnSearch(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("search", h, options...)
}

func (e *htmlRt) OnSelect(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("select", h, options...)
}

func (e *htmlRt) OnSubmit(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("submit", h, options...)
}

func (e *htmlRt) OnWheel(h EventHandler, options ...EventOption) HTMLRt {
	return e.On("wheel", h, options...)
}

func (e *htmlRt) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlRt) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlRt) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlRt) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlRt) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlRt) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "ruby" HTML element.
type HTMLRuby interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLRuby

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLRuby

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLRuby

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLRuby

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLRuby

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLRuby

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLRuby

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLRuby

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLRuby

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLRuby

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLRuby

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLRuby

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLRuby

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLRuby

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLRuby

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLRuby

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLRuby

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLRuby

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLRuby

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLRuby

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLRuby

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLRuby

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLRuby

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLRuby

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLRuby

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLRuby
}

// Returns an HTML element that marks a ruby annotation (used for East Asian typography).
func Ruby() HTMLRuby {
	e := &htmlRuby{
		htmlElement: htmlElement{
			tag:           "ruby",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlRuby struct {
	htmlElement
}

func (e *htmlRuby) Body(v ...UI) HTMLRuby {
	return e.setBody(FilterUIElems(v...)).(*htmlRuby)
}

func (e *htmlRuby) Text(v any) HTMLRuby {
	return e.Body(Text(v))
}

func (e *htmlRuby) Textf(format string, v ...any) HTMLRuby {
	return e.Body(Textf(format, v...))
}

func (e *htmlRuby) AccessKey(format string, v ...any) HTMLRuby {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlRuby) Aria(k string, v any) HTMLRuby {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRuby) Attr(n string, v any) HTMLRuby {
	e.setAttr(n, v)
	return e
}

func (e *htmlRuby) Class(v ...string) HTMLRuby {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlRuby) ContentEditable(v bool) HTMLRuby {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlRuby) DataSet(k string, v any) HTMLRuby {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlRuby) DataSets(ds map[string]any) HTMLRuby {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlRuby) Dir(format string, v ...any) HTMLRuby {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlRuby) Draggable(v bool) HTMLRuby {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlRuby) Hidden(v bool) HTMLRuby {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlRuby) ID(format string, v ...any) HTMLRuby {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlRuby) Lang(format string, v ...any) HTMLRuby {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlRuby) Role(format string, v ...any) HTMLRuby {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlRuby) Spellcheck(v bool) HTMLRuby {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlRuby) Style(k, format string, v ...any) HTMLRuby {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlRuby) Styles(s map[string]string) HTMLRuby {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlRuby) TabIndex(v int) HTMLRuby {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlRuby) Title(format string, v ...any) HTMLRuby {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlRuby) On(event string, h EventHandler, options ...EventOption) HTMLRuby {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlRuby) OnBlur(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("blur", h, options...)
}

func (e *htmlRuby) OnChange(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("change", h, options...)
}

func (e *htmlRuby) OnClick(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("click", h, options...)
}

func (e *htmlRuby) OnContextMenu(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("contextmenu", h, options...)
}

func (e *htmlRuby) OnCopy(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("copy", h, options...)
}

func (e *htmlRuby) OnCut(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("cut", h, options...)
}

func (e *htmlRuby) OnDblClick(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dblclick", h, options...)
}

func (e *htmlRuby) OnDrag(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("drag", h, options...)
}

func (e *htmlRuby) OnDragEnd(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dragend", h, options...)
}

func (e *htmlRuby) OnDragEnter(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dragenter", h, options...)
}

func (e *htmlRuby) OnDragLeave(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dragleave", h, options...)
}

func (e *htmlRuby) OnDragOver(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dragover", h, options...)
}

func (e *htmlRuby) OnDragStart(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("dragstart", h, options...)
}

func (e *htmlRuby) OnDrop(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("drop", h, options...)
}

func (e *htmlRuby) OnFocus(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("focus", h, options...)
}

func (e *htmlRuby) OnInput(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("input", h, options...)
}

func (e *htmlRuby) OnInvalid(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("invalid", h, options...)
}

func (e *htmlRuby) OnKeyDown(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("keydown", h, options...)
}

func (e *htmlRuby) OnKeyPress(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("keypress", h, options...)
}

func (e *htmlRuby) OnKeyUp(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("keyup", h, options...)
}

func (e *htmlRuby) OnMouseDown(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mousedown", h, options...)
}

func (e *htmlRuby) OnMouseEnter(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mouseenter", h, options...)
}

func (e *htmlRuby) OnMouseLeave(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mouseleave", h, options...)
}

func (e *htmlRuby) OnMouseMove(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mousemove", h, options...)
}

func (e *htmlRuby) OnMouseOut(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mouseout", h, options...)
}

func (e *htmlRuby) OnMouseOver(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mouseover", h, options...)
}

func (e *htmlRuby) OnMouseUp(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("mouseup", h, options...)
}

func (e *htmlRuby) OnPaste(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("paste", h, options...)
}

func (e *htmlRuby) OnReset(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("reset", h, options...)
}

func (e *htmlRuby) OnScroll(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("scroll", h, options...)
}

func (e *htmlRuby) OnSearch(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("search", h, options...)
}

func (e *htmlRuby) OnSelect(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("select", h, options...)
}

func (e *htmlRuby) OnSubmit(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("submit", h, options...)
}

func (e *htmlRuby) OnWheel(h EventHandler, options ...EventOption) HTMLRuby {
	return e.On("wheel", h, options...)
}

func (e *htmlRuby) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlRuby) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlRuby) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlRuby) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlRuby) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlRuby) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "s" HTML element.
type HTMLS interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLS

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLS

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLS

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLS

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLS

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLS

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLS

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLS

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLS

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLS

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLS

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLS

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLS

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLS

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLS

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLS

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLS

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLS

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLS

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLS

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLS

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLS

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLS

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLS

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLS

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLS

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLS

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLS

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLS

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLS

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLS

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLS

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLS

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLS

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLS

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLS

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLS

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLS

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLS

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLS

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLS

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLS

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLS

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLS

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLS

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLS

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLS

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLS

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLS

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLS
}

// Returns an HTML element that represents text which is no longer correct or relevant.
func S() HTMLS {
	e := &htmlS{
		htmlElement: htmlElement{
			tag:           "s",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlS struct {
	htmlElement
}

func (e *htmlS) Body(v ...UI) HTMLS {
	return e.setBody(FilterUIElems(v...)).(*htmlS)
}

func (e *htmlS) Text(v any) HTMLS {
	return e.Body(Text(v))
}

func (e *htmlS) Textf(format string, v ...any) HTMLS {
	return e.Body(Textf(format, v...))
}

func (e *htmlS) AccessKey(format string, v ...any) HTMLS {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlS) Aria(k string, v any) HTMLS {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlS) Attr(n string, v any) HTMLS {
	e.setAttr(n, v)
	return e
}

func (e *htmlS) Class(v ...string) HTMLS {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlS) ContentEditable(v bool) HTMLS {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlS) DataSet(k string, v any) HTMLS {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlS) DataSets(ds map[string]any) HTMLS {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlS) Dir(format string, v ...any) HTMLS {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlS) Draggable(v bool) HTMLS {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlS) Hidden(v bool) HTMLS {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlS) ID(format string, v ...any) HTMLS {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlS) Lang(format string, v ...any) HTMLS {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlS) Role(format string, v ...any) HTMLS {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlS) Spellcheck(v bool) HTMLS {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlS) Style(k, format string, v ...any) HTMLS {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlS) Styles(s map[string]string) HTMLS {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlS) TabIndex(v int) HTMLS {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlS) Title(format string, v ...any) HTMLS {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlS) On(event string, h EventHandler, options ...EventOption) HTMLS {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlS) OnBlur(h EventHandler, options ...EventOption) HTMLS {
	return e.On("blur", h, options...)
}

func (e *htmlS) OnChange(h EventHandler, options ...EventOption) HTMLS {
	return e.On("change", h, options...)
}

func (e *htmlS) OnClick(h EventHandler, options ...EventOption) HTMLS {
	return e.On("click", h, options...)
}

func (e *htmlS) OnContextMenu(h EventHandler, options ...EventOption) HTMLS {
	return e.On("contextmenu", h, options...)
}

func (e *htmlS) OnCopy(h EventHandler, options ...EventOption) HTMLS {
	return e.On("copy", h, options...)
}

func (e *htmlS) OnCut(h EventHandler, options ...EventOption) HTMLS {
	return e.On("cut", h, options...)
}

func (e *htmlS) OnDblClick(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dblclick", h, options...)
}

func (e *htmlS) OnDrag(h EventHandler, options ...EventOption) HTMLS {
	return e.On("drag", h, options...)
}

func (e *htmlS) OnDragEnd(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dragend", h, options...)
}

func (e *htmlS) OnDragEnter(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dragenter", h, options...)
}

func (e *htmlS) OnDragLeave(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dragleave", h, options...)
}

func (e *htmlS) OnDragOver(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dragover", h, options...)
}

func (e *htmlS) OnDragStart(h EventHandler, options ...EventOption) HTMLS {
	return e.On("dragstart", h, options...)
}

func (e *htmlS) OnDrop(h EventHandler, options ...EventOption) HTMLS {
	return e.On("drop", h, options...)
}

func (e *htmlS) OnFocus(h EventHandler, options ...EventOption) HTMLS {
	return e.On("focus", h, options...)
}

func (e *htmlS) OnInput(h EventHandler, options ...EventOption) HTMLS {
	return e.On("input", h, options...)
}

func (e *htmlS) OnInvalid(h EventHandler, options ...EventOption) HTMLS {
	return e.On("invalid", h, options...)
}

func (e *htmlS) OnKeyDown(h EventHandler, options ...EventOption) HTMLS {
	return e.On("keydown", h, options...)
}

func (e *htmlS) OnKeyPress(h EventHandler, options ...EventOption) HTMLS {
	return e.On("keypress", h, options...)
}

func (e *htmlS) OnKeyUp(h EventHandler, options ...EventOption) HTMLS {
	return e.On("keyup", h, options...)
}

func (e *htmlS) OnMouseDown(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mousedown", h, options...)
}

func (e *htmlS) OnMouseEnter(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mouseenter", h, options...)
}

func (e *htmlS) OnMouseLeave(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mouseleave", h, options...)
}

func (e *htmlS) OnMouseMove(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mousemove", h, options...)
}

func (e *htmlS) OnMouseOut(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mouseout", h, options...)
}

func (e *htmlS) OnMouseOver(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mouseover", h, options...)
}

func (e *htmlS) OnMouseUp(h EventHandler, options ...EventOption) HTMLS {
	return e.On("mouseup", h, options...)
}

func (e *htmlS) OnPaste(h EventHandler, options ...EventOption) HTMLS {
	return e.On("paste", h, options...)
}

func (e *htmlS) OnReset(h EventHandler, options ...EventOption) HTMLS {
	return e.On("reset", h, options...)
}

func (e *htmlS) OnScroll(h EventHandler, options ...EventOption) HTMLS {
	return e.On("scroll", h, options...)
}

func (e *htmlS) OnSearch(h EventHandler, options ...EventOption) HTMLS {
	return e.On("search", h, options...)
}

func (e *htmlS) OnSelect(h EventHandler, options ...EventOption) HTMLS {
	return e.On("select", h, options...)
}

func (e *htmlS) OnSubmit(h EventHandler, options ...EventOption) HTMLS {
	return e.On("submit", h, options...)
}

func (e *htmlS) OnWheel(h EventHandler, options ...EventOption) HTMLS {
	return e.On("wheel", h, options...)
}

func (e *htmlS) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlS) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlS) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlS) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlS) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlS) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "samp" HTML element.
type HTMLSamp interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSamp

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSamp

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSamp

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSamp

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSamp

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSamp

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSamp

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSamp

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSamp

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSamp

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSamp

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSamp

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSamp

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSamp

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSamp

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSamp

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSamp

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSamp

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSamp

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSamp

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSamp

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSamp

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSamp

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSamp

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSamp

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSamp
}

// Returns an HTML element that displays sample output from a computer program.
func Samp() HTMLSamp {
	e := &htmlSamp{
		htmlElement: htmlElement{
			tag:           "samp",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSamp struct {
	htmlElement
}

func (e *htmlSamp) Body(v ...UI) HTMLSamp {
	return e.setBody(FilterUIElems(v...)).(*htmlSamp)
}

func (e *htmlSamp) Text(v any) HTMLSamp {
	return e.Body(Text(v))
}

func (e *htmlSamp) Textf(format string, v ...any) HTMLSamp {
	return e.Body(Textf(format, v...))
}

func (e *htmlSamp) AccessKey(format string, v ...any) HTMLSamp {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSamp) Aria(k string, v any) HTMLSamp {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSamp) Attr(n string, v any) HTMLSamp {
	e.setAttr(n, v)
	return e
}

func (e *htmlSamp) Class(v ...string) HTMLSamp {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSamp) ContentEditable(v bool) HTMLSamp {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSamp) DataSet(k string, v any) HTMLSamp {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSamp) DataSets(ds map[string]any) HTMLSamp {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSamp) Dir(format string, v ...any) HTMLSamp {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSamp) Draggable(v bool) HTMLSamp {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSamp) Hidden(v bool) HTMLSamp {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSamp) ID(format string, v ...any) HTMLSamp {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSamp) Lang(format string, v ...any) HTMLSamp {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSamp) Role(format string, v ...any) HTMLSamp {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSamp) Spellcheck(v bool) HTMLSamp {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSamp) Style(k, format string, v ...any) HTMLSamp {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSamp) Styles(s map[string]string) HTMLSamp {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSamp) TabIndex(v int) HTMLSamp {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSamp) Title(format string, v ...any) HTMLSamp {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSamp) On(event string, h EventHandler, options ...EventOption) HTMLSamp {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSamp) OnBlur(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("blur", h, options...)
}

func (e *htmlSamp) OnChange(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("change", h, options...)
}

func (e *htmlSamp) OnClick(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("click", h, options...)
}

func (e *htmlSamp) OnContextMenu(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSamp) OnCopy(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("copy", h, options...)
}

func (e *htmlSamp) OnCut(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("cut", h, options...)
}

func (e *htmlSamp) OnDblClick(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dblclick", h, options...)
}

func (e *htmlSamp) OnDrag(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("drag", h, options...)
}

func (e *htmlSamp) OnDragEnd(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dragend", h, options...)
}

func (e *htmlSamp) OnDragEnter(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dragenter", h, options...)
}

func (e *htmlSamp) OnDragLeave(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dragleave", h, options...)
}

func (e *htmlSamp) OnDragOver(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dragover", h, options...)
}

func (e *htmlSamp) OnDragStart(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("dragstart", h, options...)
}

func (e *htmlSamp) OnDrop(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("drop", h, options...)
}

func (e *htmlSamp) OnFocus(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("focus", h, options...)
}

func (e *htmlSamp) OnInput(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("input", h, options...)
}

func (e *htmlSamp) OnInvalid(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("invalid", h, options...)
}

func (e *htmlSamp) OnKeyDown(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("keydown", h, options...)
}

func (e *htmlSamp) OnKeyPress(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("keypress", h, options...)
}

func (e *htmlSamp) OnKeyUp(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("keyup", h, options...)
}

func (e *htmlSamp) OnMouseDown(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mousedown", h, options...)
}

func (e *htmlSamp) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSamp) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSamp) OnMouseMove(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mousemove", h, options...)
}

func (e *htmlSamp) OnMouseOut(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mouseout", h, options...)
}

func (e *htmlSamp) OnMouseOver(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mouseover", h, options...)
}

func (e *htmlSamp) OnMouseUp(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("mouseup", h, options...)
}

func (e *htmlSamp) OnPaste(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("paste", h, options...)
}

func (e *htmlSamp) OnReset(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("reset", h, options...)
}

func (e *htmlSamp) OnScroll(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("scroll", h, options...)
}

func (e *htmlSamp) OnSearch(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("search", h, options...)
}

func (e *htmlSamp) OnSelect(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("select", h, options...)
}

func (e *htmlSamp) OnSubmit(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("submit", h, options...)
}

func (e *htmlSamp) OnWheel(h EventHandler, options ...EventOption) HTMLSamp {
	return e.On("wheel", h, options...)
}

func (e *htmlSamp) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSamp) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSamp) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSamp) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSamp) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSamp) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "script" HTML element.
type HTMLScript interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLScript

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLScript

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLScript

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLScript

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLScript

	// Specifies that external scripts are executed asynchronously, preventing blocking of page rendering.
	Async(v bool) HTMLScript

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLScript

	// Specifies the character encoding for the linked document or external resource.
	Charset(format string, v ...any) HTMLScript

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLScript

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLScript

	// Controls how cross-origin requests are managed for the element, supporting secure content integration from different origins.
	CrossOrigin(format string, v ...any) HTMLScript

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLScript

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLScript

	// Delays the execution of a script until after the document is parsed, typically applied to external scripts.
	Defer(v bool) HTMLScript

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLScript

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLScript

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLScript

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLScript

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLScript

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLScript

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLScript

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLScript

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLScript

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLScript

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLScript

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLScript

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLScript

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLScript

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLScript
}

// Returns an HTML element that embeds or references a client-side script.
func Script() HTMLScript {
	e := &htmlScript{
		htmlElement: htmlElement{
			tag:           "script",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlScript struct {
	htmlElement
}

func (e *htmlScript) Body(v ...UI) HTMLScript {
	return e.setBody(FilterUIElems(v...)).(*htmlScript)
}

func (e *htmlScript) Text(v any) HTMLScript {
	return e.Body(Text(v))
}

func (e *htmlScript) Textf(format string, v ...any) HTMLScript {
	return e.Body(Textf(format, v...))
}

func (e *htmlScript) AccessKey(format string, v ...any) HTMLScript {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlScript) Aria(k string, v any) HTMLScript {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlScript) Async(v bool) HTMLScript {
	e.setAttr("async", v)
	return e
}

func (e *htmlScript) Attr(n string, v any) HTMLScript {
	e.setAttr(n, v)
	return e
}

func (e *htmlScript) Charset(format string, v ...any) HTMLScript {
	e.setAttr("charset", FormatString(format, v...))
	return e
}

func (e *htmlScript) Class(v ...string) HTMLScript {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlScript) ContentEditable(v bool) HTMLScript {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlScript) CrossOrigin(format string, v ...any) HTMLScript {
	e.setAttr("crossorigin", FormatString(format, v...))
	return e
}

func (e *htmlScript) DataSet(k string, v any) HTMLScript {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlScript) DataSets(ds map[string]any) HTMLScript {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlScript) Defer(v bool) HTMLScript {
	e.setAttr("defer", v)
	return e
}

func (e *htmlScript) Dir(format string, v ...any) HTMLScript {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlScript) Draggable(v bool) HTMLScript {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlScript) Hidden(v bool) HTMLScript {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlScript) ID(format string, v ...any) HTMLScript {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlScript) Lang(format string, v ...any) HTMLScript {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlScript) Role(format string, v ...any) HTMLScript {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlScript) Spellcheck(v bool) HTMLScript {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlScript) Src(format string, v ...any) HTMLScript {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlScript) Style(k, format string, v ...any) HTMLScript {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlScript) Styles(s map[string]string) HTMLScript {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlScript) TabIndex(v int) HTMLScript {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlScript) Title(format string, v ...any) HTMLScript {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlScript) Type(format string, v ...any) HTMLScript {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlScript) On(event string, h EventHandler, options ...EventOption) HTMLScript {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlScript) OnLoad(h EventHandler, options ...EventOption) HTMLScript {
	return e.On("load", h, options...)
}

func (e *htmlScript) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlScript) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlScript) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlScript) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlScript) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlScript) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "section" HTML element.
type HTMLSection interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSection

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSection

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSection

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSection

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSection

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSection

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSection

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSection

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSection

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSection

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSection

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSection

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSection

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSection

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSection

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSection

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSection

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSection

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSection

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSection

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSection

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSection

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSection

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSection

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSection

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSection

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSection

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSection

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSection

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSection

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSection

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSection

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSection

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSection

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSection

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSection
}

// Returns an HTML element that represents a standalone section in a document.
func Section() HTMLSection {
	e := &htmlSection{
		htmlElement: htmlElement{
			tag:           "section",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSection struct {
	htmlElement
}

func (e *htmlSection) Body(v ...UI) HTMLSection {
	return e.setBody(FilterUIElems(v...)).(*htmlSection)
}

func (e *htmlSection) Text(v any) HTMLSection {
	return e.Body(Text(v))
}

func (e *htmlSection) Textf(format string, v ...any) HTMLSection {
	return e.Body(Textf(format, v...))
}

func (e *htmlSection) AccessKey(format string, v ...any) HTMLSection {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSection) Aria(k string, v any) HTMLSection {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSection) Attr(n string, v any) HTMLSection {
	e.setAttr(n, v)
	return e
}

func (e *htmlSection) Class(v ...string) HTMLSection {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSection) ContentEditable(v bool) HTMLSection {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSection) DataSet(k string, v any) HTMLSection {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSection) DataSets(ds map[string]any) HTMLSection {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSection) Dir(format string, v ...any) HTMLSection {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSection) Draggable(v bool) HTMLSection {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSection) Hidden(v bool) HTMLSection {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSection) ID(format string, v ...any) HTMLSection {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSection) Lang(format string, v ...any) HTMLSection {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSection) Role(format string, v ...any) HTMLSection {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSection) Spellcheck(v bool) HTMLSection {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSection) Style(k, format string, v ...any) HTMLSection {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSection) Styles(s map[string]string) HTMLSection {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSection) TabIndex(v int) HTMLSection {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSection) Title(format string, v ...any) HTMLSection {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSection) On(event string, h EventHandler, options ...EventOption) HTMLSection {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSection) OnBlur(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("blur", h, options...)
}

func (e *htmlSection) OnChange(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("change", h, options...)
}

func (e *htmlSection) OnClick(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("click", h, options...)
}

func (e *htmlSection) OnContextMenu(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSection) OnCopy(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("copy", h, options...)
}

func (e *htmlSection) OnCut(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("cut", h, options...)
}

func (e *htmlSection) OnDblClick(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dblclick", h, options...)
}

func (e *htmlSection) OnDrag(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("drag", h, options...)
}

func (e *htmlSection) OnDragEnd(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dragend", h, options...)
}

func (e *htmlSection) OnDragEnter(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dragenter", h, options...)
}

func (e *htmlSection) OnDragLeave(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dragleave", h, options...)
}

func (e *htmlSection) OnDragOver(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dragover", h, options...)
}

func (e *htmlSection) OnDragStart(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("dragstart", h, options...)
}

func (e *htmlSection) OnDrop(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("drop", h, options...)
}

func (e *htmlSection) OnFocus(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("focus", h, options...)
}

func (e *htmlSection) OnInput(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("input", h, options...)
}

func (e *htmlSection) OnInvalid(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("invalid", h, options...)
}

func (e *htmlSection) OnKeyDown(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("keydown", h, options...)
}

func (e *htmlSection) OnKeyPress(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("keypress", h, options...)
}

func (e *htmlSection) OnKeyUp(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("keyup", h, options...)
}

func (e *htmlSection) OnMouseDown(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mousedown", h, options...)
}

func (e *htmlSection) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSection) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSection) OnMouseMove(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mousemove", h, options...)
}

func (e *htmlSection) OnMouseOut(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mouseout", h, options...)
}

func (e *htmlSection) OnMouseOver(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mouseover", h, options...)
}

func (e *htmlSection) OnMouseUp(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("mouseup", h, options...)
}

func (e *htmlSection) OnPaste(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("paste", h, options...)
}

func (e *htmlSection) OnReset(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("reset", h, options...)
}

func (e *htmlSection) OnScroll(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("scroll", h, options...)
}

func (e *htmlSection) OnSearch(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("search", h, options...)
}

func (e *htmlSection) OnSelect(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("select", h, options...)
}

func (e *htmlSection) OnSubmit(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("submit", h, options...)
}

func (e *htmlSection) OnWheel(h EventHandler, options ...EventOption) HTMLSection {
	return e.On("wheel", h, options...)
}

func (e *htmlSection) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSection) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSection) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSection) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSection) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSection) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "select" HTML element.
type HTMLSelect interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSelect

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSelect

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSelect

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSelect

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSelect

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSelect

	// Instructs the browser to focus this element automatically when the page loads.
	AutoFocus(v bool) HTMLSelect

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSelect

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSelect

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSelect

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSelect

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSelect

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLSelect

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSelect

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLSelect

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSelect

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSelect

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSelect

	// Allows users to input multiple values.
	Multiple(v bool) HTMLSelect

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLSelect

	// Indicates that the element must contain a value before form submission.
	Required(v bool) HTMLSelect

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSelect

	// Indicates the width of the element, usually in characters for input elements.
	Size(v int) HTMLSelect

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSelect

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSelect

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSelect

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSelect

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSelect

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSelect

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSelect

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSelect

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSelect

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSelect
}

// Returns an HTML element that creates a drop-down list or list box for form input.
func Select() HTMLSelect {
	e := &htmlSelect{
		htmlElement: htmlElement{
			tag:           "select",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSelect struct {
	htmlElement
}

func (e *htmlSelect) Body(v ...UI) HTMLSelect {
	return e.setBody(FilterUIElems(v...)).(*htmlSelect)
}

func (e *htmlSelect) Text(v any) HTMLSelect {
	return e.Body(Text(v))
}

func (e *htmlSelect) Textf(format string, v ...any) HTMLSelect {
	return e.Body(Textf(format, v...))
}

func (e *htmlSelect) AccessKey(format string, v ...any) HTMLSelect {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Aria(k string, v any) HTMLSelect {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSelect) Attr(n string, v any) HTMLSelect {
	e.setAttr(n, v)
	return e
}

func (e *htmlSelect) AutoFocus(v bool) HTMLSelect {
	e.setAttr("autofocus", v)
	return e
}

func (e *htmlSelect) Class(v ...string) HTMLSelect {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSelect) ContentEditable(v bool) HTMLSelect {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSelect) DataSet(k string, v any) HTMLSelect {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSelect) DataSets(ds map[string]any) HTMLSelect {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSelect) Dir(format string, v ...any) HTMLSelect {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Disabled(v bool) HTMLSelect {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlSelect) Draggable(v bool) HTMLSelect {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSelect) Form(format string, v ...any) HTMLSelect {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Hidden(v bool) HTMLSelect {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSelect) ID(format string, v ...any) HTMLSelect {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Lang(format string, v ...any) HTMLSelect {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Multiple(v bool) HTMLSelect {
	e.setAttr("multiple", v)
	return e
}

func (e *htmlSelect) Name(format string, v ...any) HTMLSelect {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Required(v bool) HTMLSelect {
	e.setAttr("required", v)
	return e
}

func (e *htmlSelect) Role(format string, v ...any) HTMLSelect {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSelect) Size(v int) HTMLSelect {
	e.setAttr("size", v)
	return e
}

func (e *htmlSelect) Spellcheck(v bool) HTMLSelect {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSelect) Style(k, format string, v ...any) HTMLSelect {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSelect) Styles(s map[string]string) HTMLSelect {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSelect) TabIndex(v int) HTMLSelect {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSelect) Title(format string, v ...any) HTMLSelect {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSelect) On(event string, h EventHandler, options ...EventOption) HTMLSelect {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSelect) OnBlur(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("blur", h, options...)
}

func (e *htmlSelect) OnChange(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("change", h, options...)
}

func (e *htmlSelect) OnClick(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("click", h, options...)
}

func (e *htmlSelect) OnContextMenu(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSelect) OnCopy(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("copy", h, options...)
}

func (e *htmlSelect) OnCut(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("cut", h, options...)
}

func (e *htmlSelect) OnDblClick(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dblclick", h, options...)
}

func (e *htmlSelect) OnDrag(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("drag", h, options...)
}

func (e *htmlSelect) OnDragEnd(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dragend", h, options...)
}

func (e *htmlSelect) OnDragEnter(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dragenter", h, options...)
}

func (e *htmlSelect) OnDragLeave(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dragleave", h, options...)
}

func (e *htmlSelect) OnDragOver(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dragover", h, options...)
}

func (e *htmlSelect) OnDragStart(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("dragstart", h, options...)
}

func (e *htmlSelect) OnDrop(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("drop", h, options...)
}

func (e *htmlSelect) OnFocus(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("focus", h, options...)
}

func (e *htmlSelect) OnInput(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("input", h, options...)
}

func (e *htmlSelect) OnInvalid(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("invalid", h, options...)
}

func (e *htmlSelect) OnKeyDown(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("keydown", h, options...)
}

func (e *htmlSelect) OnKeyPress(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("keypress", h, options...)
}

func (e *htmlSelect) OnKeyUp(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("keyup", h, options...)
}

func (e *htmlSelect) OnMouseDown(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mousedown", h, options...)
}

func (e *htmlSelect) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSelect) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSelect) OnMouseMove(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mousemove", h, options...)
}

func (e *htmlSelect) OnMouseOut(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mouseout", h, options...)
}

func (e *htmlSelect) OnMouseOver(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mouseover", h, options...)
}

func (e *htmlSelect) OnMouseUp(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("mouseup", h, options...)
}

func (e *htmlSelect) OnPaste(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("paste", h, options...)
}

func (e *htmlSelect) OnReset(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("reset", h, options...)
}

func (e *htmlSelect) OnScroll(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("scroll", h, options...)
}

func (e *htmlSelect) OnSearch(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("search", h, options...)
}

func (e *htmlSelect) OnSelect(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("select", h, options...)
}

func (e *htmlSelect) OnSubmit(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("submit", h, options...)
}

func (e *htmlSelect) OnWheel(h EventHandler, options ...EventOption) HTMLSelect {
	return e.On("wheel", h, options...)
}

func (e *htmlSelect) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSelect) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSelect) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSelect) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSelect) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSelect) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "small" HTML element.
type HTMLSmall interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSmall

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSmall

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSmall

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSmall

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSmall

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSmall

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSmall

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSmall

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSmall

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSmall

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSmall

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSmall

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSmall

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSmall

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSmall

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSmall

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSmall

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSmall

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSmall

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSmall

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSmall

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSmall

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSmall

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSmall

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSmall

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSmall
}

// Returns an HTML element that displays text in a smaller font, typically for side comments or legal disclaimers.
func Small() HTMLSmall {
	e := &htmlSmall{
		htmlElement: htmlElement{
			tag:           "small",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSmall struct {
	htmlElement
}

func (e *htmlSmall) Body(v ...UI) HTMLSmall {
	return e.setBody(FilterUIElems(v...)).(*htmlSmall)
}

func (e *htmlSmall) Text(v any) HTMLSmall {
	return e.Body(Text(v))
}

func (e *htmlSmall) Textf(format string, v ...any) HTMLSmall {
	return e.Body(Textf(format, v...))
}

func (e *htmlSmall) AccessKey(format string, v ...any) HTMLSmall {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSmall) Aria(k string, v any) HTMLSmall {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSmall) Attr(n string, v any) HTMLSmall {
	e.setAttr(n, v)
	return e
}

func (e *htmlSmall) Class(v ...string) HTMLSmall {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSmall) ContentEditable(v bool) HTMLSmall {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSmall) DataSet(k string, v any) HTMLSmall {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSmall) DataSets(ds map[string]any) HTMLSmall {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSmall) Dir(format string, v ...any) HTMLSmall {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSmall) Draggable(v bool) HTMLSmall {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSmall) Hidden(v bool) HTMLSmall {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSmall) ID(format string, v ...any) HTMLSmall {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSmall) Lang(format string, v ...any) HTMLSmall {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSmall) Role(format string, v ...any) HTMLSmall {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSmall) Spellcheck(v bool) HTMLSmall {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSmall) Style(k, format string, v ...any) HTMLSmall {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSmall) Styles(s map[string]string) HTMLSmall {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSmall) TabIndex(v int) HTMLSmall {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSmall) Title(format string, v ...any) HTMLSmall {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSmall) On(event string, h EventHandler, options ...EventOption) HTMLSmall {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSmall) OnBlur(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("blur", h, options...)
}

func (e *htmlSmall) OnChange(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("change", h, options...)
}

func (e *htmlSmall) OnClick(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("click", h, options...)
}

func (e *htmlSmall) OnContextMenu(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSmall) OnCopy(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("copy", h, options...)
}

func (e *htmlSmall) OnCut(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("cut", h, options...)
}

func (e *htmlSmall) OnDblClick(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dblclick", h, options...)
}

func (e *htmlSmall) OnDrag(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("drag", h, options...)
}

func (e *htmlSmall) OnDragEnd(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dragend", h, options...)
}

func (e *htmlSmall) OnDragEnter(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dragenter", h, options...)
}

func (e *htmlSmall) OnDragLeave(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dragleave", h, options...)
}

func (e *htmlSmall) OnDragOver(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dragover", h, options...)
}

func (e *htmlSmall) OnDragStart(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("dragstart", h, options...)
}

func (e *htmlSmall) OnDrop(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("drop", h, options...)
}

func (e *htmlSmall) OnFocus(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("focus", h, options...)
}

func (e *htmlSmall) OnInput(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("input", h, options...)
}

func (e *htmlSmall) OnInvalid(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("invalid", h, options...)
}

func (e *htmlSmall) OnKeyDown(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("keydown", h, options...)
}

func (e *htmlSmall) OnKeyPress(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("keypress", h, options...)
}

func (e *htmlSmall) OnKeyUp(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("keyup", h, options...)
}

func (e *htmlSmall) OnMouseDown(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mousedown", h, options...)
}

func (e *htmlSmall) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSmall) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSmall) OnMouseMove(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mousemove", h, options...)
}

func (e *htmlSmall) OnMouseOut(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mouseout", h, options...)
}

func (e *htmlSmall) OnMouseOver(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mouseover", h, options...)
}

func (e *htmlSmall) OnMouseUp(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("mouseup", h, options...)
}

func (e *htmlSmall) OnPaste(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("paste", h, options...)
}

func (e *htmlSmall) OnReset(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("reset", h, options...)
}

func (e *htmlSmall) OnScroll(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("scroll", h, options...)
}

func (e *htmlSmall) OnSearch(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("search", h, options...)
}

func (e *htmlSmall) OnSelect(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("select", h, options...)
}

func (e *htmlSmall) OnSubmit(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("submit", h, options...)
}

func (e *htmlSmall) OnWheel(h EventHandler, options ...EventOption) HTMLSmall {
	return e.On("wheel", h, options...)
}

func (e *htmlSmall) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSmall) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSmall) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSmall) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSmall) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSmall) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "source" HTML element.
type HTMLSource interface {
	HTML

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSource

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSource

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSource

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSource

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSource

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSource

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSource

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSource

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSource

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSource

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSource

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSource

	// Indicates the intended media or device for the linked document.
	Media(format string, v ...any) HTMLSource

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSource

	// Specifies sizes of icons and images for different page or screen scenarios. Uses the given format and values.
	Sizes(format string, v ...any) HTMLSource

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSource

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLSource

	// Provides URLs of images to display in varied resolutions or viewport conditions. Uses the given format and values.
	SrcSet(format string, v ...any) HTMLSource

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSource

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSource

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSource

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSource

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLSource

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSource

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSource

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSource

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSource

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSource

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSource

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSource

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSource

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSource

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSource

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSource

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSource

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSource

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSource

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSource
}

// Returns an HTML element that specifies multiple media resources for elements like <picture>, <audio>, and <video>.
func Source() HTMLSource {
	e := &htmlSource{
		htmlElement: htmlElement{
			tag:           "source",
			isSelfClosing: true,
		},
	}

	return e
}

type htmlSource struct {
	htmlElement
}

func (e *htmlSource) AccessKey(format string, v ...any) HTMLSource {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSource) Aria(k string, v any) HTMLSource {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSource) Attr(n string, v any) HTMLSource {
	e.setAttr(n, v)
	return e
}

func (e *htmlSource) Class(v ...string) HTMLSource {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSource) ContentEditable(v bool) HTMLSource {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSource) DataSet(k string, v any) HTMLSource {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSource) DataSets(ds map[string]any) HTMLSource {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSource) Dir(format string, v ...any) HTMLSource {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSource) Draggable(v bool) HTMLSource {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSource) Hidden(v bool) HTMLSource {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSource) ID(format string, v ...any) HTMLSource {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSource) Lang(format string, v ...any) HTMLSource {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSource) Media(format string, v ...any) HTMLSource {
	e.setAttr("media", FormatString(format, v...))
	return e
}

func (e *htmlSource) Role(format string, v ...any) HTMLSource {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSource) Sizes(format string, v ...any) HTMLSource {
	e.setAttr("sizes", FormatString(format, v...))
	return e
}

func (e *htmlSource) Spellcheck(v bool) HTMLSource {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSource) Src(format string, v ...any) HTMLSource {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlSource) SrcSet(format string, v ...any) HTMLSource {
	e.setAttr("srcset", FormatString(format, v...))
	return e
}

func (e *htmlSource) Style(k, format string, v ...any) HTMLSource {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSource) Styles(s map[string]string) HTMLSource {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSource) TabIndex(v int) HTMLSource {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSource) Title(format string, v ...any) HTMLSource {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSource) Type(format string, v ...any) HTMLSource {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlSource) On(event string, h EventHandler, options ...EventOption) HTMLSource {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSource) OnBlur(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("blur", h, options...)
}

func (e *htmlSource) OnChange(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("change", h, options...)
}

func (e *htmlSource) OnClick(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("click", h, options...)
}

func (e *htmlSource) OnContextMenu(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSource) OnCopy(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("copy", h, options...)
}

func (e *htmlSource) OnCut(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("cut", h, options...)
}

func (e *htmlSource) OnDblClick(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dblclick", h, options...)
}

func (e *htmlSource) OnDrag(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("drag", h, options...)
}

func (e *htmlSource) OnDragEnd(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dragend", h, options...)
}

func (e *htmlSource) OnDragEnter(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dragenter", h, options...)
}

func (e *htmlSource) OnDragLeave(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dragleave", h, options...)
}

func (e *htmlSource) OnDragOver(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dragover", h, options...)
}

func (e *htmlSource) OnDragStart(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("dragstart", h, options...)
}

func (e *htmlSource) OnDrop(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("drop", h, options...)
}

func (e *htmlSource) OnFocus(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("focus", h, options...)
}

func (e *htmlSource) OnInput(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("input", h, options...)
}

func (e *htmlSource) OnInvalid(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("invalid", h, options...)
}

func (e *htmlSource) OnKeyDown(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("keydown", h, options...)
}

func (e *htmlSource) OnKeyPress(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("keypress", h, options...)
}

func (e *htmlSource) OnKeyUp(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("keyup", h, options...)
}

func (e *htmlSource) OnMouseDown(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mousedown", h, options...)
}

func (e *htmlSource) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSource) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSource) OnMouseMove(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mousemove", h, options...)
}

func (e *htmlSource) OnMouseOut(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mouseout", h, options...)
}

func (e *htmlSource) OnMouseOver(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mouseover", h, options...)
}

func (e *htmlSource) OnMouseUp(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("mouseup", h, options...)
}

func (e *htmlSource) OnPaste(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("paste", h, options...)
}

func (e *htmlSource) OnReset(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("reset", h, options...)
}

func (e *htmlSource) OnScroll(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("scroll", h, options...)
}

func (e *htmlSource) OnSearch(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("search", h, options...)
}

func (e *htmlSource) OnSelect(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("select", h, options...)
}

func (e *htmlSource) OnSubmit(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("submit", h, options...)
}

func (e *htmlSource) OnWheel(h EventHandler, options ...EventOption) HTMLSource {
	return e.On("wheel", h, options...)
}

func (e *htmlSource) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSource) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSource) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSource) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSource) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSource) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "span" HTML element.
type HTMLSpan interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSpan

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSpan

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSpan

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSpan

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSpan

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSpan

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSpan

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSpan

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSpan

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSpan

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSpan

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSpan

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSpan

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSpan

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSpan

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSpan

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSpan

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSpan

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSpan

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSpan

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSpan

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSpan

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSpan

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSpan

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSpan

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSpan
}

// Returns an HTML element that provides a way to style a specific part of the text or to group inline-elements.
func Span() HTMLSpan {
	e := &htmlSpan{
		htmlElement: htmlElement{
			tag:           "span",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSpan struct {
	htmlElement
}

func (e *htmlSpan) Body(v ...UI) HTMLSpan {
	return e.setBody(FilterUIElems(v...)).(*htmlSpan)
}

func (e *htmlSpan) Text(v any) HTMLSpan {
	return e.Body(Text(v))
}

func (e *htmlSpan) Textf(format string, v ...any) HTMLSpan {
	return e.Body(Textf(format, v...))
}

func (e *htmlSpan) AccessKey(format string, v ...any) HTMLSpan {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSpan) Aria(k string, v any) HTMLSpan {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSpan) Attr(n string, v any) HTMLSpan {
	e.setAttr(n, v)
	return e
}

func (e *htmlSpan) Class(v ...string) HTMLSpan {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSpan) ContentEditable(v bool) HTMLSpan {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSpan) DataSet(k string, v any) HTMLSpan {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSpan) DataSets(ds map[string]any) HTMLSpan {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSpan) Dir(format string, v ...any) HTMLSpan {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSpan) Draggable(v bool) HTMLSpan {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSpan) Hidden(v bool) HTMLSpan {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSpan) ID(format string, v ...any) HTMLSpan {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSpan) Lang(format string, v ...any) HTMLSpan {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSpan) Role(format string, v ...any) HTMLSpan {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSpan) Spellcheck(v bool) HTMLSpan {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSpan) Style(k, format string, v ...any) HTMLSpan {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSpan) Styles(s map[string]string) HTMLSpan {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSpan) TabIndex(v int) HTMLSpan {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSpan) Title(format string, v ...any) HTMLSpan {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSpan) On(event string, h EventHandler, options ...EventOption) HTMLSpan {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSpan) OnBlur(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("blur", h, options...)
}

func (e *htmlSpan) OnChange(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("change", h, options...)
}

func (e *htmlSpan) OnClick(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("click", h, options...)
}

func (e *htmlSpan) OnContextMenu(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSpan) OnCopy(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("copy", h, options...)
}

func (e *htmlSpan) OnCut(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("cut", h, options...)
}

func (e *htmlSpan) OnDblClick(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dblclick", h, options...)
}

func (e *htmlSpan) OnDrag(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("drag", h, options...)
}

func (e *htmlSpan) OnDragEnd(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dragend", h, options...)
}

func (e *htmlSpan) OnDragEnter(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dragenter", h, options...)
}

func (e *htmlSpan) OnDragLeave(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dragleave", h, options...)
}

func (e *htmlSpan) OnDragOver(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dragover", h, options...)
}

func (e *htmlSpan) OnDragStart(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("dragstart", h, options...)
}

func (e *htmlSpan) OnDrop(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("drop", h, options...)
}

func (e *htmlSpan) OnFocus(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("focus", h, options...)
}

func (e *htmlSpan) OnInput(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("input", h, options...)
}

func (e *htmlSpan) OnInvalid(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("invalid", h, options...)
}

func (e *htmlSpan) OnKeyDown(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("keydown", h, options...)
}

func (e *htmlSpan) OnKeyPress(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("keypress", h, options...)
}

func (e *htmlSpan) OnKeyUp(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("keyup", h, options...)
}

func (e *htmlSpan) OnMouseDown(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mousedown", h, options...)
}

func (e *htmlSpan) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSpan) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSpan) OnMouseMove(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mousemove", h, options...)
}

func (e *htmlSpan) OnMouseOut(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mouseout", h, options...)
}

func (e *htmlSpan) OnMouseOver(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mouseover", h, options...)
}

func (e *htmlSpan) OnMouseUp(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("mouseup", h, options...)
}

func (e *htmlSpan) OnPaste(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("paste", h, options...)
}

func (e *htmlSpan) OnReset(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("reset", h, options...)
}

func (e *htmlSpan) OnScroll(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("scroll", h, options...)
}

func (e *htmlSpan) OnSearch(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("search", h, options...)
}

func (e *htmlSpan) OnSelect(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("select", h, options...)
}

func (e *htmlSpan) OnSubmit(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("submit", h, options...)
}

func (e *htmlSpan) OnWheel(h EventHandler, options ...EventOption) HTMLSpan {
	return e.On("wheel", h, options...)
}

func (e *htmlSpan) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSpan) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSpan) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSpan) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSpan) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSpan) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "strong" HTML element.
type HTMLStrong interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLStrong

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLStrong

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLStrong

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLStrong

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLStrong

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLStrong

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLStrong

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLStrong

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLStrong

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLStrong

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLStrong

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLStrong

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLStrong

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLStrong

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLStrong

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLStrong

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLStrong

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLStrong

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLStrong

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLStrong

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLStrong

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLStrong

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLStrong

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLStrong

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLStrong

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLStrong
}

// Returns an HTML element that emphasizes text as important, typically displayed as bold.
func Strong() HTMLStrong {
	e := &htmlStrong{
		htmlElement: htmlElement{
			tag:           "strong",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlStrong struct {
	htmlElement
}

func (e *htmlStrong) Body(v ...UI) HTMLStrong {
	return e.setBody(FilterUIElems(v...)).(*htmlStrong)
}

func (e *htmlStrong) Text(v any) HTMLStrong {
	return e.Body(Text(v))
}

func (e *htmlStrong) Textf(format string, v ...any) HTMLStrong {
	return e.Body(Textf(format, v...))
}

func (e *htmlStrong) AccessKey(format string, v ...any) HTMLStrong {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlStrong) Aria(k string, v any) HTMLStrong {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlStrong) Attr(n string, v any) HTMLStrong {
	e.setAttr(n, v)
	return e
}

func (e *htmlStrong) Class(v ...string) HTMLStrong {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlStrong) ContentEditable(v bool) HTMLStrong {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlStrong) DataSet(k string, v any) HTMLStrong {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlStrong) DataSets(ds map[string]any) HTMLStrong {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlStrong) Dir(format string, v ...any) HTMLStrong {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlStrong) Draggable(v bool) HTMLStrong {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlStrong) Hidden(v bool) HTMLStrong {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlStrong) ID(format string, v ...any) HTMLStrong {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlStrong) Lang(format string, v ...any) HTMLStrong {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlStrong) Role(format string, v ...any) HTMLStrong {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlStrong) Spellcheck(v bool) HTMLStrong {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlStrong) Style(k, format string, v ...any) HTMLStrong {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlStrong) Styles(s map[string]string) HTMLStrong {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlStrong) TabIndex(v int) HTMLStrong {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlStrong) Title(format string, v ...any) HTMLStrong {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlStrong) On(event string, h EventHandler, options ...EventOption) HTMLStrong {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlStrong) OnBlur(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("blur", h, options...)
}

func (e *htmlStrong) OnChange(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("change", h, options...)
}

func (e *htmlStrong) OnClick(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("click", h, options...)
}

func (e *htmlStrong) OnContextMenu(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("contextmenu", h, options...)
}

func (e *htmlStrong) OnCopy(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("copy", h, options...)
}

func (e *htmlStrong) OnCut(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("cut", h, options...)
}

func (e *htmlStrong) OnDblClick(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dblclick", h, options...)
}

func (e *htmlStrong) OnDrag(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("drag", h, options...)
}

func (e *htmlStrong) OnDragEnd(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dragend", h, options...)
}

func (e *htmlStrong) OnDragEnter(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dragenter", h, options...)
}

func (e *htmlStrong) OnDragLeave(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dragleave", h, options...)
}

func (e *htmlStrong) OnDragOver(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dragover", h, options...)
}

func (e *htmlStrong) OnDragStart(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("dragstart", h, options...)
}

func (e *htmlStrong) OnDrop(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("drop", h, options...)
}

func (e *htmlStrong) OnFocus(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("focus", h, options...)
}

func (e *htmlStrong) OnInput(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("input", h, options...)
}

func (e *htmlStrong) OnInvalid(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("invalid", h, options...)
}

func (e *htmlStrong) OnKeyDown(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("keydown", h, options...)
}

func (e *htmlStrong) OnKeyPress(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("keypress", h, options...)
}

func (e *htmlStrong) OnKeyUp(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("keyup", h, options...)
}

func (e *htmlStrong) OnMouseDown(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mousedown", h, options...)
}

func (e *htmlStrong) OnMouseEnter(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mouseenter", h, options...)
}

func (e *htmlStrong) OnMouseLeave(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mouseleave", h, options...)
}

func (e *htmlStrong) OnMouseMove(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mousemove", h, options...)
}

func (e *htmlStrong) OnMouseOut(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mouseout", h, options...)
}

func (e *htmlStrong) OnMouseOver(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mouseover", h, options...)
}

func (e *htmlStrong) OnMouseUp(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("mouseup", h, options...)
}

func (e *htmlStrong) OnPaste(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("paste", h, options...)
}

func (e *htmlStrong) OnReset(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("reset", h, options...)
}

func (e *htmlStrong) OnScroll(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("scroll", h, options...)
}

func (e *htmlStrong) OnSearch(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("search", h, options...)
}

func (e *htmlStrong) OnSelect(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("select", h, options...)
}

func (e *htmlStrong) OnSubmit(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("submit", h, options...)
}

func (e *htmlStrong) OnWheel(h EventHandler, options ...EventOption) HTMLStrong {
	return e.On("wheel", h, options...)
}

func (e *htmlStrong) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlStrong) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlStrong) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlStrong) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlStrong) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlStrong) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "style" HTML element.
type HTMLStyle interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLStyle

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLStyle

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLStyle

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLStyle

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLStyle

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLStyle

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLStyle

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLStyle

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLStyle

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLStyle

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLStyle

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLStyle

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLStyle

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLStyle

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLStyle

	// Indicates the intended media or device for the linked document.
	Media(format string, v ...any) HTMLStyle

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLStyle

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLStyle

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLStyle

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLStyle

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLStyle

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLStyle

	// Designates the type of the element or its content. Can be called with specific format and values.
	Type(format string, v ...any) HTMLStyle

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLStyle

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the specified handler once the element has completely loaded.
	OnLoad(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLStyle

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLStyle

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLStyle

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLStyle
}

// Returns an HTML element that contains style information or references for a document.
func Style() HTMLStyle {
	e := &htmlStyle{
		htmlElement: htmlElement{
			tag:           "style",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlStyle struct {
	htmlElement
}

func (e *htmlStyle) Body(v ...UI) HTMLStyle {
	return e.setBody(FilterUIElems(v...)).(*htmlStyle)
}

func (e *htmlStyle) Text(v any) HTMLStyle {
	return e.Body(Text(v))
}

func (e *htmlStyle) Textf(format string, v ...any) HTMLStyle {
	return e.Body(Textf(format, v...))
}

func (e *htmlStyle) AccessKey(format string, v ...any) HTMLStyle {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Aria(k string, v any) HTMLStyle {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlStyle) Attr(n string, v any) HTMLStyle {
	e.setAttr(n, v)
	return e
}

func (e *htmlStyle) Class(v ...string) HTMLStyle {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlStyle) ContentEditable(v bool) HTMLStyle {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlStyle) DataSet(k string, v any) HTMLStyle {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlStyle) DataSets(ds map[string]any) HTMLStyle {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlStyle) Dir(format string, v ...any) HTMLStyle {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Draggable(v bool) HTMLStyle {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlStyle) Hidden(v bool) HTMLStyle {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlStyle) ID(format string, v ...any) HTMLStyle {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Lang(format string, v ...any) HTMLStyle {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Media(format string, v ...any) HTMLStyle {
	e.setAttr("media", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Role(format string, v ...any) HTMLStyle {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Spellcheck(v bool) HTMLStyle {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlStyle) Style(k, format string, v ...any) HTMLStyle {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlStyle) Styles(s map[string]string) HTMLStyle {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlStyle) TabIndex(v int) HTMLStyle {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlStyle) Title(format string, v ...any) HTMLStyle {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlStyle) Type(format string, v ...any) HTMLStyle {
	e.setAttr("type", FormatString(format, v...))
	return e
}

func (e *htmlStyle) On(event string, h EventHandler, options ...EventOption) HTMLStyle {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlStyle) OnBlur(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("blur", h, options...)
}

func (e *htmlStyle) OnChange(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("change", h, options...)
}

func (e *htmlStyle) OnClick(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("click", h, options...)
}

func (e *htmlStyle) OnContextMenu(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("contextmenu", h, options...)
}

func (e *htmlStyle) OnCopy(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("copy", h, options...)
}

func (e *htmlStyle) OnCut(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("cut", h, options...)
}

func (e *htmlStyle) OnDblClick(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dblclick", h, options...)
}

func (e *htmlStyle) OnDrag(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("drag", h, options...)
}

func (e *htmlStyle) OnDragEnd(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dragend", h, options...)
}

func (e *htmlStyle) OnDragEnter(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dragenter", h, options...)
}

func (e *htmlStyle) OnDragLeave(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dragleave", h, options...)
}

func (e *htmlStyle) OnDragOver(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dragover", h, options...)
}

func (e *htmlStyle) OnDragStart(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("dragstart", h, options...)
}

func (e *htmlStyle) OnDrop(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("drop", h, options...)
}

func (e *htmlStyle) OnFocus(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("focus", h, options...)
}

func (e *htmlStyle) OnInput(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("input", h, options...)
}

func (e *htmlStyle) OnInvalid(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("invalid", h, options...)
}

func (e *htmlStyle) OnKeyDown(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("keydown", h, options...)
}

func (e *htmlStyle) OnKeyPress(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("keypress", h, options...)
}

func (e *htmlStyle) OnKeyUp(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("keyup", h, options...)
}

func (e *htmlStyle) OnLoad(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("load", h, options...)
}

func (e *htmlStyle) OnMouseDown(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mousedown", h, options...)
}

func (e *htmlStyle) OnMouseEnter(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mouseenter", h, options...)
}

func (e *htmlStyle) OnMouseLeave(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mouseleave", h, options...)
}

func (e *htmlStyle) OnMouseMove(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mousemove", h, options...)
}

func (e *htmlStyle) OnMouseOut(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mouseout", h, options...)
}

func (e *htmlStyle) OnMouseOver(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mouseover", h, options...)
}

func (e *htmlStyle) OnMouseUp(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("mouseup", h, options...)
}

func (e *htmlStyle) OnPaste(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("paste", h, options...)
}

func (e *htmlStyle) OnReset(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("reset", h, options...)
}

func (e *htmlStyle) OnScroll(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("scroll", h, options...)
}

func (e *htmlStyle) OnSearch(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("search", h, options...)
}

func (e *htmlStyle) OnSelect(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("select", h, options...)
}

func (e *htmlStyle) OnSubmit(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("submit", h, options...)
}

func (e *htmlStyle) OnWheel(h EventHandler, options ...EventOption) HTMLStyle {
	return e.On("wheel", h, options...)
}

func (e *htmlStyle) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlStyle) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlStyle) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlStyle) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlStyle) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlStyle) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "sub" HTML element.
type HTMLSub interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSub

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSub

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSub

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSub

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSub

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSub

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSub

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSub

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSub

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSub

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSub

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSub

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSub

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSub

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSub

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSub

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSub

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSub

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSub

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSub

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSub

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSub

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSub

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSub

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSub

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSub

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSub

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSub

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSub

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSub

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSub

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSub

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSub

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSub

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSub

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSub
}

// Returns an HTML element that represents subscripted text, typically displayed lower and smaller than the main text.
func Sub() HTMLSub {
	e := &htmlSub{
		htmlElement: htmlElement{
			tag:           "sub",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSub struct {
	htmlElement
}

func (e *htmlSub) Body(v ...UI) HTMLSub {
	return e.setBody(FilterUIElems(v...)).(*htmlSub)
}

func (e *htmlSub) Text(v any) HTMLSub {
	return e.Body(Text(v))
}

func (e *htmlSub) Textf(format string, v ...any) HTMLSub {
	return e.Body(Textf(format, v...))
}

func (e *htmlSub) AccessKey(format string, v ...any) HTMLSub {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSub) Aria(k string, v any) HTMLSub {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSub) Attr(n string, v any) HTMLSub {
	e.setAttr(n, v)
	return e
}

func (e *htmlSub) Class(v ...string) HTMLSub {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSub) ContentEditable(v bool) HTMLSub {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSub) DataSet(k string, v any) HTMLSub {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSub) DataSets(ds map[string]any) HTMLSub {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSub) Dir(format string, v ...any) HTMLSub {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSub) Draggable(v bool) HTMLSub {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSub) Hidden(v bool) HTMLSub {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSub) ID(format string, v ...any) HTMLSub {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSub) Lang(format string, v ...any) HTMLSub {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSub) Role(format string, v ...any) HTMLSub {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSub) Spellcheck(v bool) HTMLSub {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSub) Style(k, format string, v ...any) HTMLSub {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSub) Styles(s map[string]string) HTMLSub {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSub) TabIndex(v int) HTMLSub {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSub) Title(format string, v ...any) HTMLSub {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSub) On(event string, h EventHandler, options ...EventOption) HTMLSub {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSub) OnBlur(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("blur", h, options...)
}

func (e *htmlSub) OnChange(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("change", h, options...)
}

func (e *htmlSub) OnClick(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("click", h, options...)
}

func (e *htmlSub) OnContextMenu(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSub) OnCopy(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("copy", h, options...)
}

func (e *htmlSub) OnCut(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("cut", h, options...)
}

func (e *htmlSub) OnDblClick(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dblclick", h, options...)
}

func (e *htmlSub) OnDrag(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("drag", h, options...)
}

func (e *htmlSub) OnDragEnd(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dragend", h, options...)
}

func (e *htmlSub) OnDragEnter(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dragenter", h, options...)
}

func (e *htmlSub) OnDragLeave(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dragleave", h, options...)
}

func (e *htmlSub) OnDragOver(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dragover", h, options...)
}

func (e *htmlSub) OnDragStart(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("dragstart", h, options...)
}

func (e *htmlSub) OnDrop(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("drop", h, options...)
}

func (e *htmlSub) OnFocus(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("focus", h, options...)
}

func (e *htmlSub) OnInput(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("input", h, options...)
}

func (e *htmlSub) OnInvalid(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("invalid", h, options...)
}

func (e *htmlSub) OnKeyDown(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("keydown", h, options...)
}

func (e *htmlSub) OnKeyPress(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("keypress", h, options...)
}

func (e *htmlSub) OnKeyUp(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("keyup", h, options...)
}

func (e *htmlSub) OnMouseDown(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mousedown", h, options...)
}

func (e *htmlSub) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSub) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSub) OnMouseMove(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mousemove", h, options...)
}

func (e *htmlSub) OnMouseOut(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mouseout", h, options...)
}

func (e *htmlSub) OnMouseOver(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mouseover", h, options...)
}

func (e *htmlSub) OnMouseUp(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("mouseup", h, options...)
}

func (e *htmlSub) OnPaste(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("paste", h, options...)
}

func (e *htmlSub) OnReset(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("reset", h, options...)
}

func (e *htmlSub) OnScroll(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("scroll", h, options...)
}

func (e *htmlSub) OnSearch(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("search", h, options...)
}

func (e *htmlSub) OnSelect(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("select", h, options...)
}

func (e *htmlSub) OnSubmit(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("submit", h, options...)
}

func (e *htmlSub) OnWheel(h EventHandler, options ...EventOption) HTMLSub {
	return e.On("wheel", h, options...)
}

func (e *htmlSub) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSub) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSub) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSub) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSub) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSub) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "summary" HTML element.
type HTMLSummary interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSummary

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSummary

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSummary

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSummary

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSummary

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSummary

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSummary

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSummary

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSummary

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSummary

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSummary

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSummary

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSummary

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSummary

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSummary

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSummary

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSummary

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSummary

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSummary

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSummary

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSummary

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSummary

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSummary

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSummary

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSummary

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSummary
}

// Returns an HTML element that provides a visible heading or label for a <details> element's content.
func Summary() HTMLSummary {
	e := &htmlSummary{
		htmlElement: htmlElement{
			tag:           "summary",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSummary struct {
	htmlElement
}

func (e *htmlSummary) Body(v ...UI) HTMLSummary {
	return e.setBody(FilterUIElems(v...)).(*htmlSummary)
}

func (e *htmlSummary) Text(v any) HTMLSummary {
	return e.Body(Text(v))
}

func (e *htmlSummary) Textf(format string, v ...any) HTMLSummary {
	return e.Body(Textf(format, v...))
}

func (e *htmlSummary) AccessKey(format string, v ...any) HTMLSummary {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSummary) Aria(k string, v any) HTMLSummary {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSummary) Attr(n string, v any) HTMLSummary {
	e.setAttr(n, v)
	return e
}

func (e *htmlSummary) Class(v ...string) HTMLSummary {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSummary) ContentEditable(v bool) HTMLSummary {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSummary) DataSet(k string, v any) HTMLSummary {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSummary) DataSets(ds map[string]any) HTMLSummary {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSummary) Dir(format string, v ...any) HTMLSummary {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSummary) Draggable(v bool) HTMLSummary {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSummary) Hidden(v bool) HTMLSummary {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSummary) ID(format string, v ...any) HTMLSummary {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSummary) Lang(format string, v ...any) HTMLSummary {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSummary) Role(format string, v ...any) HTMLSummary {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSummary) Spellcheck(v bool) HTMLSummary {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSummary) Style(k, format string, v ...any) HTMLSummary {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSummary) Styles(s map[string]string) HTMLSummary {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSummary) TabIndex(v int) HTMLSummary {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSummary) Title(format string, v ...any) HTMLSummary {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSummary) On(event string, h EventHandler, options ...EventOption) HTMLSummary {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSummary) OnBlur(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("blur", h, options...)
}

func (e *htmlSummary) OnChange(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("change", h, options...)
}

func (e *htmlSummary) OnClick(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("click", h, options...)
}

func (e *htmlSummary) OnContextMenu(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSummary) OnCopy(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("copy", h, options...)
}

func (e *htmlSummary) OnCut(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("cut", h, options...)
}

func (e *htmlSummary) OnDblClick(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dblclick", h, options...)
}

func (e *htmlSummary) OnDrag(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("drag", h, options...)
}

func (e *htmlSummary) OnDragEnd(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dragend", h, options...)
}

func (e *htmlSummary) OnDragEnter(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dragenter", h, options...)
}

func (e *htmlSummary) OnDragLeave(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dragleave", h, options...)
}

func (e *htmlSummary) OnDragOver(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dragover", h, options...)
}

func (e *htmlSummary) OnDragStart(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("dragstart", h, options...)
}

func (e *htmlSummary) OnDrop(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("drop", h, options...)
}

func (e *htmlSummary) OnFocus(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("focus", h, options...)
}

func (e *htmlSummary) OnInput(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("input", h, options...)
}

func (e *htmlSummary) OnInvalid(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("invalid", h, options...)
}

func (e *htmlSummary) OnKeyDown(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("keydown", h, options...)
}

func (e *htmlSummary) OnKeyPress(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("keypress", h, options...)
}

func (e *htmlSummary) OnKeyUp(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("keyup", h, options...)
}

func (e *htmlSummary) OnMouseDown(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mousedown", h, options...)
}

func (e *htmlSummary) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSummary) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSummary) OnMouseMove(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mousemove", h, options...)
}

func (e *htmlSummary) OnMouseOut(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mouseout", h, options...)
}

func (e *htmlSummary) OnMouseOver(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mouseover", h, options...)
}

func (e *htmlSummary) OnMouseUp(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("mouseup", h, options...)
}

func (e *htmlSummary) OnPaste(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("paste", h, options...)
}

func (e *htmlSummary) OnReset(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("reset", h, options...)
}

func (e *htmlSummary) OnScroll(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("scroll", h, options...)
}

func (e *htmlSummary) OnSearch(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("search", h, options...)
}

func (e *htmlSummary) OnSelect(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("select", h, options...)
}

func (e *htmlSummary) OnSubmit(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("submit", h, options...)
}

func (e *htmlSummary) OnWheel(h EventHandler, options ...EventOption) HTMLSummary {
	return e.On("wheel", h, options...)
}

func (e *htmlSummary) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSummary) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSummary) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSummary) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSummary) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSummary) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "sup" HTML element.
type HTMLSup interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLSup

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLSup

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLSup

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLSup

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLSup

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLSup

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLSup

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLSup

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLSup

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLSup

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLSup

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLSup

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLSup

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLSup

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLSup

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLSup

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLSup

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLSup

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLSup

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLSup

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLSup

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLSup

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLSup

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLSup

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLSup

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLSup

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLSup

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLSup

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLSup

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLSup

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLSup

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLSup

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLSup

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLSup

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLSup

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLSup
}

// Returns an HTML element that represents superscripted text, typically displayed higher and smaller than the main text.
func Sup() HTMLSup {
	e := &htmlSup{
		htmlElement: htmlElement{
			tag:           "sup",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlSup struct {
	htmlElement
}

func (e *htmlSup) Body(v ...UI) HTMLSup {
	return e.setBody(FilterUIElems(v...)).(*htmlSup)
}

func (e *htmlSup) Text(v any) HTMLSup {
	return e.Body(Text(v))
}

func (e *htmlSup) Textf(format string, v ...any) HTMLSup {
	return e.Body(Textf(format, v...))
}

func (e *htmlSup) AccessKey(format string, v ...any) HTMLSup {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlSup) Aria(k string, v any) HTMLSup {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSup) Attr(n string, v any) HTMLSup {
	e.setAttr(n, v)
	return e
}

func (e *htmlSup) Class(v ...string) HTMLSup {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlSup) ContentEditable(v bool) HTMLSup {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlSup) DataSet(k string, v any) HTMLSup {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlSup) DataSets(ds map[string]any) HTMLSup {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlSup) Dir(format string, v ...any) HTMLSup {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlSup) Draggable(v bool) HTMLSup {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlSup) Hidden(v bool) HTMLSup {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlSup) ID(format string, v ...any) HTMLSup {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlSup) Lang(format string, v ...any) HTMLSup {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlSup) Role(format string, v ...any) HTMLSup {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlSup) Spellcheck(v bool) HTMLSup {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlSup) Style(k, format string, v ...any) HTMLSup {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlSup) Styles(s map[string]string) HTMLSup {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlSup) TabIndex(v int) HTMLSup {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlSup) Title(format string, v ...any) HTMLSup {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlSup) On(event string, h EventHandler, options ...EventOption) HTMLSup {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlSup) OnBlur(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("blur", h, options...)
}

func (e *htmlSup) OnChange(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("change", h, options...)
}

func (e *htmlSup) OnClick(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("click", h, options...)
}

func (e *htmlSup) OnContextMenu(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("contextmenu", h, options...)
}

func (e *htmlSup) OnCopy(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("copy", h, options...)
}

func (e *htmlSup) OnCut(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("cut", h, options...)
}

func (e *htmlSup) OnDblClick(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dblclick", h, options...)
}

func (e *htmlSup) OnDrag(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("drag", h, options...)
}

func (e *htmlSup) OnDragEnd(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dragend", h, options...)
}

func (e *htmlSup) OnDragEnter(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dragenter", h, options...)
}

func (e *htmlSup) OnDragLeave(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dragleave", h, options...)
}

func (e *htmlSup) OnDragOver(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dragover", h, options...)
}

func (e *htmlSup) OnDragStart(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("dragstart", h, options...)
}

func (e *htmlSup) OnDrop(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("drop", h, options...)
}

func (e *htmlSup) OnFocus(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("focus", h, options...)
}

func (e *htmlSup) OnInput(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("input", h, options...)
}

func (e *htmlSup) OnInvalid(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("invalid", h, options...)
}

func (e *htmlSup) OnKeyDown(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("keydown", h, options...)
}

func (e *htmlSup) OnKeyPress(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("keypress", h, options...)
}

func (e *htmlSup) OnKeyUp(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("keyup", h, options...)
}

func (e *htmlSup) OnMouseDown(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mousedown", h, options...)
}

func (e *htmlSup) OnMouseEnter(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mouseenter", h, options...)
}

func (e *htmlSup) OnMouseLeave(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mouseleave", h, options...)
}

func (e *htmlSup) OnMouseMove(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mousemove", h, options...)
}

func (e *htmlSup) OnMouseOut(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mouseout", h, options...)
}

func (e *htmlSup) OnMouseOver(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mouseover", h, options...)
}

func (e *htmlSup) OnMouseUp(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("mouseup", h, options...)
}

func (e *htmlSup) OnPaste(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("paste", h, options...)
}

func (e *htmlSup) OnReset(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("reset", h, options...)
}

func (e *htmlSup) OnScroll(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("scroll", h, options...)
}

func (e *htmlSup) OnSearch(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("search", h, options...)
}

func (e *htmlSup) OnSelect(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("select", h, options...)
}

func (e *htmlSup) OnSubmit(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("submit", h, options...)
}

func (e *htmlSup) OnWheel(h EventHandler, options ...EventOption) HTMLSup {
	return e.On("wheel", h, options...)
}

func (e *htmlSup) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlSup) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlSup) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlSup) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlSup) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlSup) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "table" HTML element.
type HTMLTable interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTable

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTable

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTable

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTable

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTable

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTable

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTable

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTable

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTable

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTable

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTable

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTable

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTable

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTable

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTable

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTable

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTable

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTable

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTable

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTable

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTable

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTable

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTable

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTable

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTable

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTable

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTable

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTable

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTable

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTable

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTable

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTable

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTable

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTable

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTable

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTable
}

// Returns an HTML element that represents a table structure.
func Table() HTMLTable {
	e := &htmlTable{
		htmlElement: htmlElement{
			tag:           "table",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTable struct {
	htmlElement
}

func (e *htmlTable) Body(v ...UI) HTMLTable {
	return e.setBody(FilterUIElems(v...)).(*htmlTable)
}

func (e *htmlTable) Text(v any) HTMLTable {
	return e.Body(Text(v))
}

func (e *htmlTable) Textf(format string, v ...any) HTMLTable {
	return e.Body(Textf(format, v...))
}

func (e *htmlTable) AccessKey(format string, v ...any) HTMLTable {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTable) Aria(k string, v any) HTMLTable {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTable) Attr(n string, v any) HTMLTable {
	e.setAttr(n, v)
	return e
}

func (e *htmlTable) Class(v ...string) HTMLTable {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTable) ContentEditable(v bool) HTMLTable {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTable) DataSet(k string, v any) HTMLTable {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTable) DataSets(ds map[string]any) HTMLTable {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTable) Dir(format string, v ...any) HTMLTable {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTable) Draggable(v bool) HTMLTable {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTable) Hidden(v bool) HTMLTable {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTable) ID(format string, v ...any) HTMLTable {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTable) Lang(format string, v ...any) HTMLTable {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTable) Role(format string, v ...any) HTMLTable {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTable) Spellcheck(v bool) HTMLTable {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTable) Style(k, format string, v ...any) HTMLTable {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTable) Styles(s map[string]string) HTMLTable {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTable) TabIndex(v int) HTMLTable {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTable) Title(format string, v ...any) HTMLTable {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTable) On(event string, h EventHandler, options ...EventOption) HTMLTable {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTable) OnBlur(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("blur", h, options...)
}

func (e *htmlTable) OnChange(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("change", h, options...)
}

func (e *htmlTable) OnClick(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("click", h, options...)
}

func (e *htmlTable) OnContextMenu(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTable) OnCopy(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("copy", h, options...)
}

func (e *htmlTable) OnCut(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("cut", h, options...)
}

func (e *htmlTable) OnDblClick(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dblclick", h, options...)
}

func (e *htmlTable) OnDrag(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("drag", h, options...)
}

func (e *htmlTable) OnDragEnd(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dragend", h, options...)
}

func (e *htmlTable) OnDragEnter(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dragenter", h, options...)
}

func (e *htmlTable) OnDragLeave(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dragleave", h, options...)
}

func (e *htmlTable) OnDragOver(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dragover", h, options...)
}

func (e *htmlTable) OnDragStart(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("dragstart", h, options...)
}

func (e *htmlTable) OnDrop(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("drop", h, options...)
}

func (e *htmlTable) OnFocus(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("focus", h, options...)
}

func (e *htmlTable) OnInput(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("input", h, options...)
}

func (e *htmlTable) OnInvalid(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("invalid", h, options...)
}

func (e *htmlTable) OnKeyDown(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("keydown", h, options...)
}

func (e *htmlTable) OnKeyPress(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("keypress", h, options...)
}

func (e *htmlTable) OnKeyUp(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("keyup", h, options...)
}

func (e *htmlTable) OnMouseDown(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mousedown", h, options...)
}

func (e *htmlTable) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTable) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTable) OnMouseMove(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mousemove", h, options...)
}

func (e *htmlTable) OnMouseOut(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mouseout", h, options...)
}

func (e *htmlTable) OnMouseOver(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mouseover", h, options...)
}

func (e *htmlTable) OnMouseUp(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("mouseup", h, options...)
}

func (e *htmlTable) OnPaste(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("paste", h, options...)
}

func (e *htmlTable) OnReset(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("reset", h, options...)
}

func (e *htmlTable) OnScroll(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("scroll", h, options...)
}

func (e *htmlTable) OnSearch(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("search", h, options...)
}

func (e *htmlTable) OnSelect(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("select", h, options...)
}

func (e *htmlTable) OnSubmit(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("submit", h, options...)
}

func (e *htmlTable) OnWheel(h EventHandler, options ...EventOption) HTMLTable {
	return e.On("wheel", h, options...)
}

func (e *htmlTable) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTable) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTable) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTable) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTable) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTable) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "tbody" HTML element.
type HTMLTBody interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTBody

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTBody

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTBody

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTBody

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTBody

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTBody

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTBody

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTBody

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTBody

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTBody

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTBody

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTBody

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTBody

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTBody

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTBody

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTBody

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTBody

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTBody

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTBody

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTBody

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTBody

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTBody

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTBody

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTBody

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTBody

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTBody
}

// Returns an HTML element that groups the main content rows in a table.
func TBody() HTMLTBody {
	e := &htmlTBody{
		htmlElement: htmlElement{
			tag:           "tbody",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTBody struct {
	htmlElement
}

func (e *htmlTBody) Body(v ...UI) HTMLTBody {
	return e.setBody(FilterUIElems(v...)).(*htmlTBody)
}

func (e *htmlTBody) Text(v any) HTMLTBody {
	return e.Body(Text(v))
}

func (e *htmlTBody) Textf(format string, v ...any) HTMLTBody {
	return e.Body(Textf(format, v...))
}

func (e *htmlTBody) AccessKey(format string, v ...any) HTMLTBody {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTBody) Aria(k string, v any) HTMLTBody {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTBody) Attr(n string, v any) HTMLTBody {
	e.setAttr(n, v)
	return e
}

func (e *htmlTBody) Class(v ...string) HTMLTBody {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTBody) ContentEditable(v bool) HTMLTBody {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTBody) DataSet(k string, v any) HTMLTBody {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTBody) DataSets(ds map[string]any) HTMLTBody {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTBody) Dir(format string, v ...any) HTMLTBody {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTBody) Draggable(v bool) HTMLTBody {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTBody) Hidden(v bool) HTMLTBody {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTBody) ID(format string, v ...any) HTMLTBody {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTBody) Lang(format string, v ...any) HTMLTBody {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTBody) Role(format string, v ...any) HTMLTBody {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTBody) Spellcheck(v bool) HTMLTBody {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTBody) Style(k, format string, v ...any) HTMLTBody {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTBody) Styles(s map[string]string) HTMLTBody {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTBody) TabIndex(v int) HTMLTBody {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTBody) Title(format string, v ...any) HTMLTBody {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTBody) On(event string, h EventHandler, options ...EventOption) HTMLTBody {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTBody) OnBlur(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("blur", h, options...)
}

func (e *htmlTBody) OnChange(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("change", h, options...)
}

func (e *htmlTBody) OnClick(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("click", h, options...)
}

func (e *htmlTBody) OnContextMenu(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTBody) OnCopy(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("copy", h, options...)
}

func (e *htmlTBody) OnCut(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("cut", h, options...)
}

func (e *htmlTBody) OnDblClick(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dblclick", h, options...)
}

func (e *htmlTBody) OnDrag(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("drag", h, options...)
}

func (e *htmlTBody) OnDragEnd(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dragend", h, options...)
}

func (e *htmlTBody) OnDragEnter(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dragenter", h, options...)
}

func (e *htmlTBody) OnDragLeave(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dragleave", h, options...)
}

func (e *htmlTBody) OnDragOver(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dragover", h, options...)
}

func (e *htmlTBody) OnDragStart(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("dragstart", h, options...)
}

func (e *htmlTBody) OnDrop(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("drop", h, options...)
}

func (e *htmlTBody) OnFocus(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("focus", h, options...)
}

func (e *htmlTBody) OnInput(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("input", h, options...)
}

func (e *htmlTBody) OnInvalid(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("invalid", h, options...)
}

func (e *htmlTBody) OnKeyDown(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("keydown", h, options...)
}

func (e *htmlTBody) OnKeyPress(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("keypress", h, options...)
}

func (e *htmlTBody) OnKeyUp(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("keyup", h, options...)
}

func (e *htmlTBody) OnMouseDown(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mousedown", h, options...)
}

func (e *htmlTBody) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTBody) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTBody) OnMouseMove(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mousemove", h, options...)
}

func (e *htmlTBody) OnMouseOut(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mouseout", h, options...)
}

func (e *htmlTBody) OnMouseOver(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mouseover", h, options...)
}

func (e *htmlTBody) OnMouseUp(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("mouseup", h, options...)
}

func (e *htmlTBody) OnPaste(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("paste", h, options...)
}

func (e *htmlTBody) OnReset(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("reset", h, options...)
}

func (e *htmlTBody) OnScroll(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("scroll", h, options...)
}

func (e *htmlTBody) OnSearch(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("search", h, options...)
}

func (e *htmlTBody) OnSelect(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("select", h, options...)
}

func (e *htmlTBody) OnSubmit(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("submit", h, options...)
}

func (e *htmlTBody) OnWheel(h EventHandler, options ...EventOption) HTMLTBody {
	return e.On("wheel", h, options...)
}

func (e *htmlTBody) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTBody) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTBody) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTBody) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTBody) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTBody) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "td" HTML element.
type HTMLTd interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTd

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTd

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTd

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTd

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTd

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTd

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTd

	// Denotes how many columns a table cell should span across, allowing cells to occupy space of multiple columns.
	ColSpan(v int) HTMLTd

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTd

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTd

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTd

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTd

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTd

	// Designates one or more header cells to which a table cell is related.
	Headers(format string, v ...any) HTMLTd

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTd

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTd

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTd

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTd

	// Determines how many rows a table cell will span vertically.
	Rowspan(v int) HTMLTd

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTd

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTd

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTd

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTd

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTd

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTd

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTd

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTd

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTd

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTd

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTd

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTd

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTd

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTd

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTd

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTd

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTd

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTd

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTd

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTd
}

// Returns an HTML element that represents a data cell in a table.
func Td() HTMLTd {
	e := &htmlTd{
		htmlElement: htmlElement{
			tag:           "td",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTd struct {
	htmlElement
}

func (e *htmlTd) Body(v ...UI) HTMLTd {
	return e.setBody(FilterUIElems(v...)).(*htmlTd)
}

func (e *htmlTd) Text(v any) HTMLTd {
	return e.Body(Text(v))
}

func (e *htmlTd) Textf(format string, v ...any) HTMLTd {
	return e.Body(Textf(format, v...))
}

func (e *htmlTd) AccessKey(format string, v ...any) HTMLTd {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTd) Aria(k string, v any) HTMLTd {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTd) Attr(n string, v any) HTMLTd {
	e.setAttr(n, v)
	return e
}

func (e *htmlTd) Class(v ...string) HTMLTd {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTd) ColSpan(v int) HTMLTd {
	e.setAttr("colspan", v)
	return e
}

func (e *htmlTd) ContentEditable(v bool) HTMLTd {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTd) DataSet(k string, v any) HTMLTd {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTd) DataSets(ds map[string]any) HTMLTd {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTd) Dir(format string, v ...any) HTMLTd {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTd) Draggable(v bool) HTMLTd {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTd) Headers(format string, v ...any) HTMLTd {
	e.setAttr("headers", FormatString(format, v...))
	return e
}

func (e *htmlTd) Hidden(v bool) HTMLTd {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTd) ID(format string, v ...any) HTMLTd {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTd) Lang(format string, v ...any) HTMLTd {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTd) Role(format string, v ...any) HTMLTd {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTd) Rowspan(v int) HTMLTd {
	e.setAttr("rowspan", v)
	return e
}

func (e *htmlTd) Spellcheck(v bool) HTMLTd {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTd) Style(k, format string, v ...any) HTMLTd {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTd) Styles(s map[string]string) HTMLTd {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTd) TabIndex(v int) HTMLTd {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTd) Title(format string, v ...any) HTMLTd {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTd) On(event string, h EventHandler, options ...EventOption) HTMLTd {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTd) OnBlur(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("blur", h, options...)
}

func (e *htmlTd) OnChange(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("change", h, options...)
}

func (e *htmlTd) OnClick(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("click", h, options...)
}

func (e *htmlTd) OnContextMenu(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTd) OnCopy(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("copy", h, options...)
}

func (e *htmlTd) OnCut(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("cut", h, options...)
}

func (e *htmlTd) OnDblClick(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dblclick", h, options...)
}

func (e *htmlTd) OnDrag(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("drag", h, options...)
}

func (e *htmlTd) OnDragEnd(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dragend", h, options...)
}

func (e *htmlTd) OnDragEnter(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dragenter", h, options...)
}

func (e *htmlTd) OnDragLeave(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dragleave", h, options...)
}

func (e *htmlTd) OnDragOver(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dragover", h, options...)
}

func (e *htmlTd) OnDragStart(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("dragstart", h, options...)
}

func (e *htmlTd) OnDrop(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("drop", h, options...)
}

func (e *htmlTd) OnFocus(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("focus", h, options...)
}

func (e *htmlTd) OnInput(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("input", h, options...)
}

func (e *htmlTd) OnInvalid(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("invalid", h, options...)
}

func (e *htmlTd) OnKeyDown(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("keydown", h, options...)
}

func (e *htmlTd) OnKeyPress(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("keypress", h, options...)
}

func (e *htmlTd) OnKeyUp(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("keyup", h, options...)
}

func (e *htmlTd) OnMouseDown(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mousedown", h, options...)
}

func (e *htmlTd) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTd) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTd) OnMouseMove(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mousemove", h, options...)
}

func (e *htmlTd) OnMouseOut(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mouseout", h, options...)
}

func (e *htmlTd) OnMouseOver(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mouseover", h, options...)
}

func (e *htmlTd) OnMouseUp(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("mouseup", h, options...)
}

func (e *htmlTd) OnPaste(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("paste", h, options...)
}

func (e *htmlTd) OnReset(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("reset", h, options...)
}

func (e *htmlTd) OnScroll(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("scroll", h, options...)
}

func (e *htmlTd) OnSearch(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("search", h, options...)
}

func (e *htmlTd) OnSelect(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("select", h, options...)
}

func (e *htmlTd) OnSubmit(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("submit", h, options...)
}

func (e *htmlTd) OnWheel(h EventHandler, options ...EventOption) HTMLTd {
	return e.On("wheel", h, options...)
}

func (e *htmlTd) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTd) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTd) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTd) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTd) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTd) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "template" HTML element.
type HTMLTemplate interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTemplate

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTemplate

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTemplate

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTemplate

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTemplate

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTemplate

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTemplate

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTemplate

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTemplate

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTemplate

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTemplate

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTemplate

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTemplate

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTemplate

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTemplate

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTemplate

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTemplate

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTemplate

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTemplate

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTemplate

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTemplate

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTemplate
}

// Returns an HTML element that holds client-side content templates for dynamic rendering.
func Template() HTMLTemplate {
	e := &htmlTemplate{
		htmlElement: htmlElement{
			tag:           "template",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTemplate struct {
	htmlElement
}

func (e *htmlTemplate) Body(v ...UI) HTMLTemplate {
	return e.setBody(FilterUIElems(v...)).(*htmlTemplate)
}

func (e *htmlTemplate) Text(v any) HTMLTemplate {
	return e.Body(Text(v))
}

func (e *htmlTemplate) Textf(format string, v ...any) HTMLTemplate {
	return e.Body(Textf(format, v...))
}

func (e *htmlTemplate) AccessKey(format string, v ...any) HTMLTemplate {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Aria(k string, v any) HTMLTemplate {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTemplate) Attr(n string, v any) HTMLTemplate {
	e.setAttr(n, v)
	return e
}

func (e *htmlTemplate) Class(v ...string) HTMLTemplate {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTemplate) ContentEditable(v bool) HTMLTemplate {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTemplate) DataSet(k string, v any) HTMLTemplate {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTemplate) DataSets(ds map[string]any) HTMLTemplate {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTemplate) Dir(format string, v ...any) HTMLTemplate {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Draggable(v bool) HTMLTemplate {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTemplate) Hidden(v bool) HTMLTemplate {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTemplate) ID(format string, v ...any) HTMLTemplate {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Lang(format string, v ...any) HTMLTemplate {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Role(format string, v ...any) HTMLTemplate {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Spellcheck(v bool) HTMLTemplate {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTemplate) Style(k, format string, v ...any) HTMLTemplate {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTemplate) Styles(s map[string]string) HTMLTemplate {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTemplate) TabIndex(v int) HTMLTemplate {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTemplate) Title(format string, v ...any) HTMLTemplate {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTemplate) On(event string, h EventHandler, options ...EventOption) HTMLTemplate {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTemplate) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTemplate) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTemplate) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTemplate) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTemplate) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTemplate) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "textarea" HTML element.
type HTMLTextarea interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTextarea

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTextarea

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTextarea

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTextarea

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTextarea

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTextarea

	// Instructs the browser to focus this element automatically when the page loads.
	AutoFocus(v bool) HTMLTextarea

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTextarea

	// Defines the visible width, in character widths, of a text area element.
	Cols(v int) HTMLTextarea

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTextarea

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTextarea

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTextarea

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTextarea

	// Instructs the browser to also submit the text direction of a form field when the form is submitted.
	DirName(format string, v ...any) HTMLTextarea

	// Deactivates an element, rendering it uninteractive and visually distinct.
	Disabled(v bool) HTMLTextarea

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTextarea

	// Identifies the form to which the element belongs.
	Form(format string, v ...any) HTMLTextarea

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTextarea

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTextarea

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTextarea

	// Defines the maximum number of characters permissible in an element.
	MaxLength(v int) HTMLTextarea

	// Assigns a name to the element.
	Name(format string, v ...any) HTMLTextarea

	// Provides a brief hint describing the expected value of the element.
	Placeholder(format string, v ...any) HTMLTextarea

	// Indicates that the element's value cannot be edited by the user.
	ReadOnly(v bool) HTMLTextarea

	// Indicates that the element must contain a value before form submission.
	Required(v bool) HTMLTextarea

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTextarea

	// Sets the number of visible lines in a textarea element.
	Rows(v int) HTMLTextarea

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTextarea

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTextarea

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTextarea

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTextarea

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTextarea

	// Determines how the text inside a text area is wrapped when submitted in a form. Can be called with specific format and values.
	Wrap(format string, v ...any) HTMLTextarea

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTextarea

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTextarea

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTextarea

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTextarea
}

// Returns an HTML element that provides a multiline text input control.
func Textarea() HTMLTextarea {
	e := &htmlTextarea{
		htmlElement: htmlElement{
			tag:           "textarea",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTextarea struct {
	htmlElement
}

func (e *htmlTextarea) Body(v ...UI) HTMLTextarea {
	return e.setBody(FilterUIElems(v...)).(*htmlTextarea)
}

func (e *htmlTextarea) Text(v any) HTMLTextarea {
	e.setAttr("value", v)
	return e
}

func (e *htmlTextarea) Textf(format string, v ...any) HTMLTextarea {
	e.setAttr("value", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) AccessKey(format string, v ...any) HTMLTextarea {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Aria(k string, v any) HTMLTextarea {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTextarea) Attr(n string, v any) HTMLTextarea {
	e.setAttr(n, v)
	return e
}

func (e *htmlTextarea) AutoFocus(v bool) HTMLTextarea {
	e.setAttr("autofocus", v)
	return e
}

func (e *htmlTextarea) Class(v ...string) HTMLTextarea {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTextarea) Cols(v int) HTMLTextarea {
	e.setAttr("cols", v)
	return e
}

func (e *htmlTextarea) ContentEditable(v bool) HTMLTextarea {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTextarea) DataSet(k string, v any) HTMLTextarea {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTextarea) DataSets(ds map[string]any) HTMLTextarea {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTextarea) Dir(format string, v ...any) HTMLTextarea {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) DirName(format string, v ...any) HTMLTextarea {
	e.setAttr("dirname", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Disabled(v bool) HTMLTextarea {
	e.setAttr("disabled", v)
	return e
}

func (e *htmlTextarea) Draggable(v bool) HTMLTextarea {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTextarea) Form(format string, v ...any) HTMLTextarea {
	e.setAttr("form", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Hidden(v bool) HTMLTextarea {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTextarea) ID(format string, v ...any) HTMLTextarea {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Lang(format string, v ...any) HTMLTextarea {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) MaxLength(v int) HTMLTextarea {
	e.setAttr("maxlength", v)
	return e
}

func (e *htmlTextarea) Name(format string, v ...any) HTMLTextarea {
	e.setAttr("name", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Placeholder(format string, v ...any) HTMLTextarea {
	e.setAttr("placeholder", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) ReadOnly(v bool) HTMLTextarea {
	e.setAttr("readonly", v)
	return e
}

func (e *htmlTextarea) Required(v bool) HTMLTextarea {
	e.setAttr("required", v)
	return e
}

func (e *htmlTextarea) Role(format string, v ...any) HTMLTextarea {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Rows(v int) HTMLTextarea {
	e.setAttr("rows", v)
	return e
}

func (e *htmlTextarea) Spellcheck(v bool) HTMLTextarea {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTextarea) Style(k, format string, v ...any) HTMLTextarea {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Styles(s map[string]string) HTMLTextarea {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTextarea) TabIndex(v int) HTMLTextarea {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTextarea) Title(format string, v ...any) HTMLTextarea {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) Wrap(format string, v ...any) HTMLTextarea {
	e.setAttr("wrap", FormatString(format, v...))
	return e
}

func (e *htmlTextarea) On(event string, h EventHandler, options ...EventOption) HTMLTextarea {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTextarea) OnBlur(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("blur", h, options...)
}

func (e *htmlTextarea) OnChange(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("change", h, options...)
}

func (e *htmlTextarea) OnClick(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("click", h, options...)
}

func (e *htmlTextarea) OnContextMenu(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTextarea) OnCopy(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("copy", h, options...)
}

func (e *htmlTextarea) OnCut(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("cut", h, options...)
}

func (e *htmlTextarea) OnDblClick(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dblclick", h, options...)
}

func (e *htmlTextarea) OnDrag(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("drag", h, options...)
}

func (e *htmlTextarea) OnDragEnd(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dragend", h, options...)
}

func (e *htmlTextarea) OnDragEnter(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dragenter", h, options...)
}

func (e *htmlTextarea) OnDragLeave(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dragleave", h, options...)
}

func (e *htmlTextarea) OnDragOver(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dragover", h, options...)
}

func (e *htmlTextarea) OnDragStart(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("dragstart", h, options...)
}

func (e *htmlTextarea) OnDrop(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("drop", h, options...)
}

func (e *htmlTextarea) OnFocus(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("focus", h, options...)
}

func (e *htmlTextarea) OnInput(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("input", h, options...)
}

func (e *htmlTextarea) OnInvalid(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("invalid", h, options...)
}

func (e *htmlTextarea) OnKeyDown(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("keydown", h, options...)
}

func (e *htmlTextarea) OnKeyPress(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("keypress", h, options...)
}

func (e *htmlTextarea) OnKeyUp(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("keyup", h, options...)
}

func (e *htmlTextarea) OnMouseDown(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mousedown", h, options...)
}

func (e *htmlTextarea) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTextarea) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTextarea) OnMouseMove(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mousemove", h, options...)
}

func (e *htmlTextarea) OnMouseOut(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mouseout", h, options...)
}

func (e *htmlTextarea) OnMouseOver(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mouseover", h, options...)
}

func (e *htmlTextarea) OnMouseUp(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("mouseup", h, options...)
}

func (e *htmlTextarea) OnPaste(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("paste", h, options...)
}

func (e *htmlTextarea) OnReset(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("reset", h, options...)
}

func (e *htmlTextarea) OnScroll(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("scroll", h, options...)
}

func (e *htmlTextarea) OnSearch(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("search", h, options...)
}

func (e *htmlTextarea) OnSelect(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("select", h, options...)
}

func (e *htmlTextarea) OnSubmit(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("submit", h, options...)
}

func (e *htmlTextarea) OnWheel(h EventHandler, options ...EventOption) HTMLTextarea {
	return e.On("wheel", h, options...)
}

func (e *htmlTextarea) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTextarea) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTextarea) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTextarea) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTextarea) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTextarea) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "tfoot" HTML element.
type HTMLTFoot interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTFoot

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTFoot

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTFoot

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTFoot

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTFoot

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTFoot

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTFoot

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTFoot

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTFoot

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTFoot

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTFoot

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTFoot

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTFoot

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTFoot

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTFoot

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTFoot

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTFoot

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTFoot

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTFoot

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTFoot

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTFoot

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTFoot

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTFoot

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTFoot

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTFoot
}

// Returns an HTML element that groups the footer rows in a table.
func TFoot() HTMLTFoot {
	e := &htmlTFoot{
		htmlElement: htmlElement{
			tag:           "tfoot",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTFoot struct {
	htmlElement
}

func (e *htmlTFoot) Body(v ...UI) HTMLTFoot {
	return e.setBody(FilterUIElems(v...)).(*htmlTFoot)
}

func (e *htmlTFoot) Text(v any) HTMLTFoot {
	return e.Body(Text(v))
}

func (e *htmlTFoot) Textf(format string, v ...any) HTMLTFoot {
	return e.Body(Textf(format, v...))
}

func (e *htmlTFoot) AccessKey(format string, v ...any) HTMLTFoot {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Aria(k string, v any) HTMLTFoot {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTFoot) Attr(n string, v any) HTMLTFoot {
	e.setAttr(n, v)
	return e
}

func (e *htmlTFoot) Class(v ...string) HTMLTFoot {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTFoot) ContentEditable(v bool) HTMLTFoot {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTFoot) DataSet(k string, v any) HTMLTFoot {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTFoot) DataSets(ds map[string]any) HTMLTFoot {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTFoot) Dir(format string, v ...any) HTMLTFoot {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Draggable(v bool) HTMLTFoot {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTFoot) Hidden(v bool) HTMLTFoot {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTFoot) ID(format string, v ...any) HTMLTFoot {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Lang(format string, v ...any) HTMLTFoot {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Role(format string, v ...any) HTMLTFoot {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Spellcheck(v bool) HTMLTFoot {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTFoot) Style(k, format string, v ...any) HTMLTFoot {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTFoot) Styles(s map[string]string) HTMLTFoot {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTFoot) TabIndex(v int) HTMLTFoot {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTFoot) Title(format string, v ...any) HTMLTFoot {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTFoot) On(event string, h EventHandler, options ...EventOption) HTMLTFoot {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTFoot) OnBlur(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("blur", h, options...)
}

func (e *htmlTFoot) OnChange(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("change", h, options...)
}

func (e *htmlTFoot) OnClick(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("click", h, options...)
}

func (e *htmlTFoot) OnContextMenu(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTFoot) OnCopy(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("copy", h, options...)
}

func (e *htmlTFoot) OnCut(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("cut", h, options...)
}

func (e *htmlTFoot) OnDblClick(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dblclick", h, options...)
}

func (e *htmlTFoot) OnDrag(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("drag", h, options...)
}

func (e *htmlTFoot) OnDragEnd(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dragend", h, options...)
}

func (e *htmlTFoot) OnDragEnter(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dragenter", h, options...)
}

func (e *htmlTFoot) OnDragLeave(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dragleave", h, options...)
}

func (e *htmlTFoot) OnDragOver(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dragover", h, options...)
}

func (e *htmlTFoot) OnDragStart(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("dragstart", h, options...)
}

func (e *htmlTFoot) OnDrop(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("drop", h, options...)
}

func (e *htmlTFoot) OnFocus(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("focus", h, options...)
}

func (e *htmlTFoot) OnInput(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("input", h, options...)
}

func (e *htmlTFoot) OnInvalid(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("invalid", h, options...)
}

func (e *htmlTFoot) OnKeyDown(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("keydown", h, options...)
}

func (e *htmlTFoot) OnKeyPress(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("keypress", h, options...)
}

func (e *htmlTFoot) OnKeyUp(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("keyup", h, options...)
}

func (e *htmlTFoot) OnMouseDown(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mousedown", h, options...)
}

func (e *htmlTFoot) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTFoot) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTFoot) OnMouseMove(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mousemove", h, options...)
}

func (e *htmlTFoot) OnMouseOut(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mouseout", h, options...)
}

func (e *htmlTFoot) OnMouseOver(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mouseover", h, options...)
}

func (e *htmlTFoot) OnMouseUp(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("mouseup", h, options...)
}

func (e *htmlTFoot) OnPaste(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("paste", h, options...)
}

func (e *htmlTFoot) OnReset(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("reset", h, options...)
}

func (e *htmlTFoot) OnScroll(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("scroll", h, options...)
}

func (e *htmlTFoot) OnSearch(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("search", h, options...)
}

func (e *htmlTFoot) OnSelect(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("select", h, options...)
}

func (e *htmlTFoot) OnSubmit(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("submit", h, options...)
}

func (e *htmlTFoot) OnWheel(h EventHandler, options ...EventOption) HTMLTFoot {
	return e.On("wheel", h, options...)
}

func (e *htmlTFoot) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTFoot) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTFoot) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTFoot) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTFoot) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTFoot) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "th" HTML element.
type HTMLTh interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTh

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTh

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTh

	// Denotes abbreviated content for header cells to provide clarity on shortened terms.
	Abbr(format string, v ...any) HTMLTh

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTh

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTh

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTh

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTh

	// Denotes how many columns a table cell should span across, allowing cells to occupy space of multiple columns.
	ColSpan(v int) HTMLTh

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTh

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTh

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTh

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTh

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTh

	// Designates one or more header cells to which a table cell is related.
	Headers(format string, v ...any) HTMLTh

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTh

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTh

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTh

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTh

	// Determines how many rows a table cell will span vertically.
	Rowspan(v int) HTMLTh

	// Defines the set of cells a header cell provides header information for. Uses the given format and values.
	Scope(format string, v ...any) HTMLTh

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTh

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTh

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTh

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTh

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTh

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTh

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTh

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTh

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTh

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTh

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTh

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTh

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTh

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTh

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTh

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTh

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTh

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTh

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTh

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTh
}

// Returns an HTML element that represents a header cell in a table.
func Th() HTMLTh {
	e := &htmlTh{
		htmlElement: htmlElement{
			tag:           "th",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTh struct {
	htmlElement
}

func (e *htmlTh) Body(v ...UI) HTMLTh {
	return e.setBody(FilterUIElems(v...)).(*htmlTh)
}

func (e *htmlTh) Text(v any) HTMLTh {
	return e.Body(Text(v))
}

func (e *htmlTh) Textf(format string, v ...any) HTMLTh {
	return e.Body(Textf(format, v...))
}

func (e *htmlTh) Abbr(format string, v ...any) HTMLTh {
	e.setAttr("abbr", FormatString(format, v...))
	return e
}

func (e *htmlTh) AccessKey(format string, v ...any) HTMLTh {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTh) Aria(k string, v any) HTMLTh {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTh) Attr(n string, v any) HTMLTh {
	e.setAttr(n, v)
	return e
}

func (e *htmlTh) Class(v ...string) HTMLTh {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTh) ColSpan(v int) HTMLTh {
	e.setAttr("colspan", v)
	return e
}

func (e *htmlTh) ContentEditable(v bool) HTMLTh {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTh) DataSet(k string, v any) HTMLTh {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTh) DataSets(ds map[string]any) HTMLTh {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTh) Dir(format string, v ...any) HTMLTh {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTh) Draggable(v bool) HTMLTh {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTh) Headers(format string, v ...any) HTMLTh {
	e.setAttr("headers", FormatString(format, v...))
	return e
}

func (e *htmlTh) Hidden(v bool) HTMLTh {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTh) ID(format string, v ...any) HTMLTh {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTh) Lang(format string, v ...any) HTMLTh {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTh) Role(format string, v ...any) HTMLTh {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTh) Rowspan(v int) HTMLTh {
	e.setAttr("rowspan", v)
	return e
}

func (e *htmlTh) Scope(format string, v ...any) HTMLTh {
	e.setAttr("scope", FormatString(format, v...))
	return e
}

func (e *htmlTh) Spellcheck(v bool) HTMLTh {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTh) Style(k, format string, v ...any) HTMLTh {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTh) Styles(s map[string]string) HTMLTh {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTh) TabIndex(v int) HTMLTh {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTh) Title(format string, v ...any) HTMLTh {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTh) On(event string, h EventHandler, options ...EventOption) HTMLTh {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTh) OnBlur(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("blur", h, options...)
}

func (e *htmlTh) OnChange(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("change", h, options...)
}

func (e *htmlTh) OnClick(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("click", h, options...)
}

func (e *htmlTh) OnContextMenu(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTh) OnCopy(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("copy", h, options...)
}

func (e *htmlTh) OnCut(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("cut", h, options...)
}

func (e *htmlTh) OnDblClick(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dblclick", h, options...)
}

func (e *htmlTh) OnDrag(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("drag", h, options...)
}

func (e *htmlTh) OnDragEnd(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dragend", h, options...)
}

func (e *htmlTh) OnDragEnter(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dragenter", h, options...)
}

func (e *htmlTh) OnDragLeave(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dragleave", h, options...)
}

func (e *htmlTh) OnDragOver(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dragover", h, options...)
}

func (e *htmlTh) OnDragStart(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("dragstart", h, options...)
}

func (e *htmlTh) OnDrop(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("drop", h, options...)
}

func (e *htmlTh) OnFocus(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("focus", h, options...)
}

func (e *htmlTh) OnInput(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("input", h, options...)
}

func (e *htmlTh) OnInvalid(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("invalid", h, options...)
}

func (e *htmlTh) OnKeyDown(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("keydown", h, options...)
}

func (e *htmlTh) OnKeyPress(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("keypress", h, options...)
}

func (e *htmlTh) OnKeyUp(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("keyup", h, options...)
}

func (e *htmlTh) OnMouseDown(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mousedown", h, options...)
}

func (e *htmlTh) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTh) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTh) OnMouseMove(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mousemove", h, options...)
}

func (e *htmlTh) OnMouseOut(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mouseout", h, options...)
}

func (e *htmlTh) OnMouseOver(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mouseover", h, options...)
}

func (e *htmlTh) OnMouseUp(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("mouseup", h, options...)
}

func (e *htmlTh) OnPaste(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("paste", h, options...)
}

func (e *htmlTh) OnReset(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("reset", h, options...)
}

func (e *htmlTh) OnScroll(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("scroll", h, options...)
}

func (e *htmlTh) OnSearch(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("search", h, options...)
}

func (e *htmlTh) OnSelect(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("select", h, options...)
}

func (e *htmlTh) OnSubmit(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("submit", h, options...)
}

func (e *htmlTh) OnWheel(h EventHandler, options ...EventOption) HTMLTh {
	return e.On("wheel", h, options...)
}

func (e *htmlTh) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTh) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTh) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTh) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTh) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTh) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "thead" HTML element.
type HTMLTHead interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTHead

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTHead

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTHead

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTHead

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTHead

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTHead

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTHead

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTHead

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTHead

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTHead

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTHead

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTHead

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTHead

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTHead

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTHead

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTHead

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTHead

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTHead

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTHead

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTHead

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTHead

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTHead

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTHead

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTHead

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTHead

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTHead
}

// Returns an HTML element that groups the header rows in a table.
func THead() HTMLTHead {
	e := &htmlTHead{
		htmlElement: htmlElement{
			tag:           "thead",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTHead struct {
	htmlElement
}

func (e *htmlTHead) Body(v ...UI) HTMLTHead {
	return e.setBody(FilterUIElems(v...)).(*htmlTHead)
}

func (e *htmlTHead) Text(v any) HTMLTHead {
	return e.Body(Text(v))
}

func (e *htmlTHead) Textf(format string, v ...any) HTMLTHead {
	return e.Body(Textf(format, v...))
}

func (e *htmlTHead) AccessKey(format string, v ...any) HTMLTHead {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTHead) Aria(k string, v any) HTMLTHead {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTHead) Attr(n string, v any) HTMLTHead {
	e.setAttr(n, v)
	return e
}

func (e *htmlTHead) Class(v ...string) HTMLTHead {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTHead) ContentEditable(v bool) HTMLTHead {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTHead) DataSet(k string, v any) HTMLTHead {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTHead) DataSets(ds map[string]any) HTMLTHead {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTHead) Dir(format string, v ...any) HTMLTHead {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTHead) Draggable(v bool) HTMLTHead {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTHead) Hidden(v bool) HTMLTHead {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTHead) ID(format string, v ...any) HTMLTHead {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTHead) Lang(format string, v ...any) HTMLTHead {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTHead) Role(format string, v ...any) HTMLTHead {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTHead) Spellcheck(v bool) HTMLTHead {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTHead) Style(k, format string, v ...any) HTMLTHead {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTHead) Styles(s map[string]string) HTMLTHead {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTHead) TabIndex(v int) HTMLTHead {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTHead) Title(format string, v ...any) HTMLTHead {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTHead) On(event string, h EventHandler, options ...EventOption) HTMLTHead {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTHead) OnBlur(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("blur", h, options...)
}

func (e *htmlTHead) OnChange(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("change", h, options...)
}

func (e *htmlTHead) OnClick(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("click", h, options...)
}

func (e *htmlTHead) OnContextMenu(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTHead) OnCopy(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("copy", h, options...)
}

func (e *htmlTHead) OnCut(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("cut", h, options...)
}

func (e *htmlTHead) OnDblClick(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dblclick", h, options...)
}

func (e *htmlTHead) OnDrag(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("drag", h, options...)
}

func (e *htmlTHead) OnDragEnd(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dragend", h, options...)
}

func (e *htmlTHead) OnDragEnter(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dragenter", h, options...)
}

func (e *htmlTHead) OnDragLeave(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dragleave", h, options...)
}

func (e *htmlTHead) OnDragOver(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dragover", h, options...)
}

func (e *htmlTHead) OnDragStart(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("dragstart", h, options...)
}

func (e *htmlTHead) OnDrop(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("drop", h, options...)
}

func (e *htmlTHead) OnFocus(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("focus", h, options...)
}

func (e *htmlTHead) OnInput(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("input", h, options...)
}

func (e *htmlTHead) OnInvalid(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("invalid", h, options...)
}

func (e *htmlTHead) OnKeyDown(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("keydown", h, options...)
}

func (e *htmlTHead) OnKeyPress(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("keypress", h, options...)
}

func (e *htmlTHead) OnKeyUp(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("keyup", h, options...)
}

func (e *htmlTHead) OnMouseDown(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mousedown", h, options...)
}

func (e *htmlTHead) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTHead) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTHead) OnMouseMove(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mousemove", h, options...)
}

func (e *htmlTHead) OnMouseOut(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mouseout", h, options...)
}

func (e *htmlTHead) OnMouseOver(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mouseover", h, options...)
}

func (e *htmlTHead) OnMouseUp(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("mouseup", h, options...)
}

func (e *htmlTHead) OnPaste(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("paste", h, options...)
}

func (e *htmlTHead) OnReset(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("reset", h, options...)
}

func (e *htmlTHead) OnScroll(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("scroll", h, options...)
}

func (e *htmlTHead) OnSearch(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("search", h, options...)
}

func (e *htmlTHead) OnSelect(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("select", h, options...)
}

func (e *htmlTHead) OnSubmit(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("submit", h, options...)
}

func (e *htmlTHead) OnWheel(h EventHandler, options ...EventOption) HTMLTHead {
	return e.On("wheel", h, options...)
}

func (e *htmlTHead) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTHead) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTHead) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTHead) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTHead) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTHead) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "time" HTML element.
type HTMLTime interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTime

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTime

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTime

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTime

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTime

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTime

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTime

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTime

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTime

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTime

	// Represents the date and time, often used in context with machine-readable equivalents of time-related content.
	DateTime(format string, v ...any) HTMLTime

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTime

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTime

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTime

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTime

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTime

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTime

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTime

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTime

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTime

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTime

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTime

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTime

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTime

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTime

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTime

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTime

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTime

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTime

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTime

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTime

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTime

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTime

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTime

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTime

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTime

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTime
}

// Returns an HTML element that represents a specific period or a single point in time.
func Time() HTMLTime {
	e := &htmlTime{
		htmlElement: htmlElement{
			tag:           "time",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTime struct {
	htmlElement
}

func (e *htmlTime) Body(v ...UI) HTMLTime {
	return e.setBody(FilterUIElems(v...)).(*htmlTime)
}

func (e *htmlTime) Text(v any) HTMLTime {
	return e.Body(Text(v))
}

func (e *htmlTime) Textf(format string, v ...any) HTMLTime {
	return e.Body(Textf(format, v...))
}

func (e *htmlTime) AccessKey(format string, v ...any) HTMLTime {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTime) Aria(k string, v any) HTMLTime {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTime) Attr(n string, v any) HTMLTime {
	e.setAttr(n, v)
	return e
}

func (e *htmlTime) Class(v ...string) HTMLTime {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTime) ContentEditable(v bool) HTMLTime {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTime) DataSet(k string, v any) HTMLTime {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTime) DataSets(ds map[string]any) HTMLTime {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTime) DateTime(format string, v ...any) HTMLTime {
	e.setAttr("datetime", FormatString(format, v...))
	return e
}

func (e *htmlTime) Dir(format string, v ...any) HTMLTime {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTime) Draggable(v bool) HTMLTime {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTime) Hidden(v bool) HTMLTime {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTime) ID(format string, v ...any) HTMLTime {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTime) Lang(format string, v ...any) HTMLTime {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTime) Role(format string, v ...any) HTMLTime {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTime) Spellcheck(v bool) HTMLTime {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTime) Style(k, format string, v ...any) HTMLTime {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTime) Styles(s map[string]string) HTMLTime {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTime) TabIndex(v int) HTMLTime {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTime) Title(format string, v ...any) HTMLTime {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTime) On(event string, h EventHandler, options ...EventOption) HTMLTime {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTime) OnBlur(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("blur", h, options...)
}

func (e *htmlTime) OnChange(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("change", h, options...)
}

func (e *htmlTime) OnClick(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("click", h, options...)
}

func (e *htmlTime) OnContextMenu(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTime) OnCopy(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("copy", h, options...)
}

func (e *htmlTime) OnCut(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("cut", h, options...)
}

func (e *htmlTime) OnDblClick(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dblclick", h, options...)
}

func (e *htmlTime) OnDrag(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("drag", h, options...)
}

func (e *htmlTime) OnDragEnd(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dragend", h, options...)
}

func (e *htmlTime) OnDragEnter(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dragenter", h, options...)
}

func (e *htmlTime) OnDragLeave(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dragleave", h, options...)
}

func (e *htmlTime) OnDragOver(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dragover", h, options...)
}

func (e *htmlTime) OnDragStart(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("dragstart", h, options...)
}

func (e *htmlTime) OnDrop(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("drop", h, options...)
}

func (e *htmlTime) OnFocus(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("focus", h, options...)
}

func (e *htmlTime) OnInput(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("input", h, options...)
}

func (e *htmlTime) OnInvalid(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("invalid", h, options...)
}

func (e *htmlTime) OnKeyDown(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("keydown", h, options...)
}

func (e *htmlTime) OnKeyPress(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("keypress", h, options...)
}

func (e *htmlTime) OnKeyUp(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("keyup", h, options...)
}

func (e *htmlTime) OnMouseDown(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mousedown", h, options...)
}

func (e *htmlTime) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTime) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTime) OnMouseMove(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mousemove", h, options...)
}

func (e *htmlTime) OnMouseOut(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mouseout", h, options...)
}

func (e *htmlTime) OnMouseOver(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mouseover", h, options...)
}

func (e *htmlTime) OnMouseUp(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("mouseup", h, options...)
}

func (e *htmlTime) OnPaste(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("paste", h, options...)
}

func (e *htmlTime) OnReset(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("reset", h, options...)
}

func (e *htmlTime) OnScroll(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("scroll", h, options...)
}

func (e *htmlTime) OnSearch(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("search", h, options...)
}

func (e *htmlTime) OnSelect(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("select", h, options...)
}

func (e *htmlTime) OnSubmit(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("submit", h, options...)
}

func (e *htmlTime) OnWheel(h EventHandler, options ...EventOption) HTMLTime {
	return e.On("wheel", h, options...)
}

func (e *htmlTime) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTime) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTime) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTime) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTime) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTime) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "title" HTML element.
type HTMLTitle interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTitle

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTitle

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTitle

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTitle

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTitle

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTitle

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTitle

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTitle

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTitle

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTitle

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTitle

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTitle

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTitle

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTitle

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTitle

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTitle

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTitle

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTitle

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTitle

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTitle

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTitle

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTitle
}

// Returns an HTML element that specifies the title of the document, shown in the browser's title bar or tab.
func Title() HTMLTitle {
	e := &htmlTitle{
		htmlElement: htmlElement{
			tag:           "title",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTitle struct {
	htmlElement
}

func (e *htmlTitle) Body(v ...UI) HTMLTitle {
	return e.setBody(FilterUIElems(v...)).(*htmlTitle)
}

func (e *htmlTitle) Text(v any) HTMLTitle {
	return e.Body(Text(v))
}

func (e *htmlTitle) Textf(format string, v ...any) HTMLTitle {
	return e.Body(Textf(format, v...))
}

func (e *htmlTitle) AccessKey(format string, v ...any) HTMLTitle {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTitle) Aria(k string, v any) HTMLTitle {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTitle) Attr(n string, v any) HTMLTitle {
	e.setAttr(n, v)
	return e
}

func (e *htmlTitle) Class(v ...string) HTMLTitle {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTitle) ContentEditable(v bool) HTMLTitle {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTitle) DataSet(k string, v any) HTMLTitle {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTitle) DataSets(ds map[string]any) HTMLTitle {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTitle) Dir(format string, v ...any) HTMLTitle {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTitle) Draggable(v bool) HTMLTitle {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTitle) Hidden(v bool) HTMLTitle {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTitle) ID(format string, v ...any) HTMLTitle {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTitle) Lang(format string, v ...any) HTMLTitle {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTitle) Role(format string, v ...any) HTMLTitle {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTitle) Spellcheck(v bool) HTMLTitle {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTitle) Style(k, format string, v ...any) HTMLTitle {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTitle) Styles(s map[string]string) HTMLTitle {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTitle) TabIndex(v int) HTMLTitle {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTitle) Title(format string, v ...any) HTMLTitle {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTitle) On(event string, h EventHandler, options ...EventOption) HTMLTitle {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTitle) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTitle) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTitle) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTitle) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTitle) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTitle) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "tr" HTML element.
type HTMLTr interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLTr

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLTr

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLTr

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLTr

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLTr

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLTr

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLTr

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLTr

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLTr

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLTr

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLTr

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLTr

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLTr

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLTr

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLTr

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLTr

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLTr

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLTr

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLTr

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLTr

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLTr

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLTr

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLTr

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLTr

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLTr

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLTr

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLTr

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLTr

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLTr

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLTr

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLTr

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLTr

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLTr

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLTr

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLTr

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLTr
}

// Returns an HTML element that represents a row of cells in a table.
func Tr() HTMLTr {
	e := &htmlTr{
		htmlElement: htmlElement{
			tag:           "tr",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlTr struct {
	htmlElement
}

func (e *htmlTr) Body(v ...UI) HTMLTr {
	return e.setBody(FilterUIElems(v...)).(*htmlTr)
}

func (e *htmlTr) Text(v any) HTMLTr {
	return e.Body(Text(v))
}

func (e *htmlTr) Textf(format string, v ...any) HTMLTr {
	return e.Body(Textf(format, v...))
}

func (e *htmlTr) AccessKey(format string, v ...any) HTMLTr {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlTr) Aria(k string, v any) HTMLTr {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTr) Attr(n string, v any) HTMLTr {
	e.setAttr(n, v)
	return e
}

func (e *htmlTr) Class(v ...string) HTMLTr {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlTr) ContentEditable(v bool) HTMLTr {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlTr) DataSet(k string, v any) HTMLTr {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlTr) DataSets(ds map[string]any) HTMLTr {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlTr) Dir(format string, v ...any) HTMLTr {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlTr) Draggable(v bool) HTMLTr {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlTr) Hidden(v bool) HTMLTr {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlTr) ID(format string, v ...any) HTMLTr {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlTr) Lang(format string, v ...any) HTMLTr {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlTr) Role(format string, v ...any) HTMLTr {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlTr) Spellcheck(v bool) HTMLTr {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlTr) Style(k, format string, v ...any) HTMLTr {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlTr) Styles(s map[string]string) HTMLTr {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlTr) TabIndex(v int) HTMLTr {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlTr) Title(format string, v ...any) HTMLTr {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlTr) On(event string, h EventHandler, options ...EventOption) HTMLTr {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlTr) OnBlur(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("blur", h, options...)
}

func (e *htmlTr) OnChange(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("change", h, options...)
}

func (e *htmlTr) OnClick(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("click", h, options...)
}

func (e *htmlTr) OnContextMenu(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("contextmenu", h, options...)
}

func (e *htmlTr) OnCopy(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("copy", h, options...)
}

func (e *htmlTr) OnCut(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("cut", h, options...)
}

func (e *htmlTr) OnDblClick(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dblclick", h, options...)
}

func (e *htmlTr) OnDrag(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("drag", h, options...)
}

func (e *htmlTr) OnDragEnd(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dragend", h, options...)
}

func (e *htmlTr) OnDragEnter(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dragenter", h, options...)
}

func (e *htmlTr) OnDragLeave(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dragleave", h, options...)
}

func (e *htmlTr) OnDragOver(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dragover", h, options...)
}

func (e *htmlTr) OnDragStart(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("dragstart", h, options...)
}

func (e *htmlTr) OnDrop(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("drop", h, options...)
}

func (e *htmlTr) OnFocus(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("focus", h, options...)
}

func (e *htmlTr) OnInput(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("input", h, options...)
}

func (e *htmlTr) OnInvalid(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("invalid", h, options...)
}

func (e *htmlTr) OnKeyDown(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("keydown", h, options...)
}

func (e *htmlTr) OnKeyPress(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("keypress", h, options...)
}

func (e *htmlTr) OnKeyUp(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("keyup", h, options...)
}

func (e *htmlTr) OnMouseDown(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mousedown", h, options...)
}

func (e *htmlTr) OnMouseEnter(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mouseenter", h, options...)
}

func (e *htmlTr) OnMouseLeave(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mouseleave", h, options...)
}

func (e *htmlTr) OnMouseMove(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mousemove", h, options...)
}

func (e *htmlTr) OnMouseOut(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mouseout", h, options...)
}

func (e *htmlTr) OnMouseOver(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mouseover", h, options...)
}

func (e *htmlTr) OnMouseUp(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("mouseup", h, options...)
}

func (e *htmlTr) OnPaste(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("paste", h, options...)
}

func (e *htmlTr) OnReset(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("reset", h, options...)
}

func (e *htmlTr) OnScroll(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("scroll", h, options...)
}

func (e *htmlTr) OnSearch(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("search", h, options...)
}

func (e *htmlTr) OnSelect(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("select", h, options...)
}

func (e *htmlTr) OnSubmit(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("submit", h, options...)
}

func (e *htmlTr) OnWheel(h EventHandler, options ...EventOption) HTMLTr {
	return e.On("wheel", h, options...)
}

func (e *htmlTr) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlTr) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlTr) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlTr) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlTr) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlTr) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "u" HTML element.
type HTMLU interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLU

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLU

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLU

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLU

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLU

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLU

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLU

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLU

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLU

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLU

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLU

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLU

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLU

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLU

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLU

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLU

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLU

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLU

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLU

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLU

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLU

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLU

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLU

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLU

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLU

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLU

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLU

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLU

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLU

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLU

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLU

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLU

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLU

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLU

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLU

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLU

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLU

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLU

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLU

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLU

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLU

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLU

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLU

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLU

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLU

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLU

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLU

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLU

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLU

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLU
}

// Returns an HTML element that renders text with an underline, typically indicating misspelled text or proper names in Chinese text.
func U() HTMLU {
	e := &htmlU{
		htmlElement: htmlElement{
			tag:           "u",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlU struct {
	htmlElement
}

func (e *htmlU) Body(v ...UI) HTMLU {
	return e.setBody(FilterUIElems(v...)).(*htmlU)
}

func (e *htmlU) Text(v any) HTMLU {
	return e.Body(Text(v))
}

func (e *htmlU) Textf(format string, v ...any) HTMLU {
	return e.Body(Textf(format, v...))
}

func (e *htmlU) AccessKey(format string, v ...any) HTMLU {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlU) Aria(k string, v any) HTMLU {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlU) Attr(n string, v any) HTMLU {
	e.setAttr(n, v)
	return e
}

func (e *htmlU) Class(v ...string) HTMLU {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlU) ContentEditable(v bool) HTMLU {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlU) DataSet(k string, v any) HTMLU {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlU) DataSets(ds map[string]any) HTMLU {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlU) Dir(format string, v ...any) HTMLU {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlU) Draggable(v bool) HTMLU {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlU) Hidden(v bool) HTMLU {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlU) ID(format string, v ...any) HTMLU {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlU) Lang(format string, v ...any) HTMLU {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlU) Role(format string, v ...any) HTMLU {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlU) Spellcheck(v bool) HTMLU {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlU) Style(k, format string, v ...any) HTMLU {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlU) Styles(s map[string]string) HTMLU {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlU) TabIndex(v int) HTMLU {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlU) Title(format string, v ...any) HTMLU {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlU) On(event string, h EventHandler, options ...EventOption) HTMLU {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlU) OnBlur(h EventHandler, options ...EventOption) HTMLU {
	return e.On("blur", h, options...)
}

func (e *htmlU) OnChange(h EventHandler, options ...EventOption) HTMLU {
	return e.On("change", h, options...)
}

func (e *htmlU) OnClick(h EventHandler, options ...EventOption) HTMLU {
	return e.On("click", h, options...)
}

func (e *htmlU) OnContextMenu(h EventHandler, options ...EventOption) HTMLU {
	return e.On("contextmenu", h, options...)
}

func (e *htmlU) OnCopy(h EventHandler, options ...EventOption) HTMLU {
	return e.On("copy", h, options...)
}

func (e *htmlU) OnCut(h EventHandler, options ...EventOption) HTMLU {
	return e.On("cut", h, options...)
}

func (e *htmlU) OnDblClick(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dblclick", h, options...)
}

func (e *htmlU) OnDrag(h EventHandler, options ...EventOption) HTMLU {
	return e.On("drag", h, options...)
}

func (e *htmlU) OnDragEnd(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dragend", h, options...)
}

func (e *htmlU) OnDragEnter(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dragenter", h, options...)
}

func (e *htmlU) OnDragLeave(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dragleave", h, options...)
}

func (e *htmlU) OnDragOver(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dragover", h, options...)
}

func (e *htmlU) OnDragStart(h EventHandler, options ...EventOption) HTMLU {
	return e.On("dragstart", h, options...)
}

func (e *htmlU) OnDrop(h EventHandler, options ...EventOption) HTMLU {
	return e.On("drop", h, options...)
}

func (e *htmlU) OnFocus(h EventHandler, options ...EventOption) HTMLU {
	return e.On("focus", h, options...)
}

func (e *htmlU) OnInput(h EventHandler, options ...EventOption) HTMLU {
	return e.On("input", h, options...)
}

func (e *htmlU) OnInvalid(h EventHandler, options ...EventOption) HTMLU {
	return e.On("invalid", h, options...)
}

func (e *htmlU) OnKeyDown(h EventHandler, options ...EventOption) HTMLU {
	return e.On("keydown", h, options...)
}

func (e *htmlU) OnKeyPress(h EventHandler, options ...EventOption) HTMLU {
	return e.On("keypress", h, options...)
}

func (e *htmlU) OnKeyUp(h EventHandler, options ...EventOption) HTMLU {
	return e.On("keyup", h, options...)
}

func (e *htmlU) OnMouseDown(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mousedown", h, options...)
}

func (e *htmlU) OnMouseEnter(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mouseenter", h, options...)
}

func (e *htmlU) OnMouseLeave(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mouseleave", h, options...)
}

func (e *htmlU) OnMouseMove(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mousemove", h, options...)
}

func (e *htmlU) OnMouseOut(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mouseout", h, options...)
}

func (e *htmlU) OnMouseOver(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mouseover", h, options...)
}

func (e *htmlU) OnMouseUp(h EventHandler, options ...EventOption) HTMLU {
	return e.On("mouseup", h, options...)
}

func (e *htmlU) OnPaste(h EventHandler, options ...EventOption) HTMLU {
	return e.On("paste", h, options...)
}

func (e *htmlU) OnReset(h EventHandler, options ...EventOption) HTMLU {
	return e.On("reset", h, options...)
}

func (e *htmlU) OnScroll(h EventHandler, options ...EventOption) HTMLU {
	return e.On("scroll", h, options...)
}

func (e *htmlU) OnSearch(h EventHandler, options ...EventOption) HTMLU {
	return e.On("search", h, options...)
}

func (e *htmlU) OnSelect(h EventHandler, options ...EventOption) HTMLU {
	return e.On("select", h, options...)
}

func (e *htmlU) OnSubmit(h EventHandler, options ...EventOption) HTMLU {
	return e.On("submit", h, options...)
}

func (e *htmlU) OnWheel(h EventHandler, options ...EventOption) HTMLU {
	return e.On("wheel", h, options...)
}

func (e *htmlU) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlU) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlU) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlU) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlU) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlU) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "ul" HTML element.
type HTMLUl interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLUl

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLUl

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLUl

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLUl

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLUl

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLUl

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLUl

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLUl

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLUl

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLUl

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLUl

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLUl

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLUl

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLUl

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLUl

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLUl

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLUl

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLUl

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLUl

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLUl

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLUl

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLUl

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLUl

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLUl

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLUl

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLUl

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLUl

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLUl

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLUl

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLUl

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLUl

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLUl

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLUl

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLUl

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLUl

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLUl
}

// Returns an HTML element that represents an unordered list of items.
func Ul() HTMLUl {
	e := &htmlUl{
		htmlElement: htmlElement{
			tag:           "ul",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlUl struct {
	htmlElement
}

func (e *htmlUl) Body(v ...UI) HTMLUl {
	return e.setBody(FilterUIElems(v...)).(*htmlUl)
}

func (e *htmlUl) Text(v any) HTMLUl {
	return e.Body(Text(v))
}

func (e *htmlUl) Textf(format string, v ...any) HTMLUl {
	return e.Body(Textf(format, v...))
}

func (e *htmlUl) AccessKey(format string, v ...any) HTMLUl {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlUl) Aria(k string, v any) HTMLUl {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlUl) Attr(n string, v any) HTMLUl {
	e.setAttr(n, v)
	return e
}

func (e *htmlUl) Class(v ...string) HTMLUl {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlUl) ContentEditable(v bool) HTMLUl {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlUl) DataSet(k string, v any) HTMLUl {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlUl) DataSets(ds map[string]any) HTMLUl {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlUl) Dir(format string, v ...any) HTMLUl {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlUl) Draggable(v bool) HTMLUl {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlUl) Hidden(v bool) HTMLUl {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlUl) ID(format string, v ...any) HTMLUl {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlUl) Lang(format string, v ...any) HTMLUl {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlUl) Role(format string, v ...any) HTMLUl {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlUl) Spellcheck(v bool) HTMLUl {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlUl) Style(k, format string, v ...any) HTMLUl {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlUl) Styles(s map[string]string) HTMLUl {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlUl) TabIndex(v int) HTMLUl {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlUl) Title(format string, v ...any) HTMLUl {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlUl) On(event string, h EventHandler, options ...EventOption) HTMLUl {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlUl) OnBlur(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("blur", h, options...)
}

func (e *htmlUl) OnChange(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("change", h, options...)
}

func (e *htmlUl) OnClick(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("click", h, options...)
}

func (e *htmlUl) OnContextMenu(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("contextmenu", h, options...)
}

func (e *htmlUl) OnCopy(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("copy", h, options...)
}

func (e *htmlUl) OnCut(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("cut", h, options...)
}

func (e *htmlUl) OnDblClick(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dblclick", h, options...)
}

func (e *htmlUl) OnDrag(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("drag", h, options...)
}

func (e *htmlUl) OnDragEnd(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dragend", h, options...)
}

func (e *htmlUl) OnDragEnter(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dragenter", h, options...)
}

func (e *htmlUl) OnDragLeave(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dragleave", h, options...)
}

func (e *htmlUl) OnDragOver(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dragover", h, options...)
}

func (e *htmlUl) OnDragStart(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("dragstart", h, options...)
}

func (e *htmlUl) OnDrop(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("drop", h, options...)
}

func (e *htmlUl) OnFocus(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("focus", h, options...)
}

func (e *htmlUl) OnInput(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("input", h, options...)
}

func (e *htmlUl) OnInvalid(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("invalid", h, options...)
}

func (e *htmlUl) OnKeyDown(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("keydown", h, options...)
}

func (e *htmlUl) OnKeyPress(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("keypress", h, options...)
}

func (e *htmlUl) OnKeyUp(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("keyup", h, options...)
}

func (e *htmlUl) OnMouseDown(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mousedown", h, options...)
}

func (e *htmlUl) OnMouseEnter(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mouseenter", h, options...)
}

func (e *htmlUl) OnMouseLeave(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mouseleave", h, options...)
}

func (e *htmlUl) OnMouseMove(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mousemove", h, options...)
}

func (e *htmlUl) OnMouseOut(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mouseout", h, options...)
}

func (e *htmlUl) OnMouseOver(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mouseover", h, options...)
}

func (e *htmlUl) OnMouseUp(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("mouseup", h, options...)
}

func (e *htmlUl) OnPaste(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("paste", h, options...)
}

func (e *htmlUl) OnReset(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("reset", h, options...)
}

func (e *htmlUl) OnScroll(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("scroll", h, options...)
}

func (e *htmlUl) OnSearch(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("search", h, options...)
}

func (e *htmlUl) OnSelect(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("select", h, options...)
}

func (e *htmlUl) OnSubmit(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("submit", h, options...)
}

func (e *htmlUl) OnWheel(h EventHandler, options ...EventOption) HTMLUl {
	return e.On("wheel", h, options...)
}

func (e *htmlUl) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlUl) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlUl) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlUl) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlUl) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlUl) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "var" HTML element.
type HTMLVar interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLVar

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLVar

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLVar

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLVar

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLVar

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLVar

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLVar

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLVar

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLVar

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLVar

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLVar

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLVar

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLVar

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLVar

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLVar

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLVar

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLVar

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLVar

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLVar

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLVar

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLVar

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLVar

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLVar

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLVar

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLVar

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLVar

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLVar

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLVar

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLVar

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLVar

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLVar

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLVar

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLVar

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLVar

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLVar

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLVar
}

// Returns an HTML element that displays a name of a variable, typically shown in an italic typeface.
func Var() HTMLVar {
	e := &htmlVar{
		htmlElement: htmlElement{
			tag:           "var",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlVar struct {
	htmlElement
}

func (e *htmlVar) Body(v ...UI) HTMLVar {
	return e.setBody(FilterUIElems(v...)).(*htmlVar)
}

func (e *htmlVar) Text(v any) HTMLVar {
	return e.Body(Text(v))
}

func (e *htmlVar) Textf(format string, v ...any) HTMLVar {
	return e.Body(Textf(format, v...))
}

func (e *htmlVar) AccessKey(format string, v ...any) HTMLVar {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlVar) Aria(k string, v any) HTMLVar {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlVar) Attr(n string, v any) HTMLVar {
	e.setAttr(n, v)
	return e
}

func (e *htmlVar) Class(v ...string) HTMLVar {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlVar) ContentEditable(v bool) HTMLVar {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlVar) DataSet(k string, v any) HTMLVar {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlVar) DataSets(ds map[string]any) HTMLVar {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlVar) Dir(format string, v ...any) HTMLVar {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlVar) Draggable(v bool) HTMLVar {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlVar) Hidden(v bool) HTMLVar {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlVar) ID(format string, v ...any) HTMLVar {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlVar) Lang(format string, v ...any) HTMLVar {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlVar) Role(format string, v ...any) HTMLVar {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlVar) Spellcheck(v bool) HTMLVar {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlVar) Style(k, format string, v ...any) HTMLVar {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlVar) Styles(s map[string]string) HTMLVar {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlVar) TabIndex(v int) HTMLVar {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlVar) Title(format string, v ...any) HTMLVar {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlVar) On(event string, h EventHandler, options ...EventOption) HTMLVar {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlVar) OnBlur(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("blur", h, options...)
}

func (e *htmlVar) OnChange(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("change", h, options...)
}

func (e *htmlVar) OnClick(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("click", h, options...)
}

func (e *htmlVar) OnContextMenu(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("contextmenu", h, options...)
}

func (e *htmlVar) OnCopy(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("copy", h, options...)
}

func (e *htmlVar) OnCut(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("cut", h, options...)
}

func (e *htmlVar) OnDblClick(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dblclick", h, options...)
}

func (e *htmlVar) OnDrag(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("drag", h, options...)
}

func (e *htmlVar) OnDragEnd(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dragend", h, options...)
}

func (e *htmlVar) OnDragEnter(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dragenter", h, options...)
}

func (e *htmlVar) OnDragLeave(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dragleave", h, options...)
}

func (e *htmlVar) OnDragOver(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dragover", h, options...)
}

func (e *htmlVar) OnDragStart(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("dragstart", h, options...)
}

func (e *htmlVar) OnDrop(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("drop", h, options...)
}

func (e *htmlVar) OnFocus(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("focus", h, options...)
}

func (e *htmlVar) OnInput(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("input", h, options...)
}

func (e *htmlVar) OnInvalid(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("invalid", h, options...)
}

func (e *htmlVar) OnKeyDown(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("keydown", h, options...)
}

func (e *htmlVar) OnKeyPress(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("keypress", h, options...)
}

func (e *htmlVar) OnKeyUp(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("keyup", h, options...)
}

func (e *htmlVar) OnMouseDown(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mousedown", h, options...)
}

func (e *htmlVar) OnMouseEnter(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mouseenter", h, options...)
}

func (e *htmlVar) OnMouseLeave(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mouseleave", h, options...)
}

func (e *htmlVar) OnMouseMove(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mousemove", h, options...)
}

func (e *htmlVar) OnMouseOut(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mouseout", h, options...)
}

func (e *htmlVar) OnMouseOver(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mouseover", h, options...)
}

func (e *htmlVar) OnMouseUp(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("mouseup", h, options...)
}

func (e *htmlVar) OnPaste(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("paste", h, options...)
}

func (e *htmlVar) OnReset(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("reset", h, options...)
}

func (e *htmlVar) OnScroll(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("scroll", h, options...)
}

func (e *htmlVar) OnSearch(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("search", h, options...)
}

func (e *htmlVar) OnSelect(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("select", h, options...)
}

func (e *htmlVar) OnSubmit(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("submit", h, options...)
}

func (e *htmlVar) OnWheel(h EventHandler, options ...EventOption) HTMLVar {
	return e.On("wheel", h, options...)
}

func (e *htmlVar) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlVar) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlVar) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlVar) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlVar) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlVar) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "video" HTML element.
type HTMLVideo interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLVideo

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLVideo

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLVideo

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLVideo

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLVideo

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLVideo

	// Automatically plays audio or video elements once they're ready, enhancing media responsiveness.
	AutoPlay(v bool) HTMLVideo

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLVideo

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLVideo

	// Indicates the presence of user interface controls for audio or video elements, such as play or pause buttons.
	Controls(v bool) HTMLVideo

	// Controls how cross-origin requests are managed for the element, supporting secure content integration from different origins.
	CrossOrigin(format string, v ...any) HTMLVideo

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLVideo

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLVideo

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLVideo

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLVideo

	// Sets the height of the element, measured in pixels.
	Height(v int) HTMLVideo

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLVideo

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLVideo

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLVideo

	// Indicates that the audio or video should replay from the beginning upon reaching its end.
	Loop(v bool) HTMLVideo

	// Ensures that the video's audio playback is muted.
	Muted(v bool) HTMLVideo

	// Sets an image displayed before a video starts playing or while it's loading.
	Poster(format string, v ...any) HTMLVideo

	// Indicates the preferred loading method for audio/video upon page load.
	Preload(format string, v ...any) HTMLVideo

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLVideo

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLVideo

	// Provides the URL source of embedded content or media. Uses the given format and values.
	Src(format string, v ...any) HTMLVideo

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLVideo

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLVideo

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLVideo

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLVideo

	// Sets the width of the element.
	Width(v int) HTMLVideo

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when media loading is aborted.
	OnAbort(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler when media has buffered sufficiently to begin playback.
	OnCanPlay(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when media can be played through without buffering interruptions.
	OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler upon cue changes within a track element.
	OnCueChange(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler when the media's duration changes.
	OnDurationChange(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when media unexpectedly becomes unavailable.
	OnEmptied(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when media playback reaches the end.
	OnEnded(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the given handler when an error is encountered.
	OnError(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when media loading commences.
	OnLoadStart(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler as media data finishes loading.
	OnLoadedData(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when metadata (like duration and dimensions) are fully loaded.
	OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler when media playback is paused.
	OnPause(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when media starts its playback.
	OnPlay(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler once the media has initiated playback.
	OnPlaying(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler while the browser fetches media data.
	OnProgress(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when playback rate changes (e.g., slow motion or fast forward).
	OnRateChange(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler post seeking completion.
	OnSeeked(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler during the seeking process.
	OnSeeking(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler when media data fetching stalls.
	OnStalled(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when media data fetching is suspended.
	OnSuspend(h EventHandler, options ...EventOption) HTMLVideo

	// Executes the handler when the media's playback position changes.
	OnTimeUpdate(h EventHandler, options ...EventOption) HTMLVideo

	// Invokes the handler upon volume changes or muting.
	OnVolumeChange(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the handler when media pauses, awaiting further buffering.
	OnWaiting(h EventHandler, options ...EventOption) HTMLVideo

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLVideo
}

// Returns an HTML element that embeds video content, allowing for playback of video files or streams.
func Video() HTMLVideo {
	e := &htmlVideo{
		htmlElement: htmlElement{
			tag:           "video",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlVideo struct {
	htmlElement
}

func (e *htmlVideo) Body(v ...UI) HTMLVideo {
	return e.setBody(FilterUIElems(v...)).(*htmlVideo)
}

func (e *htmlVideo) Text(v any) HTMLVideo {
	return e.Body(Text(v))
}

func (e *htmlVideo) Textf(format string, v ...any) HTMLVideo {
	return e.Body(Textf(format, v...))
}

func (e *htmlVideo) AccessKey(format string, v ...any) HTMLVideo {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Aria(k string, v any) HTMLVideo {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlVideo) Attr(n string, v any) HTMLVideo {
	e.setAttr(n, v)
	return e
}

func (e *htmlVideo) AutoPlay(v bool) HTMLVideo {
	e.setAttr("autoplay", v)
	return e
}

func (e *htmlVideo) Class(v ...string) HTMLVideo {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlVideo) ContentEditable(v bool) HTMLVideo {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlVideo) Controls(v bool) HTMLVideo {
	e.setAttr("controls", v)
	return e
}

func (e *htmlVideo) CrossOrigin(format string, v ...any) HTMLVideo {
	e.setAttr("crossorigin", FormatString(format, v...))
	return e
}

func (e *htmlVideo) DataSet(k string, v any) HTMLVideo {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlVideo) DataSets(ds map[string]any) HTMLVideo {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlVideo) Dir(format string, v ...any) HTMLVideo {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Draggable(v bool) HTMLVideo {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlVideo) Height(v int) HTMLVideo {
	e.setAttr("height", v)
	return e
}

func (e *htmlVideo) Hidden(v bool) HTMLVideo {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlVideo) ID(format string, v ...any) HTMLVideo {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Lang(format string, v ...any) HTMLVideo {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Loop(v bool) HTMLVideo {
	e.setAttr("loop", v)
	return e
}

func (e *htmlVideo) Muted(v bool) HTMLVideo {
	e.setAttr("muted", v)
	return e
}

func (e *htmlVideo) Poster(format string, v ...any) HTMLVideo {
	e.setAttr("poster", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Preload(format string, v ...any) HTMLVideo {
	e.setAttr("preload", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Role(format string, v ...any) HTMLVideo {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Spellcheck(v bool) HTMLVideo {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlVideo) Src(format string, v ...any) HTMLVideo {
	e.setAttr("src", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Style(k, format string, v ...any) HTMLVideo {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlVideo) Styles(s map[string]string) HTMLVideo {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlVideo) TabIndex(v int) HTMLVideo {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlVideo) Title(format string, v ...any) HTMLVideo {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlVideo) Width(v int) HTMLVideo {
	e.setAttr("width", v)
	return e
}

func (e *htmlVideo) On(event string, h EventHandler, options ...EventOption) HTMLVideo {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlVideo) OnAbort(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("abort", h, options...)
}

func (e *htmlVideo) OnBlur(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("blur", h, options...)
}

func (e *htmlVideo) OnCanPlay(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("canplay", h, options...)
}

func (e *htmlVideo) OnCanPlayThrough(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("canplaythrough", h, options...)
}

func (e *htmlVideo) OnChange(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("change", h, options...)
}

func (e *htmlVideo) OnClick(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("click", h, options...)
}

func (e *htmlVideo) OnContextMenu(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("contextmenu", h, options...)
}

func (e *htmlVideo) OnCopy(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("copy", h, options...)
}

func (e *htmlVideo) OnCueChange(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("cuechange", h, options...)
}

func (e *htmlVideo) OnCut(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("cut", h, options...)
}

func (e *htmlVideo) OnDblClick(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dblclick", h, options...)
}

func (e *htmlVideo) OnDrag(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("drag", h, options...)
}

func (e *htmlVideo) OnDragEnd(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dragend", h, options...)
}

func (e *htmlVideo) OnDragEnter(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dragenter", h, options...)
}

func (e *htmlVideo) OnDragLeave(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dragleave", h, options...)
}

func (e *htmlVideo) OnDragOver(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dragover", h, options...)
}

func (e *htmlVideo) OnDragStart(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("dragstart", h, options...)
}

func (e *htmlVideo) OnDrop(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("drop", h, options...)
}

func (e *htmlVideo) OnDurationChange(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("durationchange", h, options...)
}

func (e *htmlVideo) OnEmptied(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("emptied", h, options...)
}

func (e *htmlVideo) OnEnded(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("ended", h, options...)
}

func (e *htmlVideo) OnError(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("error", h, options...)
}

func (e *htmlVideo) OnFocus(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("focus", h, options...)
}

func (e *htmlVideo) OnInput(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("input", h, options...)
}

func (e *htmlVideo) OnInvalid(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("invalid", h, options...)
}

func (e *htmlVideo) OnKeyDown(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("keydown", h, options...)
}

func (e *htmlVideo) OnKeyPress(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("keypress", h, options...)
}

func (e *htmlVideo) OnKeyUp(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("keyup", h, options...)
}

func (e *htmlVideo) OnLoadStart(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("loadstart", h, options...)
}

func (e *htmlVideo) OnLoadedData(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("loadeddata", h, options...)
}

func (e *htmlVideo) OnLoadedMetaData(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("loadedmetadata", h, options...)
}

func (e *htmlVideo) OnMouseDown(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mousedown", h, options...)
}

func (e *htmlVideo) OnMouseEnter(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mouseenter", h, options...)
}

func (e *htmlVideo) OnMouseLeave(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mouseleave", h, options...)
}

func (e *htmlVideo) OnMouseMove(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mousemove", h, options...)
}

func (e *htmlVideo) OnMouseOut(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mouseout", h, options...)
}

func (e *htmlVideo) OnMouseOver(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mouseover", h, options...)
}

func (e *htmlVideo) OnMouseUp(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("mouseup", h, options...)
}

func (e *htmlVideo) OnPaste(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("paste", h, options...)
}

func (e *htmlVideo) OnPause(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("pause", h, options...)
}

func (e *htmlVideo) OnPlay(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("play", h, options...)
}

func (e *htmlVideo) OnPlaying(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("playing", h, options...)
}

func (e *htmlVideo) OnProgress(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("progress", h, options...)
}

func (e *htmlVideo) OnRateChange(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("ratechange", h, options...)
}

func (e *htmlVideo) OnReset(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("reset", h, options...)
}

func (e *htmlVideo) OnScroll(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("scroll", h, options...)
}

func (e *htmlVideo) OnSearch(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("search", h, options...)
}

func (e *htmlVideo) OnSeeked(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("seeked", h, options...)
}

func (e *htmlVideo) OnSeeking(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("seeking", h, options...)
}

func (e *htmlVideo) OnSelect(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("select", h, options...)
}

func (e *htmlVideo) OnStalled(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("stalled", h, options...)
}

func (e *htmlVideo) OnSubmit(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("submit", h, options...)
}

func (e *htmlVideo) OnSuspend(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("suspend", h, options...)
}

func (e *htmlVideo) OnTimeUpdate(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("timeupdate", h, options...)
}

func (e *htmlVideo) OnVolumeChange(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("volumechange", h, options...)
}

func (e *htmlVideo) OnWaiting(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("waiting", h, options...)
}

func (e *htmlVideo) OnWheel(h EventHandler, options ...EventOption) HTMLVideo {
	return e.On("wheel", h, options...)
}

func (e *htmlVideo) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlVideo) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlVideo) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlVideo) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlVideo) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlVideo) setBody(v []UI) HTML {
	e.children = v
	return e
}

// The interface that represents a "wbr" HTML element.
type HTMLWbr interface {
	HTML

	// Sets the content of the element.
	Body(elems ...UI) HTMLWbr

	// Sets the content of the element with a text node containing the stringified given value.
	Text(v any) HTMLWbr

	// Sets the content of the element with a text node formatted according to a format specifier.
	Textf(format string, v ...any) HTMLWbr

	// Assigns a keyboard shortcut for quick element activation or focus, enhancing user experience.
	AccessKey(format string, v ...any) HTMLWbr

	// Allocates ARIA roles and properties to the element to enhance accessibility for users with disabilities. Can be called multiple times to assign various roles and properties.
	Aria(k string, v any) HTMLWbr

	// Sets an attribute with its associated value, allowing for flexible HTML customization.
	Attr(n string, v any) HTMLWbr

	// Assigns one or more classnames to an element, linking it to styles defined in a stylesheet. Can be called multiple times to assign multiple classnames.
	Class(v ...string) HTMLWbr

	// Determines if the content of an element is editable by the user, allowing for in-page content modification.
	ContentEditable(v bool) HTMLWbr

	// Allows for storage of custom data specific to individual elements. Can be called multiple times to store multiple sets of data, often used for scripting purposes.
	DataSet(k string, v any) HTMLWbr

	// Denotes datasets linked to an element and can store multiple sets of data.
	DataSets(ds map[string]any) HTMLWbr

	// Defines the text direction for the content within an element, such as 'ltr' (left-to-right) or 'rtl' (right-to-left).
	Dir(format string, v ...any) HTMLWbr

	// Specifies if an element can be dragged by the user, supporting drag-and-drop operations.
	Draggable(v bool) HTMLWbr

	// Marks an element as currently irrelevant or not yet relevant.
	Hidden(v bool) HTMLWbr

	// Assigns a unique identifier to an element.
	ID(format string, v ...any) HTMLWbr

	// Declares the language of the element's content.
	Lang(format string, v ...any) HTMLWbr

	// Communicates the intended function or meaning of an element to assistive technologies.
	Role(format string, v ...any) HTMLWbr

	// Indicates whether the element's content is subject to spell and grammar checks.
	Spellcheck(v bool) HTMLWbr

	// Assigns inline CSS styling to an element. Can be called multiple times to set multiple CSS styles.
	Style(k, format string, v ...any) HTMLWbr

	// Allocates multiple CSS styles to an element. Accepts multiple styling definitions.
	Styles(s map[string]string) HTMLWbr

	// Determines the tabbing sequence of an element within the document navigation.
	TabIndex(v int) HTMLWbr

	// Provides additional information about an element, typically displayed as a tooltip. Can be called with the desired title format and content.
	Title(format string, v ...any) HTMLWbr

	// Invokes the specified handler when the corresponding event is triggered.
	On(event string, h EventHandler, options ...EventOption) HTMLWbr

	// Executes the given handler when the element loses focus.
	OnBlur(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler when the element's value changes.
	OnChange(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler upon a mouse click on the element.
	OnClick(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the provided handler upon activation of a context menu.
	OnContextMenu(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the handler when content of an element is copied by the user.
	OnCopy(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the handler when the user cuts content from an element.
	OnCut(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the provided handler when the element is double-clicked by the mouse.
	OnDblClick(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the handler as an element is being dragged.
	OnDrag(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the handler at the conclusion of a drag operation.
	OnDragEnd(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the handler when an element is dragged onto a valid drop target.
	OnDragEnter(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the handler when an element exits a valid drop target.
	OnDragLeave(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the handler as an element is dragged over a valid drop target.
	OnDragOver(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the handler at the initiation of a drag operation.
	OnDragStart(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the handler when a dragged element is released onto a drop target.
	OnDrop(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the given handler when the element receives focus.
	OnFocus(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler when the element receives user input.
	OnInput(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the provided handler when the element is determined to be invalid.
	OnInvalid(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the specified handler when a user starts pressing a key.
	OnKeyDown(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the provided handler as a key is pressed by the user.
	OnKeyPress(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the given handler when a user releases a key.
	OnKeyUp(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the given handler as a mouse button is pressed on the element.
	OnMouseDown(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler when the mouse pointer first enters the element's boundaries.
	OnMouseEnter(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the provided handler when the mouse pointer leaves the element and its descendants.
	OnMouseLeave(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the given handler as the mouse pointer moves across the element.
	OnMouseMove(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler when the mouse pointer exits the element.
	OnMouseOut(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the provided handler as the mouse pointer hovers over the element.
	OnMouseOver(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the given handler when a mouse button is released above the element.
	OnMouseUp(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the handler as content is pasted into an element by the user.
	OnPaste(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the given handler upon clicking the Reset button within a form.
	OnReset(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the handler as an element's scrollbar is scrolled.
	OnScroll(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler when input is provided in a search field.
	OnSearch(h EventHandler, options ...EventOption) HTMLWbr

	// Invokes the provided handler after text within the element is selected.
	OnSelect(h EventHandler, options ...EventOption) HTMLWbr

	// Executes the given handler when the form undergoes submission.
	OnSubmit(h EventHandler, options ...EventOption) HTMLWbr

	// Triggers the specified handler as the mouse wheel scrolls over the element.
	OnWheel(h EventHandler, options ...EventOption) HTMLWbr
}

// Returns an HTML element that suggests an optimal position for a line break within text.
func Wbr() HTMLWbr {
	e := &htmlWbr{
		htmlElement: htmlElement{
			tag:           "wbr",
			isSelfClosing: false,
		},
	}

	return e
}

type htmlWbr struct {
	htmlElement
}

func (e *htmlWbr) Body(v ...UI) HTMLWbr {
	return e.setBody(FilterUIElems(v...)).(*htmlWbr)
}

func (e *htmlWbr) Text(v any) HTMLWbr {
	return e.Body(Text(v))
}

func (e *htmlWbr) Textf(format string, v ...any) HTMLWbr {
	return e.Body(Textf(format, v...))
}

func (e *htmlWbr) AccessKey(format string, v ...any) HTMLWbr {
	e.setAttr("accesskey", FormatString(format, v...))
	return e
}

func (e *htmlWbr) Aria(k string, v any) HTMLWbr {
	e.setAttr("aria-"+k, FormatString("%v", v))
	return e
}

func (e *htmlWbr) Attr(n string, v any) HTMLWbr {
	e.setAttr(n, v)
	return e
}

func (e *htmlWbr) Class(v ...string) HTMLWbr {
	e.setAttr("class", strings.Join(v, " "))
	return e
}

func (e *htmlWbr) ContentEditable(v bool) HTMLWbr {
	e.setAttr("contenteditable", v)
	return e
}

func (e *htmlWbr) DataSet(k string, v any) HTMLWbr {
	e.setAttr("data-"+k, FormatString("%v", v))
	return e
}

func (e *htmlWbr) DataSets(ds map[string]any) HTMLWbr {
	for k, v := range ds {
		e.DataSet(k, v)
	}
	return e
}

func (e *htmlWbr) Dir(format string, v ...any) HTMLWbr {
	e.setAttr("dir", FormatString(format, v...))
	return e
}

func (e *htmlWbr) Draggable(v bool) HTMLWbr {
	e.setAttr("draggable", v)
	return e
}

func (e *htmlWbr) Hidden(v bool) HTMLWbr {
	e.setAttr("hidden", v)
	return e
}

func (e *htmlWbr) ID(format string, v ...any) HTMLWbr {
	e.setAttr("id", FormatString(format, v...))
	return e
}

func (e *htmlWbr) Lang(format string, v ...any) HTMLWbr {
	e.setAttr("lang", FormatString(format, v...))
	return e
}

func (e *htmlWbr) Role(format string, v ...any) HTMLWbr {
	e.setAttr("role", FormatString(format, v...))
	return e
}

func (e *htmlWbr) Spellcheck(v bool) HTMLWbr {
	s := "false"
	if v {
		s = "true"
	}

	e.setAttr("spellcheck", s)
	return e
}

func (e *htmlWbr) Style(k, format string, v ...any) HTMLWbr {
	e.setAttr("style", k+":"+FormatString(format, v...))
	return e
}

func (e *htmlWbr) Styles(s map[string]string) HTMLWbr {
	for k, v := range s {
		e.Style(k, v)
	}
	return e
}

func (e *htmlWbr) TabIndex(v int) HTMLWbr {
	e.setAttr("tabindex", v)
	return e
}

func (e *htmlWbr) Title(format string, v ...any) HTMLWbr {
	e.setAttr("title", FormatString(format, v...))
	return e
}

func (e *htmlWbr) On(event string, h EventHandler, options ...EventOption) HTMLWbr {
	e.setEventHandler(event, h, options...)
	return e
}

func (e *htmlWbr) OnBlur(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("blur", h, options...)
}

func (e *htmlWbr) OnChange(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("change", h, options...)
}

func (e *htmlWbr) OnClick(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("click", h, options...)
}

func (e *htmlWbr) OnContextMenu(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("contextmenu", h, options...)
}

func (e *htmlWbr) OnCopy(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("copy", h, options...)
}

func (e *htmlWbr) OnCut(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("cut", h, options...)
}

func (e *htmlWbr) OnDblClick(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dblclick", h, options...)
}

func (e *htmlWbr) OnDrag(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("drag", h, options...)
}

func (e *htmlWbr) OnDragEnd(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dragend", h, options...)
}

func (e *htmlWbr) OnDragEnter(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dragenter", h, options...)
}

func (e *htmlWbr) OnDragLeave(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dragleave", h, options...)
}

func (e *htmlWbr) OnDragOver(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dragover", h, options...)
}

func (e *htmlWbr) OnDragStart(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("dragstart", h, options...)
}

func (e *htmlWbr) OnDrop(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("drop", h, options...)
}

func (e *htmlWbr) OnFocus(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("focus", h, options...)
}

func (e *htmlWbr) OnInput(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("input", h, options...)
}

func (e *htmlWbr) OnInvalid(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("invalid", h, options...)
}

func (e *htmlWbr) OnKeyDown(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("keydown", h, options...)
}

func (e *htmlWbr) OnKeyPress(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("keypress", h, options...)
}

func (e *htmlWbr) OnKeyUp(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("keyup", h, options...)
}

func (e *htmlWbr) OnMouseDown(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mousedown", h, options...)
}

func (e *htmlWbr) OnMouseEnter(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mouseenter", h, options...)
}

func (e *htmlWbr) OnMouseLeave(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mouseleave", h, options...)
}

func (e *htmlWbr) OnMouseMove(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mousemove", h, options...)
}

func (e *htmlWbr) OnMouseOut(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mouseout", h, options...)
}

func (e *htmlWbr) OnMouseOver(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mouseover", h, options...)
}

func (e *htmlWbr) OnMouseUp(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("mouseup", h, options...)
}

func (e *htmlWbr) OnPaste(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("paste", h, options...)
}

func (e *htmlWbr) OnReset(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("reset", h, options...)
}

func (e *htmlWbr) OnScroll(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("scroll", h, options...)
}

func (e *htmlWbr) OnSearch(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("search", h, options...)
}

func (e *htmlWbr) OnSelect(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("select", h, options...)
}

func (e *htmlWbr) OnSubmit(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("submit", h, options...)
}

func (e *htmlWbr) OnWheel(h EventHandler, options ...EventOption) HTMLWbr {
	return e.On("wheel", h, options...)
}

func (e *htmlWbr) setDepth(v uint) UI {
	e.treeDepth = v
	return e
}

func (e *htmlWbr) setJSElement(v Value) HTML {
	e.jsElement = v
	return e
}

func (e *htmlWbr) setAttrs(v attributes) HTML {
	e.attributes = v
	return e
}

func (e *htmlWbr) setEvents(v eventHandlers) HTML {
	e.eventHandlers = v
	return e
}

func (e *htmlWbr) setParent(v UI) UI {
	e.parentElement = v
	return e
}

func (e *htmlWbr) setBody(v []UI) HTML {
	e.children = v
	return e
}
